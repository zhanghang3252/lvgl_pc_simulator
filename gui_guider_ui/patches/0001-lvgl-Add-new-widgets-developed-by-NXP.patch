From 1183d0a8ef2cb58fe6949bc2a868b55baaf134a1 Mon Sep 17 00:00:00 2001
From: Zongchun Yu <zongchun.yu@nxp.com>
Date: Mon, 17 Jun 2024 17:28:19 +0800
Subject: [PATCH] lvgl: Add new widgets developed by NXP

Signed-off-by: Zongchun Yu <zongchun.yu@nxp.com>
---
 Kconfig                                       |   44 +
 .../widgets/animimg/lv_example_animimg_1.c    |    2 +-
 .../widgets/animimg/lv_example_animimg_1.py   |    2 +-
 lv_conf_template.h                            |   25 +
 src/extra/libs/barcode/code128.c              |  582 ++++++++
 src/extra/libs/barcode/code128.h              |   47 +
 src/extra/libs/barcode/lv_barcode.c           |  215 +++
 src/extra/libs/barcode/lv_barcode.h           |  108 ++
 src/extra/libs/fsdrv/lv_fs_rawfs.c            |  322 +++++
 src/extra/libs/fsdrv/lv_fsdrv.h               |   16 +
 src/extra/libs/lv_libs.h                      |    1 +
 src/extra/lv_extra.c                          |    4 +
 src/extra/others/ime/lv_ime_pinyin.c          |    2 +-
 src/extra/themes/default/lv_theme_default.c   |   88 +-
 .../widgets/analogclock/lv_analogclock.c      |  803 +++++++++++
 .../widgets/analogclock/lv_analogclock.h      |  317 +++++
 src/extra/widgets/animimg/lv_animimg.c        |   53 +-
 src/extra/widgets/animimg/lv_animimg.h        |   37 +-
 src/extra/widgets/carousel/lv_carousel.c      |  208 +++
 src/extra/widgets/carousel/lv_carousel.h      |   75 +
 src/extra/widgets/dclock/lv_dclock.c          |  437 ++++++
 src/extra/widgets/dclock/lv_dclock.h          |  130 ++
 src/extra/widgets/keyboard/chinese_library.h  | 1237 +++++++++++++++++
 src/extra/widgets/keyboard/lv_zh_keyboard.c   |  751 ++++++++++
 src/extra/widgets/keyboard/lv_zh_keyboard.h   |  190 +++
 src/extra/widgets/lv_widgets.h                |    7 +
 src/extra/widgets/radiobtn/lv_radiobtn.c      |  385 +++++
 src/extra/widgets/radiobtn/lv_radiobtn.h      |  137 ++
 .../widgets/textprogress/lv_textprogress.c    |  140 ++
 .../widgets/textprogress/lv_textprogress.h    |  100 ++
 src/extra/widgets/video/lv_video.c            |  602 ++++++++
 src/extra/widgets/video/lv_video.h            |  114 ++
 src/lv_conf_internal.h                        |  134 ++
 src/misc/lv_anim.c                            |   43 +-
 src/misc/lv_anim.h                            |   19 +
 src/widgets/lv_arc.c                          |    5 +
 src/widgets/lv_btnmatrix.c                    |   21 +-
 37 files changed, 7382 insertions(+), 21 deletions(-)
 create mode 100644 src/extra/libs/barcode/code128.c
 create mode 100644 src/extra/libs/barcode/code128.h
 create mode 100644 src/extra/libs/barcode/lv_barcode.c
 create mode 100644 src/extra/libs/barcode/lv_barcode.h
 create mode 100644 src/extra/libs/fsdrv/lv_fs_rawfs.c
 create mode 100644 src/extra/widgets/analogclock/lv_analogclock.c
 create mode 100644 src/extra/widgets/analogclock/lv_analogclock.h
 create mode 100644 src/extra/widgets/carousel/lv_carousel.c
 create mode 100644 src/extra/widgets/carousel/lv_carousel.h
 create mode 100644 src/extra/widgets/dclock/lv_dclock.c
 create mode 100644 src/extra/widgets/dclock/lv_dclock.h
 create mode 100644 src/extra/widgets/keyboard/chinese_library.h
 create mode 100644 src/extra/widgets/keyboard/lv_zh_keyboard.c
 create mode 100644 src/extra/widgets/keyboard/lv_zh_keyboard.h
 create mode 100644 src/extra/widgets/radiobtn/lv_radiobtn.c
 create mode 100644 src/extra/widgets/radiobtn/lv_radiobtn.h
 create mode 100644 src/extra/widgets/textprogress/lv_textprogress.c
 create mode 100644 src/extra/widgets/textprogress/lv_textprogress.h
 create mode 100644 src/extra/widgets/video/lv_video.c
 create mode 100644 src/extra/widgets/video/lv_video.h

diff --git a/Kconfig b/Kconfig
index e4867bf02..13f8c6551 100644
--- a/Kconfig
+++ b/Kconfig
@@ -811,6 +811,9 @@ menu "LVGL configuration"
     endmenu
 
     menu "Extra Widgets"
+        config LV_USE_ANALOGCLOCK
+            bool "Analogclock."
+            default y if !LV_CONF_MINIMAL
         config LV_USE_ANIMIMG
             bool "Anim image."
             default y if !LV_CONF_MINIMAL
@@ -828,18 +831,31 @@ menu "LVGL configuration"
             bool "Use calendar header dropdown"
             depends on LV_USE_CALENDAR
             default y
+        config LV_USE_CAROUSEL
+            bool "Carousel."
+            default y if !LV_CONF_MINIMAL
         config LV_USE_CHART
             bool "Chart."
             default y if !LV_CONF_MINIMAL
         config LV_USE_COLORWHEEL
             bool "Colorwheel."
             default y if !LV_CONF_MINIMAL
+        config LV_USE_DCLOCK
+            bool "Dclock."
+            default y if !LV_CONF_MINIMAL
         config LV_USE_IMGBTN
             bool "Imgbtn."
             default y if !LV_CONF_MINIMAL
         config LV_USE_KEYBOARD
             bool "Keyboard."
             default y if !LV_CONF_MINIMAL
+        config LV_USE_ZH_KEYBOARD
+            bool "Chinese Keyboard."
+            default n
+        config LV_ZH_KEYBOARD_MINI
+            bool "Use minimal chinese library."
+            default y
+            depends on LV_USE_ZH_KEYBOARD
         config LV_USE_LED
             bool "LED."
             default y if !LV_CONF_MINIMAL
@@ -855,6 +871,9 @@ menu "LVGL configuration"
         config LV_USE_MSGBOX
             bool "Msgbox."
             default y if !LV_CONF_MINIMAL
+        config LV_USE_RADIOBTN
+            bool "Radiobtn."
+            default y if !LV_CONF_MINIMAL
         config LV_USE_SPAN
             bool "span"
             default y if !LV_CONF_MINIMAL
@@ -871,9 +890,15 @@ menu "LVGL configuration"
         config LV_USE_TABVIEW
             bool "Tabview."
             default y if !LV_CONF_MINIMAL
+        config LV_USE_TEXTPROGRESS
+            bool "Textprogress."
+            default y if !LV_CONF_MINIMAL
         config LV_USE_TILEVIEW
             bool "Tileview"
             default y if !LV_CONF_MINIMAL
+        config LV_USE_VIDEO
+            bool "Video"
+            default n
         config LV_USE_WIN
             bool "Win"
             default y if !LV_CONF_MINIMAL
@@ -976,6 +1001,20 @@ menu "LVGL configuration"
             default 0
             depends on LV_USE_FS_LITTLEFS
 
+        config LV_USE_FS_RAWFS
+            bool "File system on top of Raw binary"
+        config LV_FS_RAWFS_LETTER
+            int "Set an upper cased letter on which the drive will accessible (e.g. 'A' i.e. 65)"
+            default 70
+            depends on LV_USE_FS_RAWFS
+        config LV_FS_RAWFS_XIP
+            bool "RAW binaries can be copied directly"
+            depends on LV_USE_FS_RAWFS
+        config LV_FS_RAWFS_XIP_BASE_ADDR
+            hex "Base address from where raw binaries can be copied directly"
+            default 0xFFFFFFFF
+            depends on LV_FS_RAWFS_XIP
+
         config LV_USE_PNG
             bool "PNG decoder library"
 
@@ -990,6 +1029,11 @@ menu "LVGL configuration"
 
         config LV_USE_QRCODE
             bool "QR code library"
+            default y if !LV_CONF_MINIMAL
+
+        config LV_USE_BARCODE
+            bool "Barcode library"
+            default y if !LV_CONF_MINIMAL
 
         config LV_USE_FREETYPE
             bool "FreeType library"
diff --git a/examples/widgets/animimg/lv_example_animimg_1.c b/examples/widgets/animimg/lv_example_animimg_1.c
index 4341b6fec..4f814578c 100644
--- a/examples/widgets/animimg/lv_example_animimg_1.c
+++ b/examples/widgets/animimg/lv_example_animimg_1.c
@@ -14,7 +14,7 @@ void lv_example_animimg_1(void)
 {
     lv_obj_t * animimg0 = lv_animimg_create(lv_scr_act());
     lv_obj_center(animimg0);
-    lv_animimg_set_src(animimg0, (const void **) anim_imgs, 3);
+    lv_animimg_set_src(animimg0, (const void **) anim_imgs, 3, false);
     lv_animimg_set_duration(animimg0, 1000);
     lv_animimg_set_repeat_count(animimg0, LV_ANIM_REPEAT_INFINITE);
     lv_animimg_start(animimg0);
diff --git a/examples/widgets/animimg/lv_example_animimg_1.py b/examples/widgets/animimg/lv_example_animimg_1.py
index f3a31fd02..25dba785a 100644
--- a/examples/widgets/animimg/lv_example_animimg_1.py
+++ b/examples/widgets/animimg/lv_example_animimg_1.py
@@ -45,7 +45,7 @@ anim_imgs[2] = lv.img_dsc_t({
 
 animimg0 = lv.animimg(lv.scr_act())
 animimg0.center()
-animimg0.set_src(anim_imgs, 3)
+animimg0.set_src(anim_imgs, 3, False)
 animimg0.set_duration(1000)
 animimg0.set_repeat_count(lv.ANIM_REPEAT.INFINITE)
 animimg0.start()
diff --git a/lv_conf_template.h b/lv_conf_template.h
index bed77fb8f..05ec7ce7d 100644
--- a/lv_conf_template.h
+++ b/lv_conf_template.h
@@ -518,6 +518,8 @@
 /*-----------
  * Widgets
  *----------*/
+#define LV_USE_ANALOGCLOCK 1
+
 #define LV_USE_ANIMIMG    1
 
 #define LV_USE_CALENDAR   1
@@ -534,10 +536,14 @@
     #define LV_USE_CALENDAR_HEADER_DROPDOWN 1
 #endif  /*LV_USE_CALENDAR*/
 
+#define LV_USE_CAROUSEL   1
+
 #define LV_USE_CHART      1
 
 #define LV_USE_COLORWHEEL 1
 
+#define LV_USE_DCLOCK     1
+
 #define LV_USE_IMGBTN     1
 
 #define LV_USE_KEYBOARD   1
@@ -552,6 +558,8 @@
 
 #define LV_USE_MSGBOX     1
 
+#define LV_USE_RADIOBTN   1
+
 #define LV_USE_SPAN       1
 #if LV_USE_SPAN
     /*A line text can contain maximum num of span descriptor */
@@ -566,8 +574,15 @@
 
 #define LV_USE_TILEVIEW   1
 
+#define LV_USE_VIDEO      1
+
 #define LV_USE_WIN        1
 
+#define LV_USE_ZH_KEYBOARD 1
+#if LV_USE_ZH_KEYBOARD
+    #define LV_ZH_KEYBOARD_MINI 1
+#endif
+
 /*-----------
  * Themes
  *----------*/
@@ -646,6 +661,16 @@
     #define LV_FS_LITTLEFS_CACHE_SIZE 0    /*>0 to cache this number of bytes in lv_fs_read()*/
 #endif
 
+/*API for RAWFS (needs to be added separately).*/
+#define LV_USE_FS_RAWFS 0
+#if LV_USE_FS_RAWFS
+    #define LV_FS_RAWFS_LETTER 'F'     /*Set an upper cased letter on which the drive will accessible (e.g. 'A')*/
+#define LV_FS_RAWFS_XIP 0
+#if LV_FS_RAWFS_XIP
+    #define LV_FS_RAWFS_XIP_BASE_ADDR 0xFFFFFFFF
+#endif
+#endif
+
 /*PNG decoder library*/
 #define LV_USE_PNG 0
 
diff --git a/src/extra/libs/barcode/code128.c b/src/extra/libs/barcode/code128.c
new file mode 100644
index 000000000..0a94ede44
--- /dev/null
+++ b/src/extra/libs/barcode/code128.c
@@ -0,0 +1,582 @@
+// Copyright (c) 2013, LKC Technologies, Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// Redistributions of source code must retain the above copyright notice, this
+// list of conditions and the following disclaimer. Redistributions in binary
+// form must reproduce the above copyright notice, this list of conditions and
+// the following disclaimer in the documentation and/or other materials
+// provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
+// HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "../../../lvgl.h"
+#if LV_USE_BARCODE
+
+#include "code128.h"
+#include <string.h>
+
+#define CODE128_MALLOC      lv_mem_alloc
+#define CODE128_REALLOC     lv_mem_realloc
+#define CODE128_FREE        lv_mem_free
+#define CODE128_MEMSET      lv_memset
+#define CODE128_STRLEN      strlen
+#define CODE128_ASSERT      LV_ASSERT
+
+#define CODE128_QUIET_ZONE_LEN 10
+#define CODE128_CHAR_LEN       11
+#define CODE128_STOP_CODE_LEN  13
+
+#define CODE128_START_CODE_A 103
+#define CODE128_START_CODE_B 104
+#define CODE128_START_CODE_C 105
+
+#define CODE128_MODE_A    'a'
+#define CODE128_MODE_B    'b'
+#define CODE128_MODE_C    'c'
+
+#define CODE128_MIN_ENCODE_LEN (CODE128_QUIET_ZONE_LEN * 2 + CODE128_CHAR_LEN * 2 + CODE128_STOP_CODE_LEN)
+
+static const int code128_pattern[] = {
+    // value: pattern,     bar/space widths
+    1740, //   0: 11011001100, 212222
+    1644, //   1: 11001101100, 222122
+    1638, //   2: 11001100110, 222221
+    1176, //   3: 10010011000, 121223
+    1164, //   4: 10010001100, 121322
+    1100, //   5: 10001001100, 131222
+    1224, //   6: 10011001000, 122213
+    1220, //   7: 10011000100, 122312
+    1124, //   8: 10001100100, 132212
+    1608, //   9: 11001001000, 221213
+    1604, //  10: 11001000100, 221312
+    1572, //  11: 11000100100, 231212
+    1436, //  12: 10110011100, 112232
+    1244, //  13: 10011011100, 122132
+    1230, //  14: 10011001110, 122231
+    1484, //  15: 10111001100, 113222
+    1260, //  16: 10011101100, 123122
+    1254, //  17: 10011100110, 123221
+    1650, //  18: 11001110010, 223211
+    1628, //  19: 11001011100, 221132
+    1614, //  20: 11001001110, 221231
+    1764, //  21: 11011100100, 213212
+    1652, //  22: 11001110100, 223112
+    1902, //  23: 11101101110, 312131
+    1868, //  24: 11101001100, 311222
+    1836, //  25: 11100101100, 321122
+    1830, //  26: 11100100110, 321221
+    1892, //  27: 11101100100, 312212
+    1844, //  28: 11100110100, 322112
+    1842, //  29: 11100110010, 322211
+    1752, //  30: 11011011000, 212123
+    1734, //  31: 11011000110, 212321
+    1590, //  32: 11000110110, 232121
+    1304, //  33: 10100011000, 111323
+    1112, //  34: 10001011000, 131123
+    1094, //  35: 10001000110, 131321
+    1416, //  36: 10110001000, 112313
+    1128, //  37: 10001101000, 132113
+    1122, //  38: 10001100010, 132311
+    1672, //  39: 11010001000, 211313
+    1576, //  40: 11000101000, 231113
+    1570, //  41: 11000100010, 231311
+    1464, //  42: 10110111000, 112133
+    1422, //  43: 10110001110
+    1134, //  44: 10001101110
+    1496, //  45: 10111011000, 113123
+    1478, //  46: 10111000110, 113321
+    1142, //  47: 10001110110, 133121
+    1910, //  48: 11101110110, 313121
+    1678, //  49: 11010001110, 211331
+    1582, //  50: 11000101110, 231131
+    1768, //  51: 11011101000, 213113
+    1762, //  52: 11011100010, 213311
+    1774, //  53: 11011101110, 213131
+    1880, //  54: 11101011000, 311123
+    1862, //  55: 11101000110, 311321
+    1814, //  56: 11100010110, 331121
+    1896, //  57: 11101101000, 312113
+    1890, //  58: 11101100010, 312311
+    1818, //  59: 11100011010, 332111
+    1914, //  60: 11101111010, 314111
+    1602, //  61: 11001000010, 221411
+    1930, //  62: 11110001010, 431111
+    1328, //  63: 10100110000, 111224
+    1292, //  64: 10100001100, 111422
+    1200, //  65: 10010110000, 121124
+    1158, //  66: 10010000110, 121421
+    1068, //  67: 10000101100, 141122
+    1062, //  68: 10000100110, 141221
+    1424, //  69: 10110010000, 112214
+    1412, //  70: 10110000100, 112412
+    1232, //  71: 10011010000, 122114
+    1218, //  72: 10011000010, 122411
+    1076, //  73: 10000110100, 142112
+    1074, //  74: 10000110010, 142211
+    1554, //  75: 11000010010, 241211
+    1616, //  76: 11001010000, 221114
+    1978, //  77: 11110111010, 413111
+    1556, //  78: 11000010100, 241112
+    1146, //  79: 10001111010, 134111
+    1340, //  80: 10100111100, 111242
+    1212, //  81: 10010111100, 121142
+    1182, //  82: 10010011110, 121241
+    1508, //  83: 10111100100, 114212
+    1268, //  84: 10011110100, 124112
+    1266, //  85: 10011110010, 124211
+    1956, //  86: 11110100100, 411212
+    1940, //  87: 11110010100, 421112
+    1938, //  88: 11110010010, 421211
+    1758, //  89: 11011011110, 212141
+    1782, //  90: 11011110110, 214121
+    1974, //  91: 11110110110, 412121
+    1400, //  92: 10101111000, 111143
+    1310, //  93: 10100011110, 111341
+    1118, //  94: 10001011110, 131141
+    1512, //  95: 10111101000, 114113
+    1506, //  96: 10111100010, 114311
+    1960, //  97: 11110101000, 411113
+    1954, //  98: 11110100010, 411311
+    1502, //  99: 10111011110, 113141
+    1518, // 100: 10111101110, 114131
+    1886, // 101: 11101011110, 311141
+    1966, // 102: 11110101110, 411131
+    1668, // 103: 11010000100, 211412
+    1680, // 104: 11010010000, 211214
+    1692  // 105: 11010011100, 211232
+};
+
+static const int code128_stop_pattern = 6379; // 1100011101011, 2331112
+
+struct code128_step {
+    int prev_ix;                // Index of previous step, if any
+    const char * next_input;    // Remaining input
+    unsigned short len;         // The length of the pattern so far (includes this step)
+    char mode;                  // State for the current encoding
+    signed char code;           // What code should be written for this step
+};
+
+struct code128_state {
+    struct code128_step * steps;
+    int allocated_steps;
+    int current_ix;
+    int todo_ix;
+    int best_ix;
+
+    size_t maxlength;
+};
+
+size_t code128_estimate_len(const char * s)
+{
+    return CODE128_QUIET_ZONE_LEN
+           + CODE128_CHAR_LEN // start code
+           + CODE128_CHAR_LEN * (CODE128_STRLEN(s) * 11 / 10) // contents + 10% padding
+           + CODE128_CHAR_LEN // checksum
+           + CODE128_STOP_CODE_LEN
+           + CODE128_QUIET_ZONE_LEN;
+}
+
+static void code128_append_pattern(int pattern, int pattern_length, char * out)
+{
+    // All patterns have their first bit set by design
+    CODE128_ASSERT(pattern & (1 << (pattern_length - 1)));
+
+    int i;
+    for(i = pattern_length - 1; i >= 0; i--) {
+        // cast avoids warning: implicit conversion from 'int' to 'char' changes value from 255 to -1 [-Wconstant-conversion]
+        *out++ = (unsigned char)((pattern & (1 << i)) ? 255 : 0);
+    }
+}
+
+static int code128_append_code(int code, char * out)
+{
+    CODE128_ASSERT(code >= 0 && code < (int)(sizeof(code128_pattern) / sizeof(code128_pattern[0])));
+    code128_append_pattern(code128_pattern[code], CODE128_CHAR_LEN, out);
+    return CODE128_CHAR_LEN;
+}
+
+static int code128_append_stop_code(char * out)
+{
+    code128_append_pattern(code128_stop_pattern, CODE128_STOP_CODE_LEN, out);
+    return CODE128_STOP_CODE_LEN;
+}
+
+static signed char code128_switch_code(char from_mode, char to_mode)
+{
+    switch(from_mode) {
+        case CODE128_MODE_A:
+            switch(to_mode) {
+                case CODE128_MODE_B:
+                    return 100;
+                case CODE128_MODE_C:
+                    return 99;
+            }
+            break;
+
+        case CODE128_MODE_B:
+            switch(to_mode) {
+                case CODE128_MODE_A:
+                    return 101;
+                case CODE128_MODE_C:
+                    return 99;
+            }
+            break;
+
+        case CODE128_MODE_C:
+            switch(to_mode) {
+                case CODE128_MODE_B:
+                    return 100;
+                case CODE128_MODE_A:
+                    return 101;
+            }
+            break;
+        default:
+            break;
+    }
+
+    CODE128_ASSERT(0); // Invalid mode switch
+    return -1;
+}
+
+static signed char code128a_ascii_to_code(signed char value)
+{
+    if(value >= ' ' && value <= '_')
+        return (signed char)(value - ' ');
+    else if(value >= 0 && value < ' ')
+        return (signed char)(value + 64);
+    else if(value == (signed char)CODE128_FNC1)
+        return 102;
+    else if(value == (signed char)CODE128_FNC2)
+        return 97;
+    else if(value == (signed char)CODE128_FNC3)
+        return 96;
+    else if(value == (signed char)CODE128_FNC4)
+        return 101;
+    else
+        return -1;
+}
+
+static signed char code128b_ascii_to_code(signed char value)
+{
+    if(value >= ' ')  // value <= 127 is implied
+        return (signed char)(value - ' ');
+    else if(value == (signed char)CODE128_FNC1)
+        return 102;
+    else if(value == (signed char)CODE128_FNC2)
+        return 97;
+    else if(value == (signed char)CODE128_FNC3)
+        return 96;
+    else if(value == (signed char)CODE128_FNC4)
+        return 100;
+    else
+        return -1;
+}
+
+static signed char code128c_ascii_to_code(const char * values)
+{
+    if(values[0] == CODE128_FNC1)
+        return 102;
+
+    if(values[0] >= '0' && values[0] <= '9' &&
+       values[1] >= '0' && values[1] <= '9') {
+        char code = 10 * (values[0] - '0') + (values[1] - '0');
+        return code;
+    }
+
+    return -1;
+}
+
+static int code128_do_a_step(struct code128_step * base, int prev_ix, int ix)
+{
+    struct code128_step * previous_step = &base[prev_ix];
+    struct code128_step * step = &base[ix];
+
+    char value = *previous_step->next_input;
+    // NOTE: Currently we can't encode NULL
+    if(value == 0)
+        return 0;
+
+    step->code = code128a_ascii_to_code(value);
+    if(step->code < 0)
+        return 0;
+
+    step->prev_ix = prev_ix;
+    step->next_input = previous_step->next_input + 1;
+    step->mode = CODE128_MODE_A;
+    step->len = previous_step->len + CODE128_CHAR_LEN;
+    if(step->mode != previous_step->mode)
+        step->len += CODE128_CHAR_LEN; // Need to switch modes
+
+    return 1;
+}
+
+static int code128_do_b_step(struct code128_step * base, int prev_ix, int ix)
+{
+    struct code128_step * previous_step = &base[prev_ix];
+    struct code128_step * step = &base[ix];
+
+    char value = *previous_step->next_input;
+    // NOTE: Currently we can't encode NULL
+    if(value == 0)
+        return 0;
+
+    step->code = code128b_ascii_to_code(value);
+    if(step->code < 0)
+        return 0;
+
+    step->prev_ix = prev_ix;
+    step->next_input = previous_step->next_input + 1;
+    step->mode = CODE128_MODE_B;
+    step->len = previous_step->len + CODE128_CHAR_LEN;
+    if(step->mode != previous_step->mode)
+        step->len += CODE128_CHAR_LEN; // Need to switch modes
+
+    return 1;
+}
+
+static int code128_do_c_step(struct code128_step * base, int prev_ix, int ix)
+{
+    struct code128_step * previous_step = &base[prev_ix];
+    struct code128_step * step = &base[ix];
+
+    char value = *previous_step->next_input;
+    // NOTE: Currently we can't encode NULL
+    if(value == 0)
+        return 0;
+
+    step->code = code128c_ascii_to_code(previous_step->next_input);
+    if(step->code < 0)
+        return 0;
+
+    step->prev_ix = prev_ix;
+    step->next_input = previous_step->next_input + 1;
+
+    // Mode C consumes 2 characters for codes 0-99
+    if(step->code < 100)
+        step->next_input++;
+
+    step->mode = CODE128_MODE_C;
+    step->len = previous_step->len + CODE128_CHAR_LEN;
+    if(step->mode != previous_step->mode)
+        step->len += CODE128_CHAR_LEN; // Need to switch modes
+
+    return 1;
+}
+
+static struct code128_step * code128_alloc_step(struct code128_state * state)
+{
+    if(state->todo_ix >= state->allocated_steps) {
+        state->allocated_steps += 1024;
+        state->steps = (struct code128_step *) CODE128_REALLOC(state->steps,
+                                                               state->allocated_steps * sizeof(struct code128_step));
+    }
+
+    struct code128_step * step = &state->steps[state->todo_ix];
+
+    CODE128_MEMSET(step, 0, sizeof(*step));
+    return step;
+}
+
+static void code128_do_step(struct code128_state * state)
+{
+    struct code128_step * step = &state->steps[state->current_ix];
+    if(*step->next_input == 0) {
+        // Done, so see if we have a new shortest encoding.
+        if((step->len < state->maxlength) ||
+           (state->best_ix < 0 && step->len == state->maxlength)) {
+            state->best_ix = state->current_ix;
+
+            // Update maxlength to avoid considering anything longer
+            state->maxlength = step->len;
+        }
+        return;
+    }
+
+    // Don't try if we're already at or beyond the max acceptable
+    // length;
+    if(step->len >= state->maxlength)
+        return;
+    char mode = step->mode;
+
+    code128_alloc_step(state);
+    int mode_c_worked = 0;
+
+    // Always try mode C
+    if(code128_do_c_step(state->steps, state->current_ix, state->todo_ix)) {
+        state->todo_ix++;
+        code128_alloc_step(state);
+        mode_c_worked = 1;
+    }
+
+    if(mode == CODE128_MODE_A) {
+        // If A works, stick with A. There's no advantage to switching
+        // to B proactively if A still works.
+        if(code128_do_a_step(state->steps, state->current_ix, state->todo_ix) ||
+           code128_do_b_step(state->steps, state->current_ix, state->todo_ix))
+            state->todo_ix++;
+    }
+    else if(mode == CODE128_MODE_B) {
+        // The same logic applies here. There's no advantage to switching
+        // proactively to A if B still works.
+        if(code128_do_b_step(state->steps, state->current_ix, state->todo_ix) ||
+           code128_do_a_step(state->steps, state->current_ix, state->todo_ix))
+            state->todo_ix++;
+    }
+    else if(!mode_c_worked) {
+        // In mode C. If mode C worked and we're in mode C, trying anything
+        // else is pointless since the mode C encoding will be shorter and
+        // there won't be any mode switches.
+
+        // If we're leaving mode C, though, try both in case one ends up
+        // better than the other.
+        if(code128_do_a_step(state->steps, state->current_ix, state->todo_ix)) {
+            state->todo_ix++;
+            code128_alloc_step(state);
+        }
+        if(code128_do_b_step(state->steps, state->current_ix, state->todo_ix))
+            state->todo_ix++;
+    }
+}
+
+size_t code128_encode_raw(const char * s, char * out, size_t maxlength)
+{
+    struct code128_state state;
+
+    const size_t overhead = CODE128_QUIET_ZONE_LEN
+                            + CODE128_CHAR_LEN // checksum
+                            + CODE128_STOP_CODE_LEN
+                            + CODE128_QUIET_ZONE_LEN;
+    if(maxlength < overhead + CODE128_CHAR_LEN + CODE128_CHAR_LEN) {
+        // Need space to encode the start character and one additional
+        // character.
+        return 0;
+    }
+
+    state.allocated_steps = 256;
+    state.steps = (struct code128_step *) CODE128_MALLOC(state.allocated_steps * sizeof(struct code128_step));
+    state.current_ix = 0;
+    state.todo_ix = 0;
+    state.maxlength = maxlength - overhead;
+    state.best_ix = -1;
+
+    // Initialize the first 3 steps for the 3 encoding routes (A, B, C)
+    state.steps[0].prev_ix = -1;
+    state.steps[0].next_input = s;
+    state.steps[0].len = CODE128_CHAR_LEN;
+    state.steps[0].mode = CODE128_MODE_C;
+    state.steps[0].code = CODE128_START_CODE_C;
+
+    state.steps[1].prev_ix = -1;
+    state.steps[1].next_input = s;
+    state.steps[1].len = CODE128_CHAR_LEN;
+    state.steps[1].mode = CODE128_MODE_A;
+    state.steps[1].code = CODE128_START_CODE_A;
+
+    state.steps[2].prev_ix = -1;
+    state.steps[2].next_input = s;
+    state.steps[2].len = CODE128_CHAR_LEN;
+    state.steps[2].mode = CODE128_MODE_B;
+    state.steps[2].code = CODE128_START_CODE_B;
+
+    state.todo_ix = 3;
+
+    // Keep going until no more work
+    do {
+        code128_do_step(&state);
+        state.current_ix++;
+    } while(state.current_ix != state.todo_ix);
+
+    // If no best_step, then fail.
+    if(state.best_ix < 0) {
+        CODE128_FREE(state.steps);
+        return 0;
+    }
+
+    // Determine the list of codes
+    size_t num_codes = state.maxlength / CODE128_CHAR_LEN;
+    char * codes = CODE128_MALLOC(num_codes);
+    CODE128_ASSERT(codes);
+
+    struct code128_step * step = &state.steps[state.best_ix];
+    size_t i;
+    for(i = num_codes - 1; i > 0; --i) {
+        struct code128_step * prev_step = &state.steps[step->prev_ix];
+        codes[i] = step->code;
+        if(step->mode != prev_step->mode) {
+            --i;
+            codes[i] = code128_switch_code(prev_step->mode, step->mode);
+        }
+        step = prev_step;
+    }
+    codes[0] = step->code;
+
+    // Encode everything up to the checksum
+    size_t actual_length = state.maxlength + overhead;
+    CODE128_MEMSET(out, 0, CODE128_QUIET_ZONE_LEN);
+    out += CODE128_QUIET_ZONE_LEN;
+    for(i = 0; i < num_codes; i++)
+        out += code128_append_code(codes[i], out);
+
+    // Compute the checksum
+    int sum = codes[0];
+    for(i = 1; i < num_codes; i++)
+        sum += codes[i] * i;
+    out += code128_append_code(sum % 103, out);
+
+    // Finalize the code.
+    out += code128_append_stop_code(out);
+    CODE128_MEMSET(out, 0, CODE128_QUIET_ZONE_LEN);
+
+    CODE128_FREE(codes);
+    CODE128_FREE(state.steps);
+    return actual_length;
+}
+
+/**
+ * @brief Encode the GS1 string
+ *
+ * This converts [FNC1] sequences to raw FNC1 characters and
+ * removes spaces before encoding the barcodes.
+ *
+ * @return the length of barcode data in bytes
+ */
+size_t code128_encode_gs1(const char * s, char * out, size_t maxlength)
+{
+    size_t raw_size = CODE128_STRLEN(s) + 1;
+    char * raw = CODE128_MALLOC(raw_size);
+    CODE128_ASSERT(raw);
+    if(!raw) {
+        return 0;
+    }
+
+    char * p = raw;
+    for(; *s != '\0'; s++) {
+        if(strncmp(s, "[FNC1]", 6) == 0) {
+            *p++ = CODE128_FNC1;
+            s += 5;
+        }
+        else if(*s != ' ') {
+            *p++ = *s;
+        }
+    }
+    *p = '\0';
+
+    size_t length = code128_encode_raw(raw, out, maxlength);
+
+    CODE128_FREE(raw);
+
+    return length;
+}
+
+#endif /*LV_USE_BARCODE*/
diff --git a/src/extra/libs/barcode/code128.h b/src/extra/libs/barcode/code128.h
new file mode 100644
index 000000000..51d53d0cc
--- /dev/null
+++ b/src/extra/libs/barcode/code128.h
@@ -0,0 +1,47 @@
+// Copyright (c) 2013-15, LKC Technologies, Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// Redistributions of source code must retain the above copyright notice, this
+// list of conditions and the following disclaimer. Redistributions in binary
+// form must reproduce the above copyright notice, this list of conditions and
+// the following disclaimer in the documentation and/or other materials
+// provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
+// HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CODE128_H
+#define CODE128_H
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Since the FNCn characters are not ASCII, define versions here to
+// simplify encoding strings that include them.
+#define CODE128_FNC1 '\xf1'
+#define CODE128_FNC2 '\xf2'
+#define CODE128_FNC3 '\xf3'
+#define CODE128_FNC4 '\xf4'
+
+size_t code128_estimate_len(const char * s);
+size_t code128_encode_gs1(const char * s, char * out, size_t maxlength);
+size_t code128_encode_raw(const char * s, char * out, size_t maxlength);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // CODE128_H
diff --git a/src/extra/libs/barcode/lv_barcode.c b/src/extra/libs/barcode/lv_barcode.c
new file mode 100644
index 000000000..ff63fa18d
--- /dev/null
+++ b/src/extra/libs/barcode/lv_barcode.c
@@ -0,0 +1,215 @@
+/**
+ * @file lv_barcode.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "lv_barcode.h"
+#if LV_USE_BARCODE
+
+#include "code128.h"
+
+/*********************
+ *      DEFINES
+ *********************/
+#define MY_CLASS &lv_barcode_class
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+/**********************
+ *  STATIC PROTOTYPES
+ **********************/
+static void lv_barcode_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_barcode_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static bool lv_barcode_change_buf_size(lv_obj_t * obj, lv_coord_t w);
+
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+
+const lv_obj_class_t lv_barcode_class = {
+    .constructor_cb = lv_barcode_constructor,
+    .destructor_cb = lv_barcode_destructor,
+    .width_def = LV_SIZE_CONTENT,
+    .instance_size = sizeof(lv_barcode_t),
+    .base_class = &lv_canvas_class
+};
+
+/**********************
+ *      MACROS
+ **********************/
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+lv_obj_t * lv_barcode_create(lv_obj_t * parent)
+{
+    LV_LOG_INFO("begin");
+    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);
+    lv_obj_class_init_obj(obj);
+    return obj;
+}
+
+void lv_barcode_set_dark_color(lv_obj_t * obj, lv_color_t color)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+    lv_barcode_t * barcode = (lv_barcode_t *)obj;
+    barcode->dark_color = color;
+}
+
+void lv_barcode_set_light_color(lv_obj_t * obj, lv_color_t color)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+    lv_barcode_t * barcode = (lv_barcode_t *)obj;
+    barcode->light_color = color;
+}
+
+void lv_barcode_set_scale(lv_obj_t * obj, uint16_t scale)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+    if(scale == 0) {
+        scale = 1;
+    }
+
+    lv_barcode_t * barcode = (lv_barcode_t *)obj;
+    barcode->scale = scale;
+}
+
+lv_res_t lv_barcode_update(lv_obj_t * obj, const char * data)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    LV_ASSERT_NULL(data);
+
+    lv_res_t res = LV_RES_INV;
+    lv_barcode_t * barcode = (lv_barcode_t *)obj;
+
+    if(data == NULL || strlen(data) == 0) {
+        LV_LOG_WARN("data is empty");
+        return LV_RES_INV;
+    }
+
+    size_t len = code128_estimate_len(data);
+    LV_LOG_INFO("data: %s, len = %zu", data, len);
+
+    char * out_buf = lv_mem_alloc(len);
+    LV_ASSERT_MALLOC(out_buf);
+    if(!out_buf) {
+        LV_LOG_ERROR("malloc failed for out_buf");
+        return LV_RES_INV;
+    }
+
+    lv_coord_t barcode_w = code128_encode_gs1(data, out_buf, len);
+    LV_LOG_INFO("barcode width = %d", (int)barcode_w);
+
+    LV_ASSERT(barcode->scale > 0);
+    uint16_t scale = barcode->scale;
+
+    if(!lv_barcode_change_buf_size(obj, barcode_w * scale)) {
+        goto failed;
+    }
+
+    lv_canvas_set_palette(obj, 0, barcode->dark_color);
+    lv_canvas_set_palette(obj, 1, barcode->light_color);
+
+    for(lv_coord_t x = 0; x < barcode_w; x++) {
+        lv_color_t color;
+        color.full = out_buf[x] ? 0 : 1;
+        for(uint16_t i = 0; i < scale; i++) {
+            lv_canvas_set_px_color(obj, x * scale + i, 0, color);
+        }
+    }
+
+    res = LV_RES_OK;
+
+failed:
+    lv_mem_free(out_buf);
+    return res;
+}
+
+lv_color_t lv_barcode_get_dark_color(lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+    lv_barcode_t * barcode = (lv_barcode_t *)obj;
+    return barcode->dark_color;
+}
+
+lv_color_t lv_barcode_get_light_color(lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+    lv_barcode_t * barcode = (lv_barcode_t *)obj;
+    return barcode->light_color;
+}
+
+uint16_t lv_barcode_get_scale(lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+    lv_barcode_t * barcode = (lv_barcode_t *)obj;
+    return barcode->scale;
+}
+
+/**********************
+ *   STATIC FUNCTIONS
+ **********************/
+
+static void lv_barcode_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+
+    lv_barcode_t * barcode = (lv_barcode_t *)obj;
+    barcode->dark_color = lv_color_black();
+    barcode->light_color = lv_color_white();
+    barcode->scale = 1;
+}
+
+static void lv_barcode_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+
+    lv_img_dsc_t * img = lv_canvas_get_img(obj);
+    lv_img_cache_invalidate_src(img);
+
+    if(!img->data) {
+        LV_LOG_INFO("canvas buffer is NULL");
+        return;
+    }
+
+    LV_LOG_INFO("free canvas buffer: %p", img->data);
+
+    lv_mem_free((void *)img->data);
+    img->data = NULL;
+}
+
+static bool lv_barcode_change_buf_size(lv_obj_t * obj, lv_coord_t w)
+{
+    LV_ASSERT_NULL(obj);
+    LV_ASSERT(w > 0);
+
+    lv_img_dsc_t * img = lv_canvas_get_img(obj);
+    void * buf = (void *)img->data;
+
+    uint32_t buf_size = LV_CANVAS_BUF_SIZE_INDEXED_1BIT(w, 1);
+    buf = lv_mem_realloc(buf, buf_size);
+    LV_ASSERT_MALLOC(buf);
+
+    if(!buf) {
+        LV_LOG_ERROR("malloc failed for canvas buffer");
+        return false;
+    }
+
+    lv_canvas_set_buffer(obj, buf, w, 1, LV_IMG_CF_INDEXED_1BIT);
+    LV_LOG_INFO("set canvas buffer: %p, width = %d", buf, (int)w);
+    return true;
+}
+
+#endif /*LV_USE_BARCODE*/
diff --git a/src/extra/libs/barcode/lv_barcode.h b/src/extra/libs/barcode/lv_barcode.h
new file mode 100644
index 000000000..3b534bdb3
--- /dev/null
+++ b/src/extra/libs/barcode/lv_barcode.h
@@ -0,0 +1,108 @@
+/**
+ * @file lv_barcode.c
+ *
+ */
+
+#ifndef LV_BARCODE_H
+#define LV_BARCODE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "../../../lvgl.h"
+#if LV_USE_BARCODE
+
+/*********************
+ *      DEFINES
+ *********************/
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+/*Data of barcode*/
+typedef struct {
+    lv_canvas_t canvas;
+    lv_color_t dark_color;
+    lv_color_t light_color;
+    uint16_t scale;
+} lv_barcode_t;
+
+extern const lv_obj_class_t lv_barcode_class;
+
+/**********************
+ * GLOBAL PROTOTYPES
+ **********************/
+
+/**
+ * Create an empty barcode (an `lv_canvas`) object.
+ * @param parent point to an object where to create the barcode
+ * @return pointer to the created barcode object
+ */
+lv_obj_t * lv_barcode_create(lv_obj_t * parent);
+
+/**
+ * Set the dark color of a barcode object
+ * @param obj pointer to barcode object
+ * @param color dark color of the barcode
+ */
+void lv_barcode_set_dark_color(lv_obj_t * obj, lv_color_t color);
+
+/**
+ * Set the light color of a barcode object
+ * @param obj pointer to barcode object
+ * @param color light color of the barcode
+ */
+void lv_barcode_set_light_color(lv_obj_t * obj, lv_color_t color);
+
+/**
+ * Set the scale of a barcode object
+ * @param obj pointer to barcode object
+ * @param scale scale factor
+ */
+void lv_barcode_set_scale(lv_obj_t * obj, uint16_t scale);
+
+/**
+ * Set the data of a barcode object
+ * @param obj pointer to barcode object
+ * @param data data to display
+ * @return LV_RES_OK: if no error; LV_RES_INV: on error
+ */
+lv_res_t lv_barcode_update(lv_obj_t * obj, const char * data);
+
+/**
+ * Get the dark color of a barcode object
+ * @param obj pointer to barcode object
+ * @return dark color of the barcode
+ */
+lv_color_t lv_barcode_get_dark_color(lv_obj_t * obj);
+
+/**
+ * Get the light color of a barcode object
+ * @param obj pointer to barcode object
+ * @return light color of the barcode
+ */
+lv_color_t lv_barcode_get_light_color(lv_obj_t * obj);
+
+/**
+ * Get the scale of a barcode object
+ * @param obj pointer to barcode object
+ * @return scale factor
+ */
+uint16_t lv_barcode_get_scale(lv_obj_t * obj);
+
+/**********************
+ *      MACROS
+ **********************/
+
+#endif /*LV_USE_BARCODE*/
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /*LV_BARCODE_H*/
diff --git a/src/extra/libs/fsdrv/lv_fs_rawfs.c b/src/extra/libs/fsdrv/lv_fs_rawfs.c
new file mode 100644
index 000000000..a6056c539
--- /dev/null
+++ b/src/extra/libs/fsdrv/lv_fs_rawfs.c
@@ -0,0 +1,322 @@
+/*
+ * @file lv_fs_rawfs.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "../../../lvgl.h"
+
+#if LV_USE_FS_RAWFS
+
+/*********************
+ *      DEFINES
+ *********************/
+
+#if LV_FS_RAWFS_LETTER == '\0'
+    #error "LV_FS_RAWFS_LETTER must be an upper case ASCII letter"
+#endif
+
+#if LV_FS_RAWFS_XIP
+    #if LV_FS_RAWFS_XIP_BASE_ADDR == 0xFFFFFFFF
+        #error "Base address for image binary (LV_FS_RAWFS_XIP_BASE_ADDR) must be valid"
+    #endif
+#endif
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+/* Info for raw binaries: base, offset, size, name*/
+/*
+const rawfs_size_t rawfs_file_count = 3;
+rawfs_file_t rawfs_files[3] = {
+    0x0, 0, 1688704, "/apic33695.bin",
+    0x19c480, 0, 1204, "/green_left_icon.bin",
+    0x19c934, 0, 1204, "/red_right_icon.bin",
+};
+*/
+extern rawfs_size_t rawfs_file_count;
+extern rawfs_file_t rawfs_files[];
+
+/**********************
+ *  STATIC PROTOTYPES
+ **********************/
+static lv_fs_res_t rawfs_file_find(const char * path, rawfs_file_t * file_p);
+
+static void fs_init(void);
+
+static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode);
+static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p);
+static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br);
+static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw);
+static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence);
+static lv_fs_res_t fs_size(lv_fs_drv_t * drv, void * file_p, uint32_t * size_p);
+static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p);
+
+static void * fs_dir_open(lv_fs_drv_t * drv, const char * path);
+static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * rddir_p, char * fn);
+static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * rddir_p);
+
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+static rawfs_file_t FIL;
+
+/**********************
+ * GLOBAL PROTOTYPES
+ **********************/
+
+/**********************
+ *      MACROS
+ **********************/
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+void lv_fs_rawfs_init(void)
+{
+    /*----------------------------------------------------
+     * Initialize your storage device and File System
+     * -------------------------------------------------*/
+    fs_init();
+
+    /*---------------------------------------------------
+     * Register the file system interface in LVGL
+     *--------------------------------------------------*/
+
+    /*Add a simple drive to open images*/
+    static lv_fs_drv_t fs_drv;
+    lv_fs_drv_init(&fs_drv);
+
+    /*Set up fields...*/
+    fs_drv.letter = LV_FS_RAWFS_LETTER;
+    fs_drv.open_cb = fs_open;
+    fs_drv.close_cb = fs_close;
+    fs_drv.read_cb = fs_read;
+    fs_drv.write_cb = fs_write;
+    fs_drv.seek_cb = fs_seek;
+    fs_drv.tell_cb = fs_tell;
+
+    fs_drv.dir_close_cb = fs_dir_close;
+    fs_drv.dir_open_cb = fs_dir_open;
+    fs_drv.dir_read_cb = fs_dir_read;
+
+    lv_fs_drv_register(&fs_drv);
+}
+
+/**********************
+ *   STATIC FUNCTIONS
+ **********************/
+
+/**
+ * Find file based on path
+ * @param path      path to the file (e.g. /folder/file.txt)
+ * @param file_p    pointer to a file_t variable. (opened with fs_open)
+ * @return          LV_FS_RES_OK: no error or  any error from @lv_fs_res_t enum
+ */
+static lv_fs_res_t rawfs_file_find(const char * path, rawfs_file_t * file_p)
+{
+    lv_fs_res_t res = LV_FS_RES_FS_ERR;
+    /*Find file*/
+    for(int i = 0; i < rawfs_file_count; i++) {
+        if(0 == strcmp(path, rawfs_files[i].name)) {
+            *file_p = rawfs_files[i];
+            res = LV_FS_RES_OK;
+            break;
+        }
+    }
+    return res;
+}
+
+/*Initialize your Storage device and File system.*/
+static void fs_init(void)
+{
+    FIL.base = 0;
+    FIL.offset = 0;
+}
+
+/**
+ * Open a file
+ * @param drv       pointer to a driver where this function belongs
+ * @param path      path to the file (e.g. /folder/file.txt)
+ * @param mode      read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR
+ * @return          a file descriptor or NULL on error
+ */
+static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
+{
+    lv_fs_res_t res = LV_FS_RES_NOT_IMP;
+
+    void * f = NULL;
+
+    if(mode == LV_FS_MODE_RD) {
+        /*Open a file for read*/
+        res = rawfs_file_find(path, &FIL);
+    }
+    else if(mode == (LV_FS_MODE_WR | LV_FS_MODE_RD)) {
+        /*Open a file for read and write*/
+        res = rawfs_file_find(path, &FIL);
+    }
+
+    if(res == LV_FS_RES_OK) {
+        f = &FIL;
+    }
+
+    return f;
+}
+
+/**
+ * Close an opened file
+ * @param drv       pointer to a driver where this function belongs
+ * @param file_p    pointer to a file_t variable. (opened with fs_open)
+ * @return          LV_FS_RES_OK: no error or  any error from @lv_fs_res_t enum
+ */
+static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
+{
+    lv_fs_res_t res = LV_FS_RES_OK;
+
+    fs_init();
+
+    return res;
+}
+
+/**
+ * Read data from an opened file
+ * @param drv       pointer to a driver where this function belongs
+ * @param file_p    pointer to a file_t variable.
+ * @param buf       pointer to a memory block where to store the read data
+ * @param btr       number of Bytes To Read
+ * @param br        the real number of read bytes (Byte Read)
+ * @return          LV_FS_RES_OK: no error or  any error from @lv_fs_res_t enum
+ */
+static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br)
+{
+    lv_fs_res_t res = LV_FS_RES_OK;
+
+    rawfs_file_t * p = (rawfs_file_t *)file_p;
+#if LV_FS_RAWFS_XIP
+    /*For XIP flash, copy directly*/
+    lv_memcpy((uint8_t *)buf, (uint8_t *)(LV_FS_RAWFS_XIP_BASE_ADDR + p->base + p->offset), btr);
+#else
+    /*For Non-XIP flash, use driver API*/
+    //W25QXX_Read((unit8_t *)buf, (unit8_t *)(p->base + p->offset), btr);
+    res = LV_FS_RES_NOT_IMP;
+#endif
+    p->offset += btr;
+    *br = btr;
+
+    return res;
+}
+
+/**
+ * Write into a file
+ * @param drv       pointer to a driver where this function belongs
+ * @param file_p    pointer to a file_t variable
+ * @param buf       pointer to a buffer with the bytes to write
+ * @param btw       Bytes To Write
+ * @param bw        the number of real written bytes (Bytes Written). NULL if unused.
+ * @return          LV_FS_RES_OK: no error or  any error from @lv_fs_res_t enum
+ */
+static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw)
+{
+    lv_fs_res_t res = LV_FS_RES_NOT_IMP;
+
+    /*Add your code here*/
+
+    return res;
+}
+
+/**
+ * Set the read write pointer. Also expand the file size if necessary.
+ * @param drv       pointer to a driver where this function belongs
+ * @param file_p    pointer to a file_t variable. (opened with fs_open )
+ * @param pos       the new position of read write pointer
+ * @param whence    tells from where to interpret the `pos`. See @lv_fs_whence_t
+ * @return          LV_FS_RES_OK: no error or  any error from @lv_fs_res_t enum
+ */
+static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence)
+{
+    lv_fs_res_t res = LV_FS_RES_OK;
+
+    rawfs_file_t * p = (rawfs_file_t *)file_p;
+    if(whence == LV_FS_SEEK_SET) {
+        p->offset = pos;
+    }
+    else if(whence == LV_FS_SEEK_CUR) {
+        p->offset += pos;
+    }
+    else if(whence == LV_FS_SEEK_END) {
+        p->offset = p->size + pos;
+    }
+    else {
+        res = LV_FS_RES_NOT_IMP;
+    }
+
+    return res;
+}
+
+/**
+ * Give the position of the read write pointer
+ * @param drv       pointer to a driver where this function belongs
+ * @param file_p    pointer to a file_t variable.
+ * @param pos_p     pointer to to store the result
+ * @return          LV_FS_RES_OK: no error or  any error from @lv_fs_res_t enum
+ */
+static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
+{
+    lv_fs_res_t res = LV_FS_RES_OK;
+
+    rawfs_file_t * p = (rawfs_file_t *)file_p;
+    *pos_p = p->offset;
+
+    return res;
+}
+
+/**
+ * Initialize a 'lv_fs_dir_t' variable for directory reading
+ * @param drv       pointer to a driver where this function belongs
+ * @param path      path to a directory
+ * @return          pointer to the directory read descriptor or NULL on error
+ */
+static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
+{
+    void * dir = NULL;
+    /*Add your code here*/
+    return dir;
+}
+
+/**
+ * Read the next filename form a directory.
+ * The name of the directories will begin with '/'
+ * @param drv       pointer to a driver where this function belongs
+ * @param rddir_p   pointer to an initialized 'lv_fs_dir_t' variable
+ * @param fn        pointer to a buffer to store the filename
+ * @return          LV_FS_RES_OK: no error or  any error from @lv_fs_res_t enum
+ */
+static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * rddir_p, char * fn)
+{
+    lv_fs_res_t res = LV_FS_RES_NOT_IMP;
+
+    /*Add your code here*/
+
+    return res;
+}
+
+/**
+ * Close the directory reading
+ * @param drv       pointer to a driver where this function belongs
+ * @param rddir_p   pointer to an initialized 'lv_fs_dir_t' variable
+ * @return          LV_FS_RES_OK: no error or  any error from @lv_fs_res_t enum
+ */
+static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * rddir_p)
+{
+    lv_fs_res_t res = LV_FS_RES_NOT_IMP;
+
+    /*Add your code here*/
+
+    return res;
+}
+
+#endif /*LV_USE_FS_RAWFS*/
+
diff --git a/src/extra/libs/fsdrv/lv_fsdrv.h b/src/extra/libs/fsdrv/lv_fsdrv.h
index b864ad6f3..0d94465b8 100644
--- a/src/extra/libs/fsdrv/lv_fsdrv.h
+++ b/src/extra/libs/fsdrv/lv_fsdrv.h
@@ -36,6 +36,22 @@ void lv_fs_littlefs_init(void);
 lv_fs_drv_t * lv_fs_littlefs_set_driver(char label, void * lfs_p);
 #endif
 
+#if LV_USE_FS_RAWFS != '\0'
+#include "stdint.h"
+
+typedef uint32_t rawfs_addr_t;
+typedef uint32_t rawfs_size_t;
+
+typedef struct _rawfs_file_t {
+    rawfs_addr_t base;
+    rawfs_addr_t offset;
+    rawfs_size_t size;
+    char * name;
+} rawfs_file_t;
+
+void lv_fs_rawfs_init(void);
+#endif
+
 #if LV_USE_FS_STDIO != '\0'
 void lv_fs_stdio_init(void);
 #endif
diff --git a/src/extra/libs/lv_libs.h b/src/extra/libs/lv_libs.h
index 1fefe6c11..749b553df 100644
--- a/src/extra/libs/lv_libs.h
+++ b/src/extra/libs/lv_libs.h
@@ -13,6 +13,7 @@ extern "C" {
 /*********************
  *      INCLUDES
  *********************/
+#include "barcode/lv_barcode.h"
 #include "bmp/lv_bmp.h"
 #include "fsdrv/lv_fsdrv.h"
 #include "png/lv_png.h"
diff --git a/src/extra/lv_extra.c b/src/extra/lv_extra.c
index bf9f68448..ee1a4623f 100644
--- a/src/extra/lv_extra.c
+++ b/src/extra/lv_extra.c
@@ -54,6 +54,10 @@ void lv_extra_init(void)
     lv_fs_littlefs_init();
 #endif
 
+#if LV_USE_FS_RAWFS != '\0'
+    lv_fs_rawfs_init();
+#endif
+
 #if LV_USE_FS_STDIO != '\0'
     lv_fs_stdio_init();
 #endif
diff --git a/src/extra/others/ime/lv_ime_pinyin.c b/src/extra/others/ime/lv_ime_pinyin.c
index 9834154fb..3939e6c19 100644
--- a/src/extra/others/ime/lv_ime_pinyin.c
+++ b/src/extra/others/ime/lv_ime_pinyin.c
@@ -572,7 +572,7 @@ static void lv_ime_pinyin_constructor(const lv_obj_class_t * class_p, lv_obj_t *
 #endif
 
     /* Init pinyin_ime->cand_panel */
-    pinyin_ime->cand_panel = lv_btnmatrix_create(lv_scr_act());
+    pinyin_ime->cand_panel = lv_btnmatrix_create(obj);
     lv_btnmatrix_set_map(pinyin_ime->cand_panel, (const char **)lv_btnm_def_pinyin_sel_map);
     lv_obj_set_size(pinyin_ime->cand_panel, LV_PCT(100), LV_PCT(5));
     lv_obj_add_flag(pinyin_ime->cand_panel, LV_OBJ_FLAG_HIDDEN);
diff --git a/src/extra/themes/default/lv_theme_default.c b/src/extra/themes/default/lv_theme_default.c
index 47392b0d1..34d6370e6 100644
--- a/src/extra/themes/default/lv_theme_default.c
+++ b/src/extra/themes/default/lv_theme_default.c
@@ -97,6 +97,10 @@ typedef struct {
     lv_style_t cb_marker, cb_marker_checked;
 #endif
 
+#if LV_USE_RADIOBTN
+    lv_style_t rb_marker, rb_marker_checked, rb_marker_inner, rb_marker_inner_checked;
+#endif
+
 #if LV_USE_SWITCH
     lv_style_t switch_knob;
 #endif
@@ -109,7 +113,7 @@ typedef struct {
     lv_style_t table_cell;
 #endif
 
-#if LV_USE_METER
+#if LV_USE_METER || LV_USE_ANALOGCLOCK
     lv_style_t meter_marker, meter_indic;
 #endif
 
@@ -125,6 +129,10 @@ typedef struct {
     lv_style_t colorwheel_main;
 #endif
 
+#if LV_USE_CAROUSEL
+    lv_style_t outline_focus, outline_disabled;
+#endif
+
 #if LV_USE_MENU
     lv_style_t menu_bg, menu_cont, menu_sidebar_cont, menu_main_cont, menu_page, menu_header_cont, menu_header_btn,
                menu_section, menu_pressed, menu_separator;
@@ -427,6 +435,30 @@ static void style_init(void)
     lv_style_set_text_font(&styles->cb_marker_checked, theme.font_small);
 #endif
 
+#if LV_USE_RADIOBTN
+    style_init_reset(&styles->rb_marker);
+    lv_style_set_pad_all(&styles->rb_marker, lv_disp_dpx(theme.disp, 3));
+    lv_style_set_border_width(&styles->rb_marker, BORDER_WIDTH);
+    lv_style_set_border_color(&styles->rb_marker, theme.color_primary);
+    lv_style_set_bg_color(&styles->rb_marker, color_card);
+    lv_style_set_bg_opa(&styles->rb_marker, LV_OPA_COVER);
+    lv_style_set_radius(&styles->rb_marker, LV_RADIUS_CIRCLE);
+
+    style_init_reset(&styles->rb_marker_checked);
+    lv_style_set_bg_color(&styles->rb_marker_checked, color_card);
+    lv_style_set_bg_opa(&styles->rb_marker_checked, LV_OPA_COVER);
+
+    style_init_reset(&styles->rb_marker_inner);
+    lv_style_set_border_opa(&styles->rb_marker_inner, LV_OPA_TRANSP);
+    lv_style_set_bg_opa(&styles->rb_marker_inner, LV_OPA_TRANSP);
+    lv_style_set_radius(&styles->rb_marker_inner, LV_RADIUS_CIRCLE);
+
+    style_init_reset(&styles->rb_marker_inner_checked);
+    lv_style_set_border_opa(&styles->rb_marker_inner_checked, LV_OPA_TRANSP);
+    lv_style_set_bg_color(&styles->rb_marker_inner_checked, theme.color_primary);
+    lv_style_set_bg_opa(&styles->rb_marker_inner_checked, LV_OPA_COVER);
+#endif
+
 #if LV_USE_SWITCH
     style_init_reset(&styles->switch_knob);
     lv_style_set_pad_all(&styles->switch_knob, - lv_disp_dpx(theme.disp, 4));
@@ -525,7 +557,7 @@ static void style_init(void)
     lv_style_set_pad_ver(&styles->menu_separator, PAD_TINY);
 #endif
 
-#if LV_USE_METER
+#if LV_USE_METER || LV_USE_ANALOGCLOCK
     style_init_reset(&styles->meter_marker);
     lv_style_set_line_width(&styles->meter_marker, lv_disp_dpx(theme.disp, 5));
     lv_style_set_line_color(&styles->meter_marker, color_text);
@@ -582,6 +614,17 @@ static void style_init(void)
     lv_style_set_arc_width(&styles->colorwheel_main, lv_disp_dpx(theme.disp, 10));
 #endif
 
+#if LV_USE_CAROUSEL
+    style_init_reset(&styles->outline_focus);
+    lv_style_set_outline_color(&styles->outline_focus, lv_palette_main(LV_PALETTE_BLUE));
+    lv_style_set_outline_width(&styles->outline_focus, OUTLINE_WIDTH);
+    lv_style_set_outline_opa(&styles->outline_focus, LV_OPA_50);
+    style_init_reset(&styles->outline_disabled);
+    lv_style_set_outline_color(&styles->outline_disabled, lv_palette_main(LV_PALETTE_GREY));
+    lv_style_set_outline_width(&styles->outline_disabled, OUTLINE_WIDTH);
+    lv_style_set_outline_opa(&styles->outline_disabled, LV_OPA_50);
+#endif
+
 #if LV_USE_MSGBOX
     /*To add space for for the button shadow*/
     style_init_reset(&styles->msgbox_btn_bg);
@@ -899,6 +942,25 @@ static void theme_apply(lv_theme_t * th, lv_obj_t * obj)
     }
 #endif
 
+#if LV_USE_RADIOBTN
+    else if(lv_obj_check_type(obj, &lv_radiobtn_item_class)) {
+        lv_obj_add_style(obj, &styles->pad_gap, 0);
+        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);
+        lv_obj_add_style(obj, &styles->disabled, LV_PART_INDICATOR | LV_STATE_DISABLED);
+        lv_obj_add_style(obj, &styles->rb_marker, LV_PART_INDICATOR);
+        lv_obj_add_style(obj, &styles->rb_marker_inner, LV_PART_CUSTOM_FIRST);
+        lv_obj_add_style(obj, &styles->rb_marker_checked, LV_PART_INDICATOR | LV_STATE_CHECKED);
+        lv_obj_add_style(obj, &styles->rb_marker_inner_checked, LV_PART_CUSTOM_FIRST | LV_STATE_CHECKED);
+        lv_obj_add_style(obj, &styles->pressed, LV_PART_INDICATOR | LV_STATE_PRESSED);
+        lv_obj_add_style(obj, &styles->pressed, LV_PART_CUSTOM_FIRST | LV_STATE_PRESSED);
+#if LV_THEME_DEFAULT_GROW
+        lv_obj_add_style(obj, &styles->grow, LV_PART_INDICATOR | LV_STATE_PRESSED);
+#endif
+        lv_obj_add_style(obj, &styles->transition_normal, LV_PART_INDICATOR | LV_STATE_PRESSED);
+        lv_obj_add_style(obj, &styles->transition_delayed, LV_PART_INDICATOR);
+    }
+#endif
+
 #if LV_USE_SWITCH
     else if(lv_obj_check_type(obj, &lv_switch_class)) {
         lv_obj_add_style(obj, &styles->bg_color_grey, 0);
@@ -995,6 +1057,14 @@ static void theme_apply(lv_theme_t * th, lv_obj_t * obj)
     }
 #endif
 
+#if LV_USE_ANALOGCLOCK
+    else if(lv_obj_check_type(obj, &lv_analogclock_class)) {
+        lv_obj_add_style(obj, &styles->card, 0);
+        lv_obj_add_style(obj, &styles->circle, 0);
+        lv_obj_add_style(obj, &styles->meter_indic, LV_PART_INDICATOR);
+    }
+#endif
+
 #if LV_USE_TEXTAREA
     else if(lv_obj_check_type(obj, &lv_textarea_class)) {
         lv_obj_add_style(obj, &styles->card, 0);
@@ -1135,6 +1205,20 @@ static void theme_apply(lv_theme_t * th, lv_obj_t * obj)
     }
 #endif
 
+#if LV_USE_CAROUSEL
+    else if(lv_obj_check_type(obj, &lv_carousel_class)) {
+        lv_obj_add_style(obj, &styles->scr, 0);
+        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);
+        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);
+    }
+    else if(lv_obj_check_type(obj, &lv_carousel_element_class)) {
+        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);
+        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);
+        lv_obj_add_style(obj, &styles->outline_focus, LV_STATE_FOCUSED);
+        lv_obj_add_style(obj, &styles->outline_disabled, LV_STATE_DEFAULT);
+    }
+#endif
+
 #if LV_USE_TABVIEW
     else if(lv_obj_check_type(obj, &lv_tabview_class)) {
         lv_obj_add_style(obj, &styles->scr, 0);
diff --git a/src/extra/widgets/analogclock/lv_analogclock.c b/src/extra/widgets/analogclock/lv_analogclock.c
new file mode 100644
index 000000000..b7e6c3e78
--- /dev/null
+++ b/src/extra/widgets/analogclock/lv_analogclock.c
@@ -0,0 +1,803 @@
+/**
+ * @file lv_analogclock.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "lv_analogclock.h"
+#if LV_USE_ANALOGCLOCK != 0
+
+#include "../../../misc/lv_assert.h"
+
+/*********************
+ *      DEFINES
+ *********************/
+#define MY_CLASS &lv_analogclock_class
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+/**********************
+ *  STATIC PROTOTYPES
+ **********************/
+static void lv_analogclock_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_analogclock_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_analogclock_event(const lv_obj_class_t * class_p, lv_event_t * e);
+static void draw_arcs(lv_obj_t * obj, lv_draw_ctx_t * draw_ctx, const lv_area_t * scale_area);
+static void draw_ticks_and_labels(lv_obj_t * obj, lv_draw_ctx_t * draw_ctx, const lv_area_t * scale_area);
+static void draw_needles(lv_obj_t * obj, lv_draw_ctx_t * draw_ctx, const lv_area_t * scale_area);
+static void inv_arc(lv_obj_t * obj, lv_analogclock_indicator_t * indic, int32_t old_value, int32_t new_value);
+static void inv_line(lv_obj_t * obj, lv_analogclock_indicator_t * indic, int32_t value);
+
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+const lv_obj_class_t lv_analogclock_class = {
+    .constructor_cb = lv_analogclock_constructor,
+    .destructor_cb = lv_analogclock_destructor,
+    .event_cb = lv_analogclock_event,
+    .instance_size = sizeof(lv_analogclock_t),
+    .base_class = &lv_obj_class
+};
+
+/**********************
+ *      MACROS
+ **********************/
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+lv_obj_t * lv_analogclock_create(lv_obj_t * parent)
+{
+    LV_LOG_INFO("begin");
+    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);
+    lv_obj_class_init_obj(obj);
+    return obj;
+}
+
+/*=====================
+ * Add scale
+ *====================*/
+
+lv_analogclock_scale_t * lv_analogclock_add_scale(lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+
+    lv_analogclock_scale_t * scale = _lv_ll_ins_head(&analogclock->scale_ll);
+    LV_ASSERT_MALLOC(scale);
+    lv_memset_00(scale, sizeof(lv_analogclock_scale_t));
+
+    // scale->angle_range = 270;
+    // scale->rotation = 90 + (360 - scale->angle_range) / 2;
+    // scale->min = 0;
+    // scale->max = 100;
+    // scale->tick_cnt = 6;
+    // scale->tick_length = 8;
+    // scale->tick_width = 2;
+    // scale->label_gap = 2;
+    scale->angle_range = 360;
+    // scale->rotation = 0;
+    // scale->min = 0;
+    // scale->max = 100;
+    scale->tick_cnt = 61;
+    scale->tick_length = 8;
+    scale->tick_width = 2;
+    // scale->tick_color = color;
+    scale->hide_label = false;
+    scale->label_gap = 10;
+    scale->tick_major_nth = 5;
+    scale->tick_major_width = 3;
+    scale->tick_major_length = 12;
+    // scale->tick_major_color = color;
+
+    scale->min = 0;
+    scale->max = 60;
+    scale->rotation = 270;
+
+    return scale;
+}
+
+void lv_analogclock_set_ticks(lv_obj_t * obj, uint16_t width, uint16_t len, lv_color_t color)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    lv_analogclock_scale_t * scale = analogclock->scale;
+    scale->tick_width = width;
+    scale->tick_length = len;
+    scale->tick_color = color;
+    lv_obj_invalidate(obj);
+}
+
+void lv_analogclock_set_major_ticks(lv_obj_t * obj, uint16_t width, uint16_t len, lv_color_t color, int16_t label_gap)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    lv_analogclock_scale_t * scale = analogclock->scale;
+    scale->tick_major_width = width;
+    scale->tick_major_length = len;
+    scale->tick_major_color = color;
+    scale->label_gap = label_gap;
+    lv_obj_invalidate(obj);
+}
+
+void lv_analogclock_set_scale_range(lv_obj_t * obj, lv_analogclock_scale_t * scale, int32_t min, int32_t max,
+                                    uint32_t angle_range,
+                                    uint32_t rotation)
+{
+    scale->min = min;
+    scale->max = max;
+    scale->angle_range = angle_range;
+    scale->rotation = rotation;
+    lv_obj_invalidate(obj);
+}
+
+/*=====================
+ * Add indicator
+ *====================*/
+void lv_analogclock_set_hour_needle_line(lv_obj_t * obj,  uint16_t width,
+                                         lv_color_t color, int16_t r_mod)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    analogclock->hour_indic = lv_analogclock_add_needle_line(obj, analogclock->scale, width, color, r_mod);
+}
+
+void lv_analogclock_set_min_needle_line(lv_obj_t * obj, uint16_t width,
+                                        lv_color_t color, int16_t r_mod)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    analogclock->min_indic = lv_analogclock_add_needle_line(obj, analogclock->scale, width, color, r_mod);
+}
+
+void lv_analogclock_set_sec_needle_line(lv_obj_t * obj, uint16_t width,
+                                        lv_color_t color, int16_t r_mod)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    analogclock->sec_indic = lv_analogclock_add_needle_line(obj, analogclock->scale, width, color, r_mod);
+}
+
+lv_analogclock_indicator_t * lv_analogclock_add_needle_line(lv_obj_t * obj, lv_analogclock_scale_t * scale,
+                                                            uint16_t width,
+                                                            lv_color_t color, int16_t r_mod)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    lv_analogclock_indicator_t * indic = _lv_ll_ins_head(&analogclock->indicator_ll);
+    LV_ASSERT_MALLOC(indic);
+    lv_memset_00(indic, sizeof(lv_analogclock_indicator_t));
+    indic->scale = scale;
+    indic->opa = LV_OPA_COVER;
+
+    indic->type = LV_analogclock_INDICATOR_TYPE_NEEDLE_LINE;
+    indic->type_data.needle_line.width = width;
+    indic->type_data.needle_line.color = color;
+    indic->type_data.needle_line.r_mod = r_mod;
+    lv_obj_invalidate(obj);
+
+    return indic;
+}
+
+void lv_analogclock_set_hour_needle_img(lv_obj_t * obj, const void * src,
+                                        lv_coord_t pivot_x, lv_coord_t pivot_y)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    analogclock->hour_indic = lv_analogclock_add_needle_img(obj, analogclock->scale, src, pivot_x, pivot_y);
+}
+
+void lv_analogclock_set_min_needle_img(lv_obj_t * obj, const void * src,
+                                       lv_coord_t pivot_x, lv_coord_t pivot_y)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    analogclock->min_indic = lv_analogclock_add_needle_img(obj, analogclock->scale, src, pivot_x, pivot_y);
+}
+
+void lv_analogclock_set_sec_needle_img(lv_obj_t * obj, const void * src,
+                                       lv_coord_t pivot_x, lv_coord_t pivot_y)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    analogclock->sec_indic = lv_analogclock_add_needle_img(obj, analogclock->scale, src, pivot_x, pivot_y);
+}
+
+lv_analogclock_indicator_t * lv_analogclock_add_needle_img(lv_obj_t * obj, lv_analogclock_scale_t * scale,
+                                                           const void * src,
+                                                           lv_coord_t pivot_x, lv_coord_t pivot_y)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    lv_analogclock_indicator_t * indic = _lv_ll_ins_head(&analogclock->indicator_ll);
+    LV_ASSERT_MALLOC(indic);
+    lv_memset_00(indic, sizeof(lv_analogclock_indicator_t));
+    indic->scale = scale;
+    indic->opa = LV_OPA_COVER;
+
+    indic->type = LV_analogclock_INDICATOR_TYPE_NEEDLE_IMG;
+    indic->type_data.needle_img.src = src;
+    indic->type_data.needle_img.pivot.x = pivot_x;
+    indic->type_data.needle_img.pivot.y = pivot_y;
+    lv_obj_invalidate(obj);
+
+    return indic;
+}
+
+lv_analogclock_indicator_t * lv_analogclock_add_arc(lv_obj_t * obj, uint16_t width, lv_color_t color,
+                                                    int16_t r_mod)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    lv_analogclock_indicator_t * indic = _lv_ll_ins_head(&analogclock->indicator_ll);
+    LV_ASSERT_MALLOC(indic);
+    lv_memset_00(indic, sizeof(lv_analogclock_indicator_t));
+    indic->scale = analogclock->scale;
+    indic->opa = LV_OPA_COVER;
+
+    indic->type = LV_analogclock_INDICATOR_TYPE_ARC;
+    indic->type_data.arc.width = width;
+    indic->type_data.arc.color = color;
+    indic->type_data.arc.r_mod = r_mod;
+
+    lv_obj_invalidate(obj);
+    return indic;
+}
+
+lv_analogclock_indicator_t * lv_analogclock_add_scale_lines(lv_obj_t * obj,  lv_color_t color_start,
+                                                            lv_color_t color_end, bool local, int16_t width_mod)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    lv_analogclock_indicator_t * indic = _lv_ll_ins_head(&analogclock->indicator_ll);
+    LV_ASSERT_MALLOC(indic);
+    lv_memset_00(indic, sizeof(lv_analogclock_indicator_t));
+    indic->scale = analogclock->scale;
+    indic->opa = LV_OPA_COVER;
+
+    indic->type = LV_analogclock_INDICATOR_TYPE_SCALE_LINES;
+    indic->type_data.scale_lines.color_start = color_start;
+    indic->type_data.scale_lines.color_end = color_end;
+    indic->type_data.scale_lines.local_grad = local;
+    indic->type_data.scale_lines.width_mod = width_mod;
+
+    lv_obj_invalidate(obj);
+    return indic;
+}
+
+/*=====================
+ * Hide digits / center point
+ *====================*/
+void lv_analogclock_hide_digits(lv_obj_t * obj, bool hide_digits)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    lv_analogclock_scale_t * scale = analogclock->scale;
+    scale->hide_label = hide_digits;
+}
+
+void lv_analogclock_hide_point(lv_obj_t * obj, bool hide_point)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    analogclock->hide_point = hide_point;
+}
+
+/*=====================
+ * Set indicator value
+ *====================*/
+
+void lv_analogclock_set_indicator_value(lv_obj_t * obj, lv_analogclock_indicator_t * indic, int32_t value)
+{
+    int32_t old_start = indic->start_value;
+    int32_t old_end = indic->end_value;
+    indic->start_value = value;
+    indic->end_value = value;
+
+    if(indic->type == LV_analogclock_INDICATOR_TYPE_ARC) {
+        inv_arc(obj, indic, old_start, value);
+        inv_arc(obj, indic, old_end, value);
+    }
+    else if(indic->type == LV_analogclock_INDICATOR_TYPE_NEEDLE_IMG ||
+            indic->type == LV_analogclock_INDICATOR_TYPE_NEEDLE_LINE) {
+        inv_line(obj, indic, old_start);
+        inv_line(obj, indic, old_end);
+        inv_line(obj, indic, value);
+    }
+    else {
+        lv_obj_invalidate(obj);
+    }
+}
+
+void lv_analogclock_set_indicator_start_value(lv_obj_t * obj, lv_analogclock_indicator_t * indic, int32_t value)
+{
+    int32_t old_value = indic->start_value;
+    indic->start_value = value;
+
+    if(indic->type == LV_analogclock_INDICATOR_TYPE_ARC) {
+        inv_arc(obj, indic, old_value, value);
+    }
+    else if(indic->type == LV_analogclock_INDICATOR_TYPE_NEEDLE_IMG ||
+            indic->type == LV_analogclock_INDICATOR_TYPE_NEEDLE_LINE) {
+        inv_line(obj, indic, old_value);
+        inv_line(obj, indic, value);
+    }
+    else {
+        lv_obj_invalidate(obj);
+    }
+}
+
+void lv_analogclock_set_indicator_end_value(lv_obj_t * obj, lv_analogclock_indicator_t * indic, int32_t value)
+{
+    int32_t old_value = indic->end_value;
+    indic->end_value = value;
+
+    if(indic->type == LV_analogclock_INDICATOR_TYPE_ARC) {
+        inv_arc(obj, indic, old_value, value);
+    }
+    else if(indic->type == LV_analogclock_INDICATOR_TYPE_NEEDLE_IMG ||
+            indic->type == LV_analogclock_INDICATOR_TYPE_NEEDLE_LINE) {
+        inv_line(obj, indic, old_value);
+        inv_line(obj, indic, value);
+    }
+    else {
+        lv_obj_invalidate(obj);
+    }
+}
+
+void lv_analogclock_set_time(lv_obj_t * obj, int32_t hour, int32_t min, int32_t sec)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    lv_analogclock_set_indicator_value(obj, analogclock->hour_indic, 5 * hour + min / 12);
+    lv_analogclock_set_indicator_value(obj, analogclock->min_indic, min);
+    lv_analogclock_set_indicator_value(obj, analogclock->sec_indic, sec);
+}
+
+/**********************
+ *   STATIC FUNCTIONS
+ **********************/
+
+static void lv_analogclock_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    LV_TRACE_OBJ_CREATE("begin");
+
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+
+    _lv_ll_init(&analogclock->scale_ll, sizeof(lv_analogclock_scale_t));
+    _lv_ll_init(&analogclock->indicator_ll, sizeof(lv_analogclock_indicator_t));
+    analogclock->scale = lv_analogclock_add_scale(obj);
+    analogclock->hide_point = false;
+
+    LV_TRACE_OBJ_CREATE("finished");
+}
+
+static void lv_analogclock_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    _lv_ll_clear(&analogclock->indicator_ll);
+    _lv_ll_clear(&analogclock->scale_ll);
+
+}
+
+static void lv_analogclock_event(const lv_obj_class_t * class_p, lv_event_t * e)
+{
+    LV_UNUSED(class_p);
+
+    lv_res_t res = lv_obj_event_base(MY_CLASS, e);
+    if(res != LV_RES_OK) return;
+
+    lv_event_code_t code = lv_event_get_code(e);
+    lv_obj_t * obj = lv_event_get_target(e);
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+    if(code == LV_EVENT_DRAW_MAIN) {
+        lv_draw_ctx_t * draw_ctx = lv_event_get_draw_ctx(e);
+        lv_area_t scale_area;
+        lv_obj_get_content_coords(obj, &scale_area);
+
+        draw_arcs(obj, draw_ctx, &scale_area);
+        draw_ticks_and_labels(obj, draw_ctx, &scale_area);
+        draw_needles(obj, draw_ctx, &scale_area);
+
+        if(!analogclock->hide_point) {
+            lv_coord_t r_edge = lv_area_get_width(&scale_area) / 2;
+            lv_point_t scale_center;
+            scale_center.x = scale_area.x1 + r_edge;
+            scale_center.y = scale_area.y1 + r_edge;
+
+            lv_draw_rect_dsc_t mid_dsc;
+            lv_draw_rect_dsc_init(&mid_dsc);
+            lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &mid_dsc);
+            lv_coord_t w = lv_obj_get_style_width(obj, LV_PART_INDICATOR) / 2;
+            lv_coord_t h = lv_obj_get_style_height(obj, LV_PART_INDICATOR) / 2;
+            lv_area_t nm_cord;
+            nm_cord.x1 = scale_center.x - w;
+            nm_cord.y1 = scale_center.y - h;
+            nm_cord.x2 = scale_center.x + w;
+            nm_cord.y2 = scale_center.y + h;
+            lv_draw_rect(draw_ctx, &mid_dsc, &nm_cord);
+        }
+    }
+}
+
+static void draw_arcs(lv_obj_t * obj, lv_draw_ctx_t * draw_ctx, const lv_area_t * scale_area)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+
+    lv_draw_arc_dsc_t arc_dsc;
+    lv_draw_arc_dsc_init(&arc_dsc);
+    arc_dsc.rounded = lv_obj_get_style_arc_rounded(obj, LV_PART_ITEMS);
+
+    lv_coord_t r_out = lv_area_get_width(scale_area) / 2 ;
+    lv_point_t scale_center;
+    scale_center.x = scale_area->x1 + r_out;
+    scale_center.y = scale_area->y1 + r_out;
+
+    lv_opa_t opa_main = lv_obj_get_style_opa(obj, LV_PART_MAIN);
+    lv_analogclock_indicator_t * indic;
+
+    lv_obj_draw_part_dsc_t part_draw_dsc;
+    lv_obj_draw_dsc_init(&part_draw_dsc, draw_ctx);
+    part_draw_dsc.arc_dsc = &arc_dsc;
+    part_draw_dsc.part = LV_PART_INDICATOR;
+    part_draw_dsc.class_p = MY_CLASS;
+    part_draw_dsc.type = LV_analogclock_DRAW_PART_ARC;
+
+    _LV_LL_READ_BACK(&analogclock->indicator_ll, indic) {
+        if(indic->type != LV_analogclock_INDICATOR_TYPE_ARC) continue;
+
+        arc_dsc.color = indic->type_data.arc.color;
+        arc_dsc.width = indic->type_data.arc.width;
+        arc_dsc.opa = indic->opa > LV_OPA_MAX ? opa_main : (opa_main * indic->opa) >> 8;
+
+        lv_analogclock_scale_t * scale = indic->scale;
+
+        int32_t start_angle = lv_map(indic->start_value, scale->min, scale->max, scale->rotation,
+                                     scale->rotation + scale->angle_range);
+        int32_t end_angle = lv_map(indic->end_value, scale->min, scale->max, scale->rotation,
+                                   scale->rotation + scale->angle_range);
+
+        part_draw_dsc.radius = r_out + indic->type_data.arc.r_mod;
+        part_draw_dsc.sub_part_ptr = indic;
+        part_draw_dsc.p1 = &scale_center;
+
+        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);
+        lv_draw_arc(draw_ctx, &arc_dsc, &scale_center, part_draw_dsc.radius, start_angle, end_angle);
+        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);
+    }
+}
+
+static void draw_ticks_and_labels(lv_obj_t * obj, lv_draw_ctx_t * draw_ctx, const lv_area_t * scale_area)
+{
+    lv_analogclock_t * analogclock    = (lv_analogclock_t *)obj;
+
+    lv_point_t p_center;
+    lv_coord_t r_edge = LV_MIN(lv_area_get_width(scale_area) / 2, lv_area_get_height(scale_area) / 2);
+    p_center.x = scale_area->x1 + r_edge;
+    p_center.y = scale_area->y1 + r_edge;
+
+    uint8_t i;
+
+    lv_draw_line_dsc_t line_dsc;
+    lv_draw_line_dsc_init(&line_dsc);
+    lv_obj_init_draw_line_dsc(obj, LV_PART_TICKS, &line_dsc);
+    line_dsc.raw_end = 1;
+
+    lv_draw_label_dsc_t label_dsc;
+    lv_draw_label_dsc_init(&label_dsc);
+    lv_obj_init_draw_label_dsc(obj, LV_PART_TICKS, &label_dsc);
+
+    lv_analogclock_scale_t * scale;
+
+    lv_draw_mask_radius_param_t inner_minor_mask;
+    lv_draw_mask_radius_param_t inner_major_mask;
+    lv_draw_mask_radius_param_t outer_mask;
+
+    lv_obj_draw_part_dsc_t part_draw_dsc;
+    lv_obj_draw_dsc_init(&part_draw_dsc, draw_ctx);
+    part_draw_dsc.class_p = MY_CLASS;
+    part_draw_dsc.part = LV_PART_TICKS;
+    part_draw_dsc.type = LV_analogclock_DRAW_PART_TICK;
+    part_draw_dsc.line_dsc = &line_dsc;
+
+    _LV_LL_READ_BACK(&analogclock->scale_ll, scale) {
+        part_draw_dsc.sub_part_ptr = scale;
+
+        lv_coord_t r_out = r_edge + scale->r_mod;
+        lv_coord_t r_in_minor = r_out - scale->tick_length;
+        lv_coord_t r_in_major = r_out - scale->tick_major_length;
+
+        lv_area_t area_inner_minor;
+        area_inner_minor.x1 = p_center.x - r_in_minor;
+        area_inner_minor.y1 = p_center.y - r_in_minor;
+        area_inner_minor.x2 = p_center.x + r_in_minor;
+        area_inner_minor.y2 = p_center.y + r_in_minor;
+        lv_draw_mask_radius_init(&inner_minor_mask, &area_inner_minor, LV_RADIUS_CIRCLE, true);
+
+        lv_area_t area_inner_major;
+        area_inner_major.x1 = p_center.x - r_in_major;
+        area_inner_major.y1 = p_center.y - r_in_major;
+        area_inner_major.x2 = p_center.x + r_in_major - 1;
+        area_inner_major.y2 = p_center.y + r_in_major - 1;
+        lv_draw_mask_radius_init(&inner_major_mask, &area_inner_major, LV_RADIUS_CIRCLE, true);
+
+        lv_area_t area_outer;
+        area_outer.x1 = p_center.x - r_out;
+        area_outer.y1 = p_center.y - r_out;
+        area_outer.x2 = p_center.x + r_out - 1;
+        area_outer.y2 = p_center.y + r_out - 1;
+        lv_draw_mask_radius_init(&outer_mask, &area_outer, LV_RADIUS_CIRCLE, false);
+        int16_t outer_mask_id = lv_draw_mask_add(&outer_mask, NULL);
+
+        int16_t inner_act_mask_id = LV_MASK_ID_INV; /*Will be added later*/
+
+        uint32_t minor_cnt = scale->tick_major_nth ? scale->tick_major_nth - 1 : 0xFFFF;
+        for(i = 0; i < scale->tick_cnt; i++) {
+            minor_cnt++;
+            bool major = false;
+            if(minor_cnt == scale->tick_major_nth) {
+                minor_cnt = 0;
+                major = true;
+            }
+
+            int32_t value_of_line = lv_map(i, 0, scale->tick_cnt - 1, scale->min, scale->max);
+            part_draw_dsc.value = value_of_line;
+
+            lv_color_t line_color = major ? scale->tick_major_color : scale->tick_color;
+            lv_color_t line_color_ori = line_color;
+
+            lv_coord_t line_width_ori = major ? scale->tick_major_width : scale->tick_width;
+            lv_coord_t line_width = line_width_ori;
+
+            lv_analogclock_indicator_t * indic;
+            _LV_LL_READ_BACK(&analogclock->indicator_ll, indic) {
+                if(indic->type != LV_analogclock_INDICATOR_TYPE_SCALE_LINES) continue;
+                if(value_of_line >= indic->start_value && value_of_line <= indic->end_value) {
+                    line_width += indic->type_data.scale_lines.width_mod;
+
+                    if(indic->type_data.scale_lines.color_start.full == indic->type_data.scale_lines.color_end.full) {
+                        line_color = indic->type_data.scale_lines.color_start;
+                    }
+                    else {
+                        lv_opa_t ratio;
+                        if(indic->type_data.scale_lines.local_grad) {
+                            ratio = lv_map(value_of_line, indic->start_value, indic->end_value, LV_OPA_TRANSP, LV_OPA_COVER);
+                        }
+                        else {
+                            ratio = lv_map(value_of_line, scale->min, scale->max, LV_OPA_TRANSP, LV_OPA_COVER);
+                        }
+                        line_color = lv_color_mix(indic->type_data.scale_lines.color_end, indic->type_data.scale_lines.color_start, ratio);
+                    }
+                }
+            }
+
+            /*`* 256` for extra precision*/
+            int32_t angle_upscale = ((i * scale->angle_range) << 8) / (scale->tick_cnt - 1);
+
+            int32_t angle_low = (angle_upscale >> 8);
+            int32_t angle_high = angle_low + 1;
+            int32_t angle_rem = angle_upscale & 0xFF;
+
+            /*Interpolate sine and cos*/
+            int32_t sin_low = lv_trigo_sin(angle_low + scale->rotation);
+            int32_t sin_high = lv_trigo_sin(angle_high + scale->rotation);
+            int32_t sin_mid = (sin_low * (256 - angle_rem) + sin_high * angle_rem) >> 8;
+
+            int32_t cos_low = lv_trigo_cos(angle_low + scale->rotation);
+            int32_t cos_high = lv_trigo_cos(angle_high + scale->rotation);
+            int32_t cos_mid = (cos_low * (256 - angle_rem) + cos_high * angle_rem) >> 8;
+
+            line_dsc.color = line_color;
+            line_dsc.width = line_width;
+            /*Use the interpolated angle to get the outer x and y coordinates.
+             *Draw a little bit longer lines to be sure the mask will clip them correctly*/
+            lv_point_t p_outer;
+            p_outer.x = (int32_t)(((int32_t)cos_mid * (r_out + line_width) + 127) >> (LV_TRIGO_SHIFT)) + p_center.x;
+            p_outer.y = (int32_t)(((int32_t)sin_mid * (r_out + line_width) + 127) >> (LV_TRIGO_SHIFT)) + p_center.y;
+
+            part_draw_dsc.p1 = &p_outer;
+            part_draw_dsc.p1 = &p_center;
+            part_draw_dsc.id = i;
+            part_draw_dsc.label_dsc = &label_dsc;
+
+            /*Draw the text*/
+            if(major && !scale->hide_label) {
+                lv_draw_mask_remove_id(outer_mask_id);
+                uint32_t r_text = r_in_major - scale->label_gap;
+                lv_point_t p;
+                p.x = (int32_t)((int32_t)((int32_t)cos_mid * r_text + 127) >> LV_TRIGO_SHIFT) + p_center.x;
+                p.y = (int32_t)((int32_t)((int32_t)sin_mid * r_text + 127) >> LV_TRIGO_SHIFT) + p_center.y;
+
+                lv_draw_label_dsc_t label_dsc_tmp;
+                lv_memcpy(&label_dsc_tmp, &label_dsc, sizeof(label_dsc_tmp));
+
+                part_draw_dsc.label_dsc = &label_dsc_tmp;
+                char buf[16];
+
+                lv_snprintf(buf, sizeof(buf), "%" LV_PRId32, value_of_line / 5);
+                part_draw_dsc.text = buf;
+
+                lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);
+
+                lv_point_t label_size;
+                lv_txt_get_size(&label_size, part_draw_dsc.text, label_dsc.font, label_dsc.letter_space, label_dsc.line_space,
+                                LV_COORD_MAX, LV_TEXT_FLAG_NONE);
+
+                lv_area_t label_cord;
+                label_cord.x1 = p.x - label_size.x / 2;
+                label_cord.y1 = p.y - label_size.y / 2;
+                label_cord.x2 = label_cord.x1 + label_size.x;
+                label_cord.y2 = label_cord.y1 + label_size.y;
+                if(value_of_line != 0) {
+                    lv_draw_label(draw_ctx, part_draw_dsc.label_dsc, &label_cord, part_draw_dsc.text, NULL);
+                }
+                outer_mask_id = lv_draw_mask_add(&outer_mask, NULL);
+            }
+            else {
+                part_draw_dsc.label_dsc = NULL;
+                part_draw_dsc.text = NULL;
+                lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);
+            }
+
+            inner_act_mask_id = lv_draw_mask_add(major ? &inner_major_mask : &inner_minor_mask, NULL);
+            lv_draw_line(draw_ctx, &line_dsc, &p_outer, &p_center);
+            lv_draw_mask_remove_id(inner_act_mask_id);
+            lv_event_send(obj, LV_EVENT_DRAW_MAIN_END, &part_draw_dsc);
+
+            line_dsc.color = line_color_ori;
+            line_dsc.width = line_width_ori;
+
+        }
+        lv_draw_mask_free_param(&inner_minor_mask);
+        lv_draw_mask_free_param(&inner_major_mask);
+        lv_draw_mask_free_param(&outer_mask);
+        lv_draw_mask_remove_id(outer_mask_id);
+    }
+}
+
+
+static void draw_needles(lv_obj_t * obj, lv_draw_ctx_t * draw_ctx, const lv_area_t * scale_area)
+{
+    lv_analogclock_t * analogclock = (lv_analogclock_t *)obj;
+
+    lv_coord_t r_edge = lv_area_get_width(scale_area) / 2;
+    lv_point_t scale_center;
+    scale_center.x = scale_area->x1 + r_edge;
+    scale_center.y = scale_area->y1 + r_edge;
+
+    lv_draw_line_dsc_t line_dsc;
+    lv_draw_line_dsc_init(&line_dsc);
+    lv_obj_init_draw_line_dsc(obj, LV_PART_ITEMS, &line_dsc);
+
+    lv_draw_img_dsc_t img_dsc;
+    lv_draw_img_dsc_init(&img_dsc);
+    lv_obj_init_draw_img_dsc(obj, LV_PART_ITEMS, &img_dsc);
+    lv_opa_t opa_main = lv_obj_get_style_opa(obj, LV_PART_MAIN);
+
+    lv_obj_draw_part_dsc_t part_draw_dsc;
+    lv_obj_draw_dsc_init(&part_draw_dsc, draw_ctx);
+    part_draw_dsc.class_p = MY_CLASS;
+    part_draw_dsc.p1 = &scale_center;
+
+    lv_analogclock_indicator_t * indic;
+    _LV_LL_READ_BACK(&analogclock->indicator_ll, indic) {
+        lv_analogclock_scale_t * scale = indic->scale;
+        part_draw_dsc.sub_part_ptr = indic;
+
+        if(indic->type == LV_analogclock_INDICATOR_TYPE_NEEDLE_LINE) {
+            int32_t angle = lv_map(indic->end_value, scale->min, scale->max, scale->rotation, scale->rotation + scale->angle_range);
+            lv_coord_t r_out = r_edge + scale->r_mod + indic->type_data.needle_line.r_mod;
+            lv_point_t p_end;
+            p_end.y = (lv_trigo_sin(angle) * (r_out)) / LV_TRIGO_SIN_MAX + scale_center.y;
+            p_end.x = (lv_trigo_cos(angle) * (r_out)) / LV_TRIGO_SIN_MAX + scale_center.x;
+            line_dsc.color = indic->type_data.needle_line.color;
+            line_dsc.width = indic->type_data.needle_line.width;
+            line_dsc.opa = indic->opa > LV_OPA_MAX ? opa_main : (opa_main * indic->opa) >> 8;
+
+            part_draw_dsc.id = LV_analogclock_DRAW_PART_NEEDLE_LINE;
+            part_draw_dsc.line_dsc = &line_dsc;
+            part_draw_dsc.p2 = &p_end;
+
+            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);
+            lv_draw_line(draw_ctx, &line_dsc, &scale_center, &p_end);
+            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);
+        }
+        else if(indic->type == LV_analogclock_INDICATOR_TYPE_NEEDLE_IMG) {
+            if(indic->type_data.needle_img.src == NULL) continue;
+
+            int32_t angle = lv_map(indic->end_value, scale->min, scale->max, scale->rotation, scale->rotation + scale->angle_range);
+            lv_img_header_t info;
+            lv_img_decoder_get_info(indic->type_data.needle_img.src, &info);
+            lv_area_t a;
+            a.x1 = scale_center.x - indic->type_data.needle_img.pivot.x;
+            a.y1 = scale_center.y - indic->type_data.needle_img.pivot.y;
+            a.x2 = a.x1 + info.w - 1;
+            a.y2 = a.y1 + info.h - 1;
+
+            img_dsc.opa = indic->opa > LV_OPA_MAX ? opa_main : (opa_main * indic->opa) >> 8;
+            img_dsc.pivot.x = indic->type_data.needle_img.pivot.x;
+            img_dsc.pivot.y = indic->type_data.needle_img.pivot.y;
+            angle = angle * 10;
+            if(angle > 3600) angle -= 3600;
+            img_dsc.angle = angle;
+
+            part_draw_dsc.img_dsc = &img_dsc;
+
+            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);
+            lv_draw_img(draw_ctx, &img_dsc, &a, indic->type_data.needle_img.src);
+            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);
+        }
+    }
+}
+
+static void inv_arc(lv_obj_t * obj, lv_analogclock_indicator_t * indic, int32_t old_value, int32_t new_value)
+{
+    bool rounded = lv_obj_get_style_arc_rounded(obj, LV_PART_ITEMS);
+
+    lv_area_t scale_area;
+    lv_obj_get_content_coords(obj, &scale_area);
+
+    lv_coord_t r_out = lv_area_get_width(&scale_area) / 2;
+    lv_point_t scale_center;
+    scale_center.x = scale_area.x1 + r_out;
+    scale_center.y = scale_area.y1 + r_out;
+
+    r_out += indic->type_data.arc.r_mod;
+
+    lv_analogclock_scale_t * scale = indic->scale;
+
+    int32_t start_angle = lv_map(old_value, scale->min, scale->max, scale->rotation, scale->angle_range + scale->rotation);
+    int32_t end_angle = lv_map(new_value, scale->min, scale->max, scale->rotation, scale->angle_range + scale->rotation);
+
+    lv_area_t a;
+    lv_draw_arc_get_area(scale_center.x, scale_center.y, r_out, LV_MIN(start_angle, end_angle), LV_MAX(start_angle,
+                                                                                                       end_angle), indic->type_data.arc.width, rounded, &a);
+    lv_obj_invalidate_area(obj, &a);
+}
+
+
+static void inv_line(lv_obj_t * obj, lv_analogclock_indicator_t * indic, int32_t value)
+{
+    lv_area_t scale_area;
+    lv_obj_get_content_coords(obj, &scale_area);
+
+    lv_coord_t r_out = lv_area_get_width(&scale_area) / 2;
+    lv_point_t scale_center;
+    scale_center.x = scale_area.x1 + r_out;
+    scale_center.y = scale_area.y1 + r_out;
+
+    lv_analogclock_scale_t * scale = indic->scale;
+
+    if(indic->type == LV_analogclock_INDICATOR_TYPE_NEEDLE_LINE) {
+        int32_t angle = lv_map(value, scale->min, scale->max, scale->rotation, scale->rotation + scale->angle_range);
+        r_out += scale->r_mod + indic->type_data.needle_line.r_mod;
+        lv_point_t p_end;
+        p_end.y = (lv_trigo_sin(angle) * (r_out)) / LV_TRIGO_SIN_MAX + scale_center.y;
+        p_end.x = (lv_trigo_cos(angle) * (r_out)) / LV_TRIGO_SIN_MAX + scale_center.x;
+
+        lv_area_t a;
+        a.x1 = LV_MIN(scale_center.x, p_end.x) - indic->type_data.needle_line.width - 2;
+        a.y1 = LV_MIN(scale_center.y, p_end.y) - indic->type_data.needle_line.width - 2;
+        a.x2 = LV_MAX(scale_center.x, p_end.x) + indic->type_data.needle_line.width + 2;
+        a.y2 = LV_MAX(scale_center.y, p_end.y) + indic->type_data.needle_line.width + 2;
+
+        lv_obj_invalidate_area(obj, &a);
+    }
+    else if(indic->type == LV_analogclock_INDICATOR_TYPE_NEEDLE_IMG) {
+        int32_t angle = lv_map(value, scale->min, scale->max, scale->rotation, scale->rotation + scale->angle_range);
+        lv_img_header_t info;
+        lv_img_decoder_get_info(indic->type_data.needle_img.src, &info);
+
+        angle = angle * 10;
+        if(angle > 3600) angle -= 3600;
+
+        scale_center.x -= indic->type_data.needle_img.pivot.x;
+        scale_center.y -= indic->type_data.needle_img.pivot.y;
+        lv_area_t a;
+        _lv_img_buf_get_transformed_area(&a, info.w, info.h, angle, LV_IMG_ZOOM_NONE, &indic->type_data.needle_img.pivot);
+        a.x1 += scale_center.x - 2;
+        a.y1 += scale_center.y - 2;
+        a.x2 += scale_center.x + 2;
+        a.y2 += scale_center.y + 2;
+
+        lv_obj_invalidate_area(obj, &a);
+    }
+}
+#endif
diff --git a/src/extra/widgets/analogclock/lv_analogclock.h b/src/extra/widgets/analogclock/lv_analogclock.h
new file mode 100644
index 000000000..ef5f7212e
--- /dev/null
+++ b/src/extra/widgets/analogclock/lv_analogclock.h
@@ -0,0 +1,317 @@
+/**
+ * @file lv_analogclock.h
+ *
+ */
+
+#ifndef LV_ANALOGCLOCK_H
+#define LV_ANALOGCLOCK_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "../../../lvgl.h"
+
+#if LV_USE_ANALOGCLOCK != 0
+
+/*Testing of dependencies*/
+#if LV_DRAW_COMPLEX == 0
+#error "lv_analogclock: Complex drawing is required. Enable it in lv_conf.h (LV_DRAW_COMPLEX 1)"
+#endif
+
+/*********************
+ *      DEFINES
+ *********************/
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+typedef struct {
+    lv_color_t tick_color;
+    uint16_t tick_cnt;
+    uint16_t tick_length;
+    uint16_t tick_width;
+
+    lv_color_t tick_major_color;
+    uint16_t tick_major_nth;
+    uint16_t tick_major_length;
+    uint16_t tick_major_width;
+
+    bool hide_label;
+    int16_t label_gap;
+    int16_t label_color;
+
+    int32_t min;
+    int32_t max;
+    int16_t r_mod;
+    uint16_t angle_range;
+    int16_t rotation;
+} lv_analogclock_scale_t;
+
+enum {
+    LV_analogclock_INDICATOR_TYPE_NEEDLE_IMG,
+    LV_analogclock_INDICATOR_TYPE_NEEDLE_LINE,
+    LV_analogclock_INDICATOR_TYPE_SCALE_LINES,
+    LV_analogclock_INDICATOR_TYPE_ARC,
+};
+typedef uint8_t lv_analogclock_indicator_type_t;
+
+typedef struct {
+    lv_analogclock_scale_t * scale;
+    lv_analogclock_indicator_type_t type;
+    lv_opa_t opa;
+    int32_t start_value;
+    int32_t end_value;
+    union {
+        struct {
+            const void * src;
+            lv_point_t pivot;
+        } needle_img;
+        struct {
+            uint16_t width;
+            int16_t r_mod;
+            lv_color_t color;
+        } needle_line;
+        struct {
+            uint16_t width;
+            const void * src;
+            lv_color_t color;
+            int16_t r_mod;
+        } arc;
+        struct {
+            int16_t width_mod;
+            lv_color_t color_start;
+            lv_color_t color_end;
+            uint8_t local_grad  : 1;
+        } scale_lines;
+    } type_data;
+} lv_analogclock_indicator_t;
+
+/*Data of line analogclock*/
+typedef struct {
+    lv_obj_t obj;
+    lv_ll_t scale_ll;
+    lv_analogclock_scale_t * scale;
+    lv_ll_t indicator_ll;
+    bool hide_point;
+    lv_analogclock_indicator_t * hour_indic;
+    lv_analogclock_indicator_t * min_indic;
+    lv_analogclock_indicator_t * sec_indic;
+} lv_analogclock_t;
+
+extern const lv_obj_class_t lv_analogclock_class;
+
+/**
+ * `type` field in `lv_obj_draw_part_dsc_t` if `class_p = lv_analogclock_class`
+ * Used in `LV_EVENT_DRAW_PART_BEGIN` and `LV_EVENT_DRAW_PART_END`
+ */
+typedef enum {
+    LV_analogclock_DRAW_PART_ARC,             /**< The arc indicator*/
+    LV_analogclock_DRAW_PART_NEEDLE_LINE,     /**< The needle lines*/
+    LV_analogclock_DRAW_PART_NEEDLE_IMG,      /**< The needle images*/
+    LV_analogclock_DRAW_PART_TICK,            /**< The tick lines and labels*/
+} lv_analogclock_draw_part_type_t;
+
+/**********************
+ * GLOBAL PROTOTYPES
+ **********************/
+
+/**
+ * Create a analogclock object
+ * @param parent pointer to an object, it will be the parent of the new bar.
+ * @return pointer to the created analogclock
+ */
+lv_obj_t * lv_analogclock_create(lv_obj_t * parent);
+
+/*=====================
+ * Add scale
+ *====================*/
+
+/**
+ * Add a new scale to the analogclock.
+ * @param obj   pointer to a analogclock object
+ * @return      the new scale
+ * @note        Indicators can be attached to scales.
+ */
+lv_analogclock_scale_t * lv_analogclock_add_scale(lv_obj_t * obj);
+
+/*=====================
+ * Add scale
+ *====================*/
+/**
+ * Set the properties of the ticks of a scale
+ * @param obj       pointer to a analogclock object
+ * @param scale     pointer to scale (added to `analogclock`)
+ * @param cnt       number of tick lines
+ * @param width     width of tick lines
+ * @param len       length of tick lines
+ * @param color     color of tick lines
+ */
+void lv_analogclock_set_ticks(lv_obj_t * obj, uint16_t width, uint16_t len, lv_color_t color);
+
+/**
+ * Make some "normal" ticks major ticks and set their attributes.
+ * Texts with the current value are also added to the major ticks.
+ * @param obj           pointer to a analogclock object
+ * @param scale         pointer to scale (added to `analogclock`)
+ * @param nth           make every Nth normal tick major tick. (start from the first on the left)
+ * @param width         width of the major ticks
+ * @param len           length of the major ticks
+ * @param color         color of the major ticks
+ * @param label_gap     gap between the major ticks and the labels
+ */
+void lv_analogclock_set_major_ticks(lv_obj_t * obj, uint16_t width, uint16_t len, lv_color_t color, int16_t label_gap);
+
+
+/**
+ * Set the value and angular range of a scale.
+ * @param obj           pointer to a analogclock object
+ * @param scale         pointer to scale (added to `analogclock`)
+ * @param min           the minimum value
+ * @param max           the maximal value
+ * @param angle_range   the angular range of the scale
+ * @param rotation      the angular offset from the 3 o'clock position (clock-wise)
+ */
+void lv_analogclock_set_scale_range(lv_obj_t * obj, lv_analogclock_scale_t * scale, int32_t min, int32_t max,
+                                    uint32_t angle_range,
+                                    uint32_t rotation);
+
+/*=====================
+ * Hide digits / centerpoint
+ *====================*/
+
+/**
+ * Hide the digits or not
+ * @param obj           pointer to a analogclock object
+ * @param hide_digits   set whether has digits
+ */
+void lv_analogclock_hide_digits(lv_obj_t * obj, bool hide_digits);
+
+/**
+ * Hide the center point or not
+ * @param obj           pointer to a analogclock object
+ * @param hide_point    set whether has center point
+ */
+void lv_analogclock_hide_point(lv_obj_t * obj, bool hide_point);
+
+/*=====================
+ * Add indicator
+ *====================*/
+
+/**
+ * Add a needle line indicator the scale
+ * @param obj           pointer to a analogclock object
+ * @param scale         pointer to scale (added to `analogclock`)
+ * @param width         width of the line
+ * @param color         color of the line
+ * @param r_mod         the radius modifier (added to the scale's radius) to get the lines length
+ * @return              the new indicator
+ */
+lv_analogclock_indicator_t * lv_analogclock_add_needle_line(lv_obj_t * obj, lv_analogclock_scale_t * scale,
+                                                            uint16_t width,
+                                                            lv_color_t color, int16_t r_mod);
+void lv_analogclock_set_hour_needle_line(lv_obj_t * obj, uint16_t width,
+                                         lv_color_t color, int16_t r_mod);
+void lv_analogclock_set_min_needle_line(lv_obj_t * obj, uint16_t width,
+                                        lv_color_t color, int16_t r_mod);
+void lv_analogclock_set_sec_needle_line(lv_obj_t * obj, uint16_t width,
+                                        lv_color_t color, int16_t r_mod);
+
+/**
+ * Add a needle image indicator the scale
+ * @param obj           pointer to a analogclock object
+ * @param scale         pointer to scale (added to `analogclock`)
+ * @param src           the image source of the indicator. path or pointer to ::lv_img_dsc_t
+ * @param pivot_x       the X pivot point of the needle
+ * @param pivot_y       the Y pivot point of the needle
+ * @return              the new indicator
+ * @note                the needle image should point to the right, like -O----->
+ */
+lv_analogclock_indicator_t * lv_analogclock_add_needle_img(lv_obj_t * obj, lv_analogclock_scale_t * scale,
+                                                           const void * src,
+                                                           lv_coord_t pivot_x, lv_coord_t pivot_y);
+void lv_analogclock_set_hour_needle_img(lv_obj_t * obj, const void * src,
+                                        lv_coord_t pivot_x, lv_coord_t pivot_y);
+void lv_analogclock_set_min_needle_img(lv_obj_t * obj, const void * src,
+                                       lv_coord_t pivot_x, lv_coord_t pivot_y);
+void lv_analogclock_set_sec_needle_img(lv_obj_t * obj, const void * src,
+                                       lv_coord_t pivot_x, lv_coord_t pivot_y);
+
+/**
+ * Add an arc indicator the scale
+ * @param obj           pointer to a analogclock object
+ * @param scale         pointer to scale (added to `analogclock`)
+ * @param width         width of the arc
+ * @param color         color of the arc
+ * @param r_mod         the radius modifier (added to the scale's radius) to get the outer radius of the arc
+ * @return              the new indicator
+ */
+lv_analogclock_indicator_t * lv_analogclock_add_arc(lv_obj_t * obj, uint16_t width, lv_color_t color,
+                                                    int16_t r_mod);
+
+
+/**
+ * Add a scale line indicator the scale. It will modify the ticks.
+ * @param obj           pointer to a analogclock object
+ * @param scale         pointer to scale (added to `analogclock`)
+ * @param color_start   the start color
+ * @param color_end     the end color
+ * @param local         tell how to map start and end color. true: the indicator's start and end_value; false: the scale's min max value
+ * @param width_mod     add this the affected tick's width
+ * @return              the new indicator
+ */
+lv_analogclock_indicator_t * lv_analogclock_add_scale_lines(lv_obj_t * obj, lv_color_t color_start,
+                                                            lv_color_t color_end, bool local, int16_t width_mod);
+
+/*=====================
+ * Set indicator value
+ *====================*/
+
+/**
+ * Set the value of the indicator. It will set start and and value to the same value
+ * @param obj           pointer to a analogclock object
+ * @param indic         pointer to an indicator
+ * @param value         the new value
+ */
+void lv_analogclock_set_indicator_value(lv_obj_t * obj, lv_analogclock_indicator_t * indic, int32_t value);
+
+/**
+ * Set the start value of the indicator.
+ * @param obj           pointer to a analogclock object
+ * @param indic         pointer to an indicator
+ * @param value         the new value
+ */
+void lv_analogclock_set_indicator_start_value(lv_obj_t * obj, lv_analogclock_indicator_t * indic, int32_t value);
+
+/**
+ * Set the start value of the indicator.
+ * @param obj           pointer to a analogclock object
+ * @param indic         pointer to an indicator
+ * @param value         the new value
+ */
+void lv_analogclock_set_indicator_end_value(lv_obj_t * obj, lv_analogclock_indicator_t * indic, int32_t value);
+
+/**
+ * Set the time of clock.
+ * @param obj           pointer to a analogclock object
+ * @param hour          hour value
+ * @param min           minute value
+ * @param sec           second value
+ */
+void lv_analogclock_set_time(lv_obj_t * obj, int32_t hour, int32_t min, int32_t sec);
+
+/**********************
+ *      MACROS
+ **********************/
+
+#endif /*LV_USE_ANALOGCLOCK*/
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*LV_ANALOGCLOCK_H*/
diff --git a/src/extra/widgets/animimg/lv_animimg.c b/src/extra/widgets/animimg/lv_animimg.c
index 072d02e05..f409ecb89 100644
--- a/src/extra/widgets/animimg/lv_animimg.c
+++ b/src/extra/widgets/animimg/lv_animimg.c
@@ -64,13 +64,18 @@ lv_obj_t * lv_animimg_create(lv_obj_t * parent)
     return obj;
 }
 
-void lv_animimg_set_src(lv_obj_t * obj, const void * dsc[], uint8_t num)
+void lv_animimg_set_src(lv_obj_t * obj, const void * dsc[], uint8_t num, bool reverse)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     lv_animimg_t * animimg = (lv_animimg_t *)obj;
     animimg->dsc = dsc;
     animimg->pic_count = num;
-    lv_anim_set_values(&animimg->anim, 0, num);
+    if(reverse) {
+        lv_anim_set_values(&animimg->anim, num, 0);
+    }
+    else {
+        lv_anim_set_values(&animimg->anim, 0, num);
+    }
 }
 
 void lv_animimg_start(lv_obj_t * obj)
@@ -80,6 +85,14 @@ void lv_animimg_start(lv_obj_t * obj)
     lv_anim_start(&animimg->anim);
 }
 
+bool lv_animimg_del(lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_animimg_t * animimg = (lv_animimg_t *)obj;
+    return lv_anim_del(animimg, NULL);
+}
+
+
 /*=====================
  * Setter functions
  *====================*/
@@ -89,7 +102,6 @@ void lv_animimg_set_duration(lv_obj_t * obj, uint32_t duration)
     LV_ASSERT_OBJ(obj, MY_CLASS);
     lv_animimg_t * animimg = (lv_animimg_t *)obj;
     lv_anim_set_time(&animimg->anim, duration);
-    lv_anim_set_playback_delay(&animimg->anim, duration);
 }
 
 void lv_animimg_set_repeat_count(lv_obj_t * obj, uint16_t count)
@@ -99,6 +111,34 @@ void lv_animimg_set_repeat_count(lv_obj_t * obj, uint16_t count)
     lv_anim_set_repeat_count(&animimg->anim, count);
 }
 
+void lv_animimg_set_playback_time(lv_obj_t * obj, uint16_t duration)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_animimg_t * animimg = (lv_animimg_t *)obj;
+    lv_anim_set_playback_time(&animimg->anim, duration);
+}
+
+void lv_animimg_set_playback_delay(lv_obj_t * obj, uint16_t duration)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_animimg_t * animimg = (lv_animimg_t *)obj;
+    lv_anim_set_playback_delay(&animimg->anim, duration);
+}
+
+void lv_animimg_set_start_cb(lv_obj_t * obj, lv_anim_start_cb_t start_cb)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_animimg_t * animimg = (lv_animimg_t *)obj;
+    lv_anim_set_start_cb(&animimg->anim, start_cb);
+}
+
+void lv_animimg_set_ready_cb(lv_obj_t * obj, lv_anim_start_cb_t ready_cb)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_animimg_t * animimg = (lv_animimg_t *)obj;
+    lv_anim_set_ready_cb(&animimg->anim, ready_cb);
+}
+
 /*=====================
  * Getter functions
  *====================*/
@@ -127,12 +167,9 @@ static void lv_animimg_constructor(const lv_obj_class_t * class_p, lv_obj_t * ob
 
 static void index_change(lv_obj_t * obj, int32_t index)
 {
-    lv_coord_t idx;
     lv_animimg_t * animimg = (lv_animimg_t *)obj;
-
-    idx = index % animimg->pic_count;
-
-    lv_img_set_src(obj, animimg->dsc[idx]);
+    index = animimg->pic_count == index ? index - 1 : index;
+    lv_img_set_src(obj, animimg->dsc[index]);
 }
 
 #endif
diff --git a/src/extra/widgets/animimg/lv_animimg.h b/src/extra/widgets/animimg/lv_animimg.h
index 0ba01f239..7e3915632 100644
--- a/src/extra/widgets/animimg/lv_animimg.h
+++ b/src/extra/widgets/animimg/lv_animimg.h
@@ -68,8 +68,9 @@ lv_obj_t * lv_animimg_create(lv_obj_t * parent);
  * @param img pointer to an animation image object
  * @param dsc pointer to a series images
  * @param num images' number
+ * @param reverse play in reverse.
  */
-void lv_animimg_set_src(lv_obj_t * img, const void * dsc[], uint8_t num);
+void lv_animimg_set_src(lv_obj_t * img, const void * dsc[], uint8_t num, bool reverse);
 
 /**
  * Startup the image animation.
@@ -77,6 +78,12 @@ void lv_animimg_set_src(lv_obj_t * img, const void * dsc[], uint8_t num);
  */
 void lv_animimg_start(lv_obj_t * obj);
 
+/**
+ * Delete the image animation.
+ * @param obj pointer to an animation image object
+ */
+bool lv_animimg_del(lv_obj_t * obj);
+
 /**
  * Set the image animation duration time. unit:ms
  * @param img pointer to an animation image object
@@ -90,6 +97,34 @@ void lv_animimg_set_duration(lv_obj_t * img, uint32_t duration);
  */
 void lv_animimg_set_repeat_count(lv_obj_t * img, uint16_t count);
 
+/**
+ * Make the image animation to play back to when the forward direction is ready.
+ * @param img pointer to an animation image object
+ * @param duration the duration of the playback image animation in milliseconds. 0: disable playback
+ */
+void lv_animimg_set_playback_time(lv_obj_t * img, uint16_t duration);
+
+/**
+ * Make the image animation to play back to when the forward direction is ready.
+ * @param img pointer to an animation image object
+ * @param duration delay in milliseconds before starting the playback image animation.
+ */
+void lv_animimg_set_playback_delay(lv_obj_t * img, uint16_t duration);
+
+/**
+ * Set a function call when the animation image really starts (considering `delay`)
+ * @param img pointer to an animation image object
+ * @param start_cb  a function call when the animation is start
+ */
+void lv_animimg_set_start_cb(lv_obj_t * img, lv_anim_ready_cb_t start_cb);
+
+/**
+ * Set a function call when the animation is ready
+ * @param img pointer to an animation image object
+ * @param ready_cb  a function call when the animation is ready
+ */
+void lv_animimg_set_ready_cb(lv_obj_t * img, lv_anim_ready_cb_t ready_cb);
+
 /*=====================
  * Getter functions
  *====================*/
diff --git a/src/extra/widgets/carousel/lv_carousel.c b/src/extra/widgets/carousel/lv_carousel.c
new file mode 100644
index 000000000..36f155b9b
--- /dev/null
+++ b/src/extra/widgets/carousel/lv_carousel.c
@@ -0,0 +1,208 @@
+/**
+ * @file lv_carousel.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "lv_carousel.h"
+#if LV_USE_CAROUSEL
+
+/*********************
+ *      DEFINES
+ *********************/
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+/**********************
+ *  STATIC PROTOTYPES
+ **********************/
+static void lv_carousel_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_carousel_element_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void carousel_event_cb(lv_event_t * e);
+
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+
+const lv_obj_class_t lv_carousel_class = {.constructor_cb = lv_carousel_constructor,
+                                          .base_class = &lv_obj_class,
+                                          .instance_size = sizeof(lv_carousel_t)
+                                         };
+
+const lv_obj_class_t lv_carousel_element_class = {.constructor_cb = lv_carousel_element_constructor,
+                                                  .base_class = &lv_obj_class,
+                                                  .instance_size = sizeof(lv_carousel_element_t)
+                                                 };
+
+static uint32_t create_col_id;
+
+/**********************
+ *      MACROS
+ **********************/
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+lv_obj_t * lv_carousel_create(lv_obj_t * parent)
+{
+    LV_LOG_INFO("begin");
+    lv_obj_t * obj = lv_obj_class_create_obj(&lv_carousel_class, parent);
+    lv_carousel_t * carousel = (lv_carousel_t *) obj;
+    lv_obj_class_init_obj(obj);
+    carousel->sentinel = lv_obj_create(obj);
+    lv_obj_remove_style_all(carousel->sentinel);
+    return obj;
+}
+
+/*======================
+ * Add/remove functions
+ *=====================*/
+
+lv_obj_t * lv_carousel_add_element(lv_obj_t * obj, uint8_t id)
+{
+    LV_LOG_INFO("begin");
+    create_col_id = id;
+    lv_carousel_t * carousel = (lv_carousel_t *) obj;
+
+    lv_obj_t * element_obj = lv_obj_class_create_obj(&lv_carousel_element_class, obj);
+    lv_obj_class_init_obj(element_obj);
+    if(id == 0) {
+        carousel->element_act = element_obj;
+        lv_obj_add_state(carousel->element_act, LV_STATE_FOCUSED);
+    }
+
+    lv_obj_set_pos(carousel->sentinel, carousel->start_pos + ((carousel->element_width) * (create_col_id + 1)), 0);
+    lv_obj_set_size(carousel->sentinel, carousel->start_pos, LV_PCT(100));
+    lv_obj_update_layout(carousel->sentinel);
+    lv_obj_clear_flag(element_obj, LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_CLICKABLE);
+
+    // printf("sentinel: x : %d, width: %d\n", lv_obj_get_x(carousel->sentinel), lv_obj_get_width(carousel->sentinel));
+
+    return element_obj;
+}
+
+void lv_carousel_set_element_width(lv_obj_t * obj, lv_coord_t w)
+{
+    lv_carousel_t * carousel = (lv_carousel_t *) obj;
+    carousel->element_width = w;
+}
+
+void lv_obj_set_element(lv_obj_t * obj, lv_obj_t * element_obj, lv_anim_enable_t anim_en)
+{
+    lv_obj_update_layout(element_obj);
+    lv_coord_t tx = lv_obj_get_x(element_obj);
+    lv_coord_t ty = lv_obj_get_y(element_obj);
+
+    lv_carousel_element_t * element = (lv_carousel_element_t *)element_obj;
+    lv_carousel_t * carousel = (lv_carousel_t *) obj;
+    lv_obj_t * element_pre = carousel->element_act;
+    carousel->element_act = (lv_obj_t *)element;
+    tx -= carousel->start_pos;
+
+    lv_obj_clear_state(element_pre, LV_STATE_FOCUSED);
+    lv_obj_add_state(carousel->element_act, LV_STATE_FOCUSED);
+    //lv_obj_set_scroll_dir(obj, element->dir);
+    lv_obj_scroll_to(obj, tx, ty, anim_en);
+}
+
+void lv_obj_set_element_id(lv_obj_t * obj, uint32_t id, lv_anim_enable_t anim_en)
+{
+    lv_obj_update_layout(obj);
+
+    lv_carousel_t * carousel = (lv_carousel_t *) obj;
+    lv_coord_t tx = (carousel->element_width * id) + carousel->start_pos;
+    // printf("===============tx: %d\n", tx);
+
+    uint32_t i;
+    for(i = 0; i < lv_obj_get_child_cnt(obj); i++) {
+        lv_obj_t * element_obj = lv_obj_get_child(obj, i);
+        lv_coord_t x = lv_obj_get_x(element_obj);
+        // printf("===============i: %d, x: %d\n", i, x);
+        if(x == tx) {
+            lv_obj_set_element(obj, element_obj, anim_en);
+            return;
+        }
+    }
+
+    LV_LOG_WARN("No element found with at (%d) index", (int)id);
+}
+
+lv_obj_t * lv_carousel_get_element_act(lv_obj_t * obj)
+{
+    lv_carousel_t * carousel = (lv_carousel_t *) obj;
+    return carousel->element_act;
+}
+
+/**********************
+ *   STATIC FUNCTIONS
+ **********************/
+
+static void lv_carousel_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+
+    lv_obj_set_size(obj, 300, 100);
+    lv_carousel_set_element_width(obj, 100);
+    lv_obj_add_event_cb(obj, carousel_event_cb, LV_EVENT_ALL, NULL);
+    lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_ONE);
+    lv_obj_set_scroll_snap_x(obj, LV_SCROLL_SNAP_CENTER);
+}
+
+static void lv_carousel_element_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+
+    LV_UNUSED(class_p);
+    lv_obj_t * parent = lv_obj_get_parent(obj);
+    lv_carousel_t * carousel = (lv_carousel_t *) parent;
+    lv_coord_t carousel_width;
+    lv_obj_set_size(obj, carousel->element_width, LV_PCT(100));
+    lv_obj_update_layout(obj);  /*Be sure the size is correct*/
+
+    carousel_width = lv_obj_get_content_width(parent);
+    lv_coord_t startpos = (carousel_width - carousel->element_width) / 2;
+    carousel->start_pos = startpos;
+    lv_obj_set_pos(obj, startpos + ((carousel->element_width) * create_col_id), 0);
+}
+
+static void carousel_event_cb(lv_event_t * e)
+{
+    lv_event_code_t code = lv_event_get_code(e);
+    lv_obj_t * obj = lv_event_get_target(e);
+    lv_carousel_t * carousel = (lv_carousel_t *) obj;
+
+    if(code == LV_EVENT_SCROLL_END) {
+        lv_point_t scroll_end;
+        lv_obj_get_scroll_end(obj, &scroll_end);
+        lv_coord_t left = scroll_end.x;
+
+        lv_dir_t dir = LV_DIR_HOR;
+        uint32_t child_count = lv_obj_get_child_cnt(obj);
+        uint32_t i;
+        lv_obj_t * element_pre = carousel->element_act;
+        for(i = 0; i < child_count; i++) {
+            lv_obj_t * element_obj = lv_obj_get_child(obj, i);
+            lv_coord_t x = lv_obj_get_x(element_obj) - carousel->start_pos;
+            if(x == left) {
+                lv_carousel_element_t * element = (lv_carousel_element_t *)element_obj;
+                carousel->element_act = (lv_obj_t *)element;
+                lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);
+                if(left == (lv_coord_t)((child_count - 2) * carousel->element_width)) {
+                    dir = LV_DIR_LEFT;
+                }
+                else if(left == 0) {
+                    dir = LV_DIR_RIGHT;
+                }
+                break;
+            }
+        }
+        lv_obj_clear_state(element_pre, LV_STATE_FOCUSED);
+        lv_obj_add_state(carousel->element_act, LV_STATE_FOCUSED);
+        lv_obj_set_scroll_dir(obj, dir);
+    }
+}
+#endif /*LV_USE_CAROUSEL*/
diff --git a/src/extra/widgets/carousel/lv_carousel.h b/src/extra/widgets/carousel/lv_carousel.h
new file mode 100644
index 000000000..267d1427e
--- /dev/null
+++ b/src/extra/widgets/carousel/lv_carousel.h
@@ -0,0 +1,75 @@
+/**
+ * @file lv_carousel.h
+ *
+ */
+
+#ifndef LV_CAROUSEL_H
+#define LV_CAROUSEL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "../../../core/lv_obj.h"
+
+#if LV_USE_CAROUSEL
+
+/*********************
+ *      DEFINES
+ *********************/
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+typedef struct {
+    lv_obj_t obj;
+    lv_obj_t * element_act;
+    lv_obj_t * sentinel;
+    lv_coord_t element_width;
+    lv_coord_t start_pos;
+} lv_carousel_t;
+
+typedef struct {
+    lv_obj_t obj;
+    lv_dir_t dir;
+} lv_carousel_element_t;
+
+extern const lv_obj_class_t lv_carousel_class;
+extern const lv_obj_class_t lv_carousel_element_class;
+
+/**********************
+ * GLOBAL PROTOTYPES
+ **********************/
+
+/**
+ * Create a carousel object
+ * @param parent pointer to an object, it will be the parent of the new carousel
+ * @return pointer to the created carousel
+ */
+lv_obj_t * lv_carousel_create(lv_obj_t * parent);
+
+lv_obj_t * lv_carousel_add_element(lv_obj_t * obj, uint8_t id);
+void lv_carousel_set_element_width(lv_obj_t * obj, lv_coord_t w);
+void lv_obj_set_element(lv_obj_t * obj, lv_obj_t * element_obj, lv_anim_enable_t anim_en);
+void lv_obj_set_element_id(lv_obj_t * obj, uint32_t id, lv_anim_enable_t anim_en);
+
+lv_obj_t * lv_carousel_get_element_act(lv_obj_t * obj);
+
+/*=====================
+ * Other functions
+ *====================*/
+
+/**********************
+ *      MACROS
+ **********************/
+
+#endif /*LV_USE_carousel*/
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*LV_carousel_H*/
diff --git a/src/extra/widgets/dclock/lv_dclock.c b/src/extra/widgets/dclock/lv_dclock.c
new file mode 100644
index 000000000..00ca0f6dd
--- /dev/null
+++ b/src/extra/widgets/dclock/lv_dclock.c
@@ -0,0 +1,437 @@
+/**
+ * @file lv_dclock.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "lv_dclock.h"
+#if LV_USE_DCLOCK != 0
+#include "../../../core/lv_obj.h"
+#include "../../../misc/lv_assert.h"
+#include "../../../core/lv_group.h"
+#include "../../../draw/lv_draw.h"
+#include "../../../misc/lv_color.h"
+#include "../../../misc/lv_math.h"
+#include "../../../misc/lv_bidi.h"
+#include "../../../misc/lv_txt_ap.h"
+#include "../../../misc/lv_printf.h"
+#include "../../../widgets/lv_label.h"
+
+
+/*********************
+ *      DEFINES
+ *********************/
+#define MY_CLASS &lv_dclock_class
+
+#define LV_DCLOCK_DEF_SCROLL_SPEED   (lv_disp_get_dpi(lv_obj_get_disp(obj)) / 3)
+#define LV_DCLOCK_SCROLL_DELAY       300
+#define LV_DCLOCK_DOT_END_INV 0xFFFFFFFF
+#define LV_DCLOCK_HINT_HEIGHT_LIMIT 1024 /*Enable "hint" to buffer info about labels larger than this. (Speed up drawing)*/
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+/**********************
+ *  STATIC PROTOTYPES
+ **********************/
+static void lv_dclock_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_dclock_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_dclock_event(const lv_obj_class_t * class_p, lv_event_t * e);
+static void draw_main(lv_event_t * e);
+static void lv_dclock_refr_text(lv_obj_t * obj);
+
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+const lv_obj_class_t lv_dclock_class = {
+    .constructor_cb = lv_dclock_constructor,
+    .destructor_cb = lv_dclock_destructor,
+    .event_cb = lv_dclock_event,
+    .width_def = LV_SIZE_CONTENT,
+    .height_def = LV_SIZE_CONTENT,
+    .instance_size = sizeof(lv_dclock_t),
+    .base_class = &lv_obj_class
+};
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+lv_obj_t * lv_dclock_create(lv_obj_t * parent, char * input_time)
+{
+    LV_LOG_INFO("begin");
+    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);
+    lv_obj_class_init_obj(obj);
+    if(lv_obj_is_valid(obj)) {
+        lv_dclock_set_text_fmt(obj, "%s", input_time);
+    }
+    return obj;
+}
+
+void lv_dclock_set_text(lv_obj_t * obj, const char * text)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_dclock_t * dclock = (lv_dclock_t *)obj;
+
+    lv_obj_invalidate(obj);
+
+    /*If text is NULL then just refresh with the current text*/
+    if(text == NULL) text = dclock->text;
+
+    if(dclock->text == text && dclock->static_txt == 0) {
+        /*If set its own text then reallocate it (maybe its size changed)*/
+#if LV_USE_ARABIC_PERSIAN_CHARS
+        /*Get the size of the text and process it*/
+        size_t len = _lv_txt_ap_calc_bytes_cnt(text);
+
+        dclock->text = lv_mem_realloc(dclock->text, len);
+        LV_ASSERT_MALLOC(dclock->text);
+        if(dclock->text == NULL) return;
+
+        _lv_txt_ap_proc(dclock->text, dclock->text);
+#else
+        dclock->text = lv_mem_realloc(dclock->text, strlen(dclock->text) + 1);
+#endif
+
+        LV_ASSERT_MALLOC(dclock->text);
+        if(dclock->text == NULL) return;
+    }
+    else {
+        /*Free the old text*/
+        if(dclock->text != NULL && dclock->static_txt == 0) {
+            lv_mem_free(dclock->text);
+            dclock->text = NULL;
+        }
+
+#if LV_USE_ARABIC_PERSIAN_CHARS
+        /*Get the size of the text and process it*/
+        size_t len = _lv_txt_ap_calc_bytes_cnt(text);
+
+        dclock->text = lv_mem_alloc(len);
+        LV_ASSERT_MALLOC(dclock->text);
+        if(dclock->text == NULL) return;
+
+        _lv_txt_ap_proc(text, dclock->text);
+#else
+        /*Get the size of the text*/
+        size_t len = strlen(text) + 1;
+
+        /*Allocate space for the new text*/
+        dclock->text = lv_mem_alloc(len);
+        LV_ASSERT_MALLOC(dclock->text);
+        if(dclock->text == NULL) return;
+        strcpy(dclock->text, text);
+#endif
+
+        /*Now the text is dynamically allocated*/
+        dclock->static_txt = 0;
+    }
+
+    lv_dclock_refr_text(obj);
+}
+
+void lv_dclock_set_text_fmt(lv_obj_t * obj, const char * fmt, ...)
+{
+
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    LV_ASSERT_NULL(fmt);
+    lv_obj_invalidate(obj);
+    lv_dclock_t * dclock = (lv_dclock_t *)obj;
+
+    /*If text is NULL then refresh*/
+    if(fmt == NULL) {
+        lv_dclock_refr_text(obj);
+        return;
+    }
+
+    if(dclock->text != NULL && dclock->static_txt == 0) {
+        lv_mem_free(dclock->text);
+        dclock->text = NULL;
+    }
+
+    va_list args;
+    va_start(args, fmt);
+    dclock->text = _lv_txt_set_text_vfmt(fmt, args);
+    va_end(args);
+    dclock->static_txt = 0; /*Now the text is dynamically allocated*/
+
+    lv_dclock_refr_text(obj);
+}
+
+/*=====================
+ * Getter functions
+ *====================*/
+
+uint32_t lv_dclock_get_text_selection_start(const lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+#if LV_DCLOCK_TEXT_SELECTION
+    lv_dclock_t * dclock = (lv_dclock_t *)obj;
+    return dclock->sel_start;
+
+#else
+    LV_UNUSED(obj); /*Unused*/
+    return LV_DCLOCK_TEXT_SELECTION_OFF;
+#endif
+}
+
+uint32_t lv_dclock_get_text_selection_end(const lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+#if LV_DCLOCK_TEXT_SELECTION
+    lv_dclock_t * dclock = (lv_dclock_t *)obj;
+    return dclock->sel_end;
+#else
+    LV_UNUSED(obj); /*Unused*/
+    return LV_DCLOCK_TEXT_SELECTION_OFF;
+#endif
+}
+
+
+/*=====================
+ * Other functions
+ *====================*/
+
+/**
+ * @brief           Calculate the digital clock by the 24-hours mode
+ * @param obj       pointer to the values for hour/minute/seconds and the bool value to select AM/PM
+ * @return          selection end index. The function of lv_dclock_24_timer_cb will call it.
+ */
+void clock_count_24(int * hour, int * minute, int * seconds)
+{
+    (*seconds)++;
+
+    if(*seconds == 60) {
+        *seconds = 0;
+        (*minute)++;
+    }
+
+    if(*minute == 60) {
+        *minute = 0;
+        (*hour)++;
+    }
+
+    if(*hour == 24) {
+        *hour = 0;
+    }
+}
+
+/**
+ * @brief           Calculate the digital clock by the 12-hours mode
+ * @param obj       pointer to the values for hour/minute/seconds and the bool value to select AM/PM
+ * @return          selection end index. The function of lv_dclock_12_timer_cb will call it.
+ */
+void clock_count_12(int * hour, int * minute, int * seconds, char * meridiem)
+{
+
+    (*seconds)++;
+    if(*seconds == 60) {
+        *seconds = 0;
+        (*minute)++;
+    }
+    if(*minute == 60) {
+        *minute = 0;
+        if(*hour < 12) {
+            (*hour)++;
+        }
+        else {
+            (*hour)++;
+            (*hour) = (*hour) % 12;
+        }
+    }
+    if(*hour == 12 && *seconds == 0 && *minute == 0) {
+        if((strcmp(meridiem, "PM") == 0)) {
+            strcpy(meridiem, "AM");
+        }
+        else {
+            strcpy(meridiem, "PM");
+        }
+    }
+}
+
+
+/**********************
+ *   STATIC FUNCTIONS
+ **********************/
+
+static void lv_dclock_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    LV_TRACE_OBJ_CREATE("begin");
+
+    lv_dclock_t * dclock = (lv_dclock_t *)obj;
+
+    dclock->text       = NULL;
+    dclock->static_txt = 0;
+    dclock->recolor    = 0;
+    dclock->offset.x = 0;
+    dclock->offset.y = 0;
+
+#if LV_DCLOCK_TEXT_SELECTION
+    dclock->sel_start = LV_DRAW_LABEL_NO_TXT_SEL;
+    dclock->sel_end   = LV_DRAW_LABEL_NO_TXT_SEL;
+#endif
+
+    lv_obj_clear_flag(obj, LV_OBJ_FLAG_CLICKABLE);
+
+    LV_TRACE_OBJ_CREATE("finished");
+}
+
+static void lv_dclock_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    lv_dclock_t * dclock = (lv_dclock_t *)obj;
+
+    if(!dclock->static_txt) lv_mem_free(dclock->text);
+    dclock->text = NULL;
+}
+
+static void lv_dclock_event(const lv_obj_class_t * class_p, lv_event_t * e)
+{
+    LV_UNUSED(class_p);
+
+    lv_res_t res;
+
+    /*Call the ancestor's event handler*/
+    res = lv_obj_event_base(MY_CLASS, e);
+    if(res != LV_RES_OK) return;
+
+    lv_event_code_t code = lv_event_get_code(e);
+    lv_obj_t * obj = lv_event_get_target(e);
+
+    if(code == LV_EVENT_STYLE_CHANGED) {
+        lv_dclock_refr_text(obj);
+    }
+    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {
+        /* Italic or other non-typical letters can be drawn of out of the object.
+         * It happens if box_w + ofs_x > adw_w in the glyph.
+         * To avoid this add some extra draw area.
+         * font_h / 4 is an empirical value. */
+        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);
+        lv_coord_t font_h = lv_font_get_line_height(font);
+        lv_event_set_ext_draw_size(e, font_h / 4);
+    }
+    else if(code == LV_EVENT_SIZE_CHANGED) {
+        lv_dclock_refr_text(obj);
+    }
+    else if(code == LV_EVENT_GET_SELF_SIZE) {
+        lv_point_t size;
+        lv_dclock_t * dclock = (lv_dclock_t *)obj;
+        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);
+        lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);
+        lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);
+        lv_text_flag_t flag = LV_TEXT_FLAG_NONE;
+        if(dclock->recolor != 0) flag |= LV_TEXT_FLAG_RECOLOR;
+        if(dclock->expand != 0) flag |= LV_TEXT_FLAG_EXPAND;
+
+        lv_coord_t w = lv_obj_get_content_width(obj);
+        if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT && !obj->w_layout) w = LV_COORD_MAX;
+        else w = lv_obj_get_content_width(obj);
+
+        lv_txt_get_size(&size, dclock->text, font, letter_space, line_space, w, flag);
+
+        lv_point_t * self_size = lv_event_get_param(e);
+        self_size->x = LV_MAX(self_size->x, size.x);
+        self_size->y = LV_MAX(self_size->y, size.y);
+    }
+    else if(code == LV_EVENT_DRAW_MAIN) {
+        draw_main(e);
+    }
+}
+
+static void draw_main(lv_event_t * e)
+{
+    lv_obj_t * obj = lv_event_get_target(e);
+    lv_dclock_t * dclock = (lv_dclock_t *)obj;
+    lv_draw_ctx_t * draw_ctx = lv_event_get_draw_ctx(e);
+
+    lv_area_t txt_coords;
+    lv_obj_get_content_coords(obj, &txt_coords);
+
+    lv_text_flag_t flag = LV_TEXT_FLAG_NONE;
+    if(dclock->recolor != 0) flag |= LV_TEXT_FLAG_RECOLOR;
+    if(dclock->expand != 0) flag |= LV_TEXT_FLAG_EXPAND;
+    if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT && !obj->w_layout) flag |= LV_TEXT_FLAG_FIT;
+
+    lv_draw_label_dsc_t dclock_draw_dsc;
+    lv_draw_label_dsc_init(&dclock_draw_dsc);
+
+    dclock_draw_dsc.ofs_x = dclock->offset.x;
+    dclock_draw_dsc.ofs_y = dclock->offset.y;
+
+    dclock_draw_dsc.flag = flag;
+    lv_obj_init_draw_label_dsc(obj, LV_PART_MAIN, &dclock_draw_dsc);
+    lv_bidi_calculate_align(&dclock_draw_dsc.align, &dclock_draw_dsc.bidi_dir, dclock->text);
+
+    dclock_draw_dsc.sel_start = lv_dclock_get_text_selection_start(obj);
+    dclock_draw_dsc.sel_end = lv_dclock_get_text_selection_end(obj);
+    if(dclock_draw_dsc.sel_start != LV_DRAW_LABEL_NO_TXT_SEL && dclock_draw_dsc.sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {
+        dclock_draw_dsc.sel_color = lv_obj_get_style_text_color_filtered(obj, LV_PART_SELECTED);
+        dclock_draw_dsc.sel_bg_color = lv_obj_get_style_bg_color(obj, LV_PART_SELECTED);
+    }
+
+    /* In SCROLL and SCROLL_CIRCULAR mode the CENTER and RIGHT are pointless, so remove them.
+     * (In addition, they will create misalignment in this situation)*/
+
+#if LV_DCLOCK_LONG_TXT_HINT
+    lv_draw_label_hint_t * hint = &dclock->hint;
+    if(dclock->long_mode == LV_DCLOCK_LONG_SCROLL_CIRCULAR || lv_area_get_height(&txt_coords) < LV_DCLOCK_HINT_HEIGHT_LIMIT)
+        hint = NULL;
+
+#else
+    /*Just for compatibility*/
+    lv_draw_label_hint_t * hint = NULL;
+#endif
+
+    lv_area_t txt_clip;
+    bool is_common = _lv_area_intersect(&txt_clip, &txt_coords, draw_ctx->clip_area);
+    if(!is_common) return;
+
+    lv_draw_label(draw_ctx, &dclock_draw_dsc, &txt_coords, dclock->text, hint); /// copy the above case
+    const lv_area_t * clip_area_ori = draw_ctx->clip_area;
+    draw_ctx->clip_area = &txt_clip;
+
+    draw_ctx->clip_area = clip_area_ori;
+}
+
+/**
+ * Refresh the dclock with its text stored in its extended data
+ * @param dclock pointer to a label object
+ */
+static void lv_dclock_refr_text(lv_obj_t * obj)
+{
+
+    lv_dclock_t * dclock = (lv_dclock_t *)obj;
+    if(dclock->text == NULL) return;
+#if LV_DCLOCK_LONG_TXT_HINT
+    dclock->hint.line_start = -1; /*The hint is invalid if the text changes*/
+#endif
+
+    lv_area_t txt_coords;
+    lv_obj_get_content_coords(obj, &txt_coords);
+    lv_coord_t max_w         = lv_area_get_width(&txt_coords);
+    const lv_font_t * font   = lv_obj_get_style_text_font(obj, LV_PART_MAIN);
+    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);
+    lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);
+
+    /*Calc. the height and longest line*/
+    lv_point_t size;
+    lv_text_flag_t flag = LV_TEXT_FLAG_NONE;
+    if(dclock->recolor != 0) flag |= LV_TEXT_FLAG_RECOLOR;
+    if(dclock->expand != 0) flag |= LV_TEXT_FLAG_EXPAND;
+    if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT && !obj->w_layout) flag |= LV_TEXT_FLAG_FIT;
+
+    lv_txt_get_size(&size, dclock->text, font, letter_space, line_space, max_w, flag);
+
+    lv_obj_refresh_self_size(obj);
+
+    lv_obj_invalidate(obj);
+
+}
+
+#endif
diff --git a/src/extra/widgets/dclock/lv_dclock.h b/src/extra/widgets/dclock/lv_dclock.h
new file mode 100644
index 000000000..fcf1885a8
--- /dev/null
+++ b/src/extra/widgets/dclock/lv_dclock.h
@@ -0,0 +1,130 @@
+/**
+ * @file lv_dclock.h
+ *
+ */
+
+#ifndef LV_DCLOCK_H
+#define LV_DCLOCK_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "../../../lv_conf_internal.h"
+
+#if LV_USE_DCLOCK != 0
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include "../../../core/lv_obj.h"
+#include "../../../font/lv_font.h"
+#include "../../../font/lv_symbol_def.h"
+#include "../../../misc/lv_txt.h"
+#include "../../../draw/lv_draw.h"
+
+/*********************
+ *      DEFINES
+ *********************/
+#define LV_DCLOCK_WAIT_CHAR_COUNT        3
+#define LV_DCLOCK_DOT_NUM 3
+#define LV_DCLOCK_POS_LAST 0xFFFF
+#define LV_DCLOCK_TEXT_SELECTION_OFF LV_DRAW_LABEL_NO_TXT_SEL
+
+
+LV_EXPORT_CONST_INT(LV_DCLOCK_DOT_NUM);
+LV_EXPORT_CONST_INT(LV_DCLOCK_POS_LAST);
+LV_EXPORT_CONST_INT(LV_DCLOCK_TEXT_SELECTION_OFF);
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+
+typedef struct {
+    lv_obj_t obj;
+    char * text;
+
+#if LV_DCLOCK_TEXT_SELECTION
+    uint32_t sel_start;
+    uint32_t sel_end;
+#endif
+
+    lv_point_t offset; /*Text draw position offset*/
+    uint8_t static_txt : 1;             /*Flag to indicate the text is static*/
+    uint8_t recolor : 1;                /*Enable in-line letter re-coloring*/
+    uint8_t expand : 1;                 /*Ignore real width (used by the library with LV_LABEL_LONG_SCROLL)*/
+} lv_dclock_t;
+
+
+extern const lv_obj_class_t lv_dclock_class;
+
+/**********************
+ * GLOBAL PROTOTYPES
+ **********************/
+
+/**
+ * Create a dclock object
+ * @param parent    pointer to an object, it will be the parent of the new label.
+         input_time  Type the time as the following:
+ * @return          pointer to the created button
+ * Example:  lv_obj_t * dclock = lv_dclock_create(lv_obj_t * parent,"11:59:55 AM", LV_DCLOCK_SHOW_SECONDS_TRUE,LV_DCLOCK_SHOW_MERIDIEM_TRUE);
+ */
+
+lv_obj_t * lv_dclock_create(lv_obj_t * parent, char * input_time);
+
+/*=====================
+ * Setter functions
+ *====================*/
+
+void lv_dclock_set_text_fmt(lv_obj_t * obj, const char * fmt, ...) LV_FORMAT_ATTRIBUTE(2, 3);
+
+void lv_dclock_set_text(lv_obj_t * obj, const char * text);
+
+/**
+ * @brief           Calculate the digital clock by the 12-hours mode
+ * @param obj       pointer to the values for hour/minute/seconds and the bool value to select AM/PM
+ * @return          selection end index. The function of lv_dclock_12_timer_cb will call it.
+ */
+void clock_count_12(int * hour, int * minute, int * seconds, char * meridiem);
+
+
+/**
+ * @brief           Calculate the digital clock by the 24-hours mode
+ * @param obj       pointer to the values for hour/minute/seconds and the bool value to select AM/PM
+ * @return          selection end index. The function of lv_dclock_24_timer_cb will call it.
+ */
+void clock_count_24(int * hour, int * minute, int * seconds);
+
+/*=====================
+ * Getter functions
+ *====================*/
+
+/**
+ * @brief Get the selection start index.
+ * @param obj       pointer to a dclock object.
+ * @return          selection start index. `LV_LABEL_TEXT_SELECTION_OFF` if nothing is selected.
+ */
+uint32_t lv_dclock_get_text_selection_start(const lv_obj_t * obj);
+
+/**
+ * @brief Get the selection end index.
+ * @param obj       pointer to a dclock object.
+ * @return          selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected.
+ */
+uint32_t lv_dclock_get_text_selection_end(const lv_obj_t * obj);
+
+
+/**********************
+ *      MACROS
+ **********************/
+
+#endif /*LV_USE_DCLOCK*/
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*LV_DCLOCK_H*/
diff --git a/src/extra/widgets/keyboard/chinese_library.h b/src/extra/widgets/keyboard/chinese_library.h
new file mode 100644
index 000000000..077286634
--- /dev/null
+++ b/src/extra/widgets/keyboard/chinese_library.h
@@ -0,0 +1,1237 @@
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+
+#if LV_USE_ZH_KEYBOARD
+
+struct PINYIN_initials {
+    char * PINYIN;
+    char * PINYIN_mp;
+};
+
+#if LV_ZH_KEYBOARD_MINI
+/*Chinese Characters UTF-8*/
+static char PINYIN_mp_a[] = {""};
+static char PINYIN_mp_ai[] = {""};
+static char PINYIN_mp_an[] = {""};
+static char PINYIN_mp_ang[] = {""};
+static char PINYIN_mp_ao[] = {""};
+static char PINYIN_mp_ba[] = {""};
+static char PINYIN_mp_bai[] = {""};
+static char PINYIN_mp_ban[] = {""};
+static char PINYIN_mp_bang[] = {""};
+static char PINYIN_mp_bao[] = {""};
+static char PINYIN_mp_bei[] = {""};
+static char PINYIN_mp_ben[] = {""};
+static char PINYIN_mp_beng[] = {""};
+static char PINYIN_mp_bi[] = {""};
+static char PINYIN_mp_bian[] = {""};
+static char PINYIN_mp_biao[] = {""};
+static char PINYIN_mp_bie[] = {""};
+static char PINYIN_mp_bin[] = {""};
+static char PINYIN_mp_bing[] = {""};
+static char PINYIN_mp_bo[] = {""};
+static char PINYIN_mp_bu[] = {""};
+static char PINYIN_mp_ca[] = {""};
+static char PINYIN_mp_cai[] = {""};
+static char PINYIN_mp_can[] = {""};
+static char PINYIN_mp_cang[] = {""};
+static char PINYIN_mp_cao[] = {""};
+static char PINYIN_mp_ce[] = {""};
+static char PINYIN_mp_cen[] = {""};
+static char PINYIN_mp_ceng[] = {""};
+static char PINYIN_mp_cha[] = {""};
+static char PINYIN_mp_chai[] = {""};
+static char PINYIN_mp_chan[] = {""};
+static char PINYIN_mp_chang[] = {""};
+static char PINYIN_mp_chao[] = {""};
+static char PINYIN_mp_che[] = {""};
+static char PINYIN_mp_chen[] = {""};
+static char PINYIN_mp_cheng[] = {""};
+static char PINYIN_mp_chi[] = {""};
+static char PINYIN_mp_chong[] = {""};
+static char PINYIN_mp_chou[] = {""};
+static char PINYIN_mp_chu[] = {""};
+static char PINYIN_mp_chuai[] = {""};
+static char PINYIN_mp_chuan[] = {""};
+static char PINYIN_mp_chuang[] = {""};
+static char PINYIN_mp_chui[] = {""};
+static char PINYIN_mp_chun[] = {""};
+static char PINYIN_mp_chuo[] = {""};
+static char PINYIN_mp_ci[] = {""};
+static char PINYIN_mp_cong[] = {""};
+static char PINYIN_mp_cou[] = {""};
+static char PINYIN_mp_cu[] = {""};
+static char PINYIN_mp_cuan[] = {""};
+static char PINYIN_mp_cui[] = {""};
+static char PINYIN_mp_cun[] = {""};
+static char PINYIN_mp_cuo[] = {""};
+static char PINYIN_mp_da[] = {""};
+static char PINYIN_mp_dai[] = {""};
+static char PINYIN_mp_dan[] = {""};
+static char PINYIN_mp_dang[] = {""};
+static char PINYIN_mp_dao[] = {""};
+static char PINYIN_mp_de[] = {""};
+static char PINYIN_mp_dei[] = {""};
+static char PINYIN_mp_deng[] = {""};
+static char PINYIN_mp_di[] = {""};
+static char PINYIN_mp_dia[] = {""};
+static char PINYIN_mp_dian[] = {""};
+static char PINYIN_mp_diao[] = {""};
+static char PINYIN_mp_die[] = {""};
+static char PINYIN_mp_ding[] = {""};
+static char PINYIN_mp_diu[] = {""};
+static char PINYIN_mp_dong[] = {""};
+static char PINYIN_mp_dou[] = {""};
+static char PINYIN_mp_du[] = {""};
+static char PINYIN_mp_duan[] = {""};
+static char PINYIN_mp_dui[] = {""};
+static char PINYIN_mp_dun[] = {""};
+static char PINYIN_mp_duo[] = {""};
+static char PINYIN_mp_e[] = {""};
+static char PINYIN_mp_ei[] = {""};
+static char PINYIN_mp_en[] = {""};
+static char PINYIN_mp_er[] = {""};
+static char PINYIN_mp_fa[] = {""};
+static char PINYIN_mp_fan[] = {""};
+static char PINYIN_mp_fang[] = {""};
+static char PINYIN_mp_fei[] = {""};
+static char PINYIN_mp_fen[] = {""};
+static char PINYIN_mp_feng[] = {""};
+static char PINYIN_mp_fo[] = {""};
+static char PINYIN_mp_fou[] = {""};
+static char PINYIN_mp_fu[] = {""};
+static char PINYIN_mp_ga[] = {""};
+static char PINYIN_mp_gai[] = {""};
+static char PINYIN_mp_gan[] = {""};
+static char PINYIN_mp_gang[] = {""};
+static char PINYIN_mp_gao[] = {""};
+static char PINYIN_mp_ge[] = {""};
+static char PINYIN_mp_gei[] = {""};
+static char PINYIN_mp_gen[] = {""};
+static char PINYIN_mp_geng[] = {""};
+static char PINYIN_mp_gong[] = {""};
+static char PINYIN_mp_gou[] = {""};
+static char PINYIN_mp_gu[] = {""};
+static char PINYIN_mp_gua[] = {""};
+static char PINYIN_mp_guai[] = {""};
+static char PINYIN_mp_guan[] = {""};
+static char PINYIN_mp_guang[] = {""};
+static char PINYIN_mp_gui[] = {""};
+static char PINYIN_mp_gun[] = {""};
+static char PINYIN_mp_guo[] = {""};
+static char PINYIN_mp_ha[] = {""};
+static char PINYIN_mp_hai[] = {""};
+static char PINYIN_mp_han[] = {""};
+static char PINYIN_mp_hang[] = {""};
+static char PINYIN_mp_hao[] = {""};
+static char PINYIN_mp_he[] = {""};
+static char PINYIN_mp_hei[] = {""};
+static char PINYIN_mp_hen[] = {""};
+static char PINYIN_mp_heng[] = {""};
+static char PINYIN_mp_hong[] = {""};
+static char PINYIN_mp_hou[] = {""};
+static char PINYIN_mp_hu[] = {""};
+static char PINYIN_mp_hua[] = {""};
+static char PINYIN_mp_huai[] = {""};
+static char PINYIN_mp_huan[] = {""};
+static char PINYIN_mp_huang[] = {""};
+static char PINYIN_mp_hui[] = {""};
+static char PINYIN_mp_hun[] = {""};
+static char PINYIN_mp_huo[] = {""};
+static char PINYIN_mp_ji[] = {""};
+static char PINYIN_mp_jia[] = {""};
+static char PINYIN_mp_jian[] = {""};
+static char PINYIN_mp_jiang[] = {""};
+static char PINYIN_mp_jiao[] = {""};
+static char PINYIN_mp_jie[] = {""};
+static char PINYIN_mp_jin[] = {""};
+static char PINYIN_mp_jing[] = {""};
+static char PINYIN_mp_jiong[] = {""};
+static char PINYIN_mp_jiu[] = {""};
+static char PINYIN_mp_ju[] = {""};
+static char PINYIN_mp_juan[] = {""};
+static char PINYIN_mp_jue[] = {""};
+static char PINYIN_mp_jun[] = {""};
+static char PINYIN_mp_ka[] = {""};
+static char PINYIN_mp_kai[] = {""};
+static char PINYIN_mp_kan[] = {""};
+static char PINYIN_mp_kang[] = {""};
+static char PINYIN_mp_kao[] = {""};
+static char PINYIN_mp_ke[] = {""};
+static char PINYIN_mp_ken[] = {""};
+static char PINYIN_mp_keng[] = {""};
+static char PINYIN_mp_kong[] = {""};
+static char PINYIN_mp_kou[] = {""};
+static char PINYIN_mp_ku[] = {""};
+static char PINYIN_mp_kua[] = {""};
+static char PINYIN_mp_kuai[] = {""};
+static char PINYIN_mp_kuan[] = {""};
+static char PINYIN_mp_kuang[] = {""};
+static char PINYIN_mp_kui[] = {""};
+static char PINYIN_mp_kun[] = {""};
+static char PINYIN_mp_kuo[] = {""};
+static char PINYIN_mp_la[] = {""};
+static char PINYIN_mp_lai[] = {""};
+static char PINYIN_mp_lan[] = {""};
+static char PINYIN_mp_lang[] = {""};
+static char PINYIN_mp_lao[] = {""};
+static char PINYIN_mp_le[] = {""};
+static char PINYIN_mp_lei[] = {""};
+static char PINYIN_mp_leng[] = {""};
+static char PINYIN_mp_li[] = {""};
+static char PINYIN_mp_lia[] = {""};
+static char PINYIN_mp_lian[] = {""};
+static char PINYIN_mp_liang[] = {""};
+static char PINYIN_mp_liao[] = {""};
+static char PINYIN_mp_lie[] = {""};
+static char PINYIN_mp_lin[] = {""};
+static char PINYIN_mp_ling[] = {""};
+static char PINYIN_mp_liu[] = {""};
+static char PINYIN_mp_lo[] = {""};
+static char PINYIN_mp_long[] = {""};
+static char PINYIN_mp_lou[] = {""};
+static char PINYIN_mp_lu[] = {""};
+static char PINYIN_mp_luan[] = {""};
+static char PINYIN_mp_lun[] = {""};
+static char PINYIN_mp_luo[] = {""};
+static char PINYIN_mp_lv[] = {""};
+static char PINYIN_mp_lue[] = {""};
+static char PINYIN_mp_ma[] = {""};
+static char PINYIN_mp_mai[] = {""};
+static char PINYIN_mp_man[] = {""};
+static char PINYIN_mp_mang[] = {""};
+static char PINYIN_mp_mao[] = {""};
+static char PINYIN_mp_me[] = {""};
+static char PINYIN_mp_mei[] = {""};
+static char PINYIN_mp_men[] = {""};
+static char PINYIN_mp_meng[] = {""};
+static char PINYIN_mp_mi[] = {""};
+static char PINYIN_mp_mian[] = {""};
+static char PINYIN_mp_miao[] = {""};
+static char PINYIN_mp_mie[] = {""};
+static char PINYIN_mp_min[] = {""};
+static char PINYIN_mp_ming[] = {""};
+static char PINYIN_mp_miu[] = {""};
+static char PINYIN_mp_mo[] = {""};
+static char PINYIN_mp_mou[] = {""};
+static char PINYIN_mp_mu[] = {""};
+static char PINYIN_mp_na[] = {""};
+static char PINYIN_mp_nai[] = {""};
+static char PINYIN_mp_nan[] = {""};
+static char PINYIN_mp_nang[] = {""};
+static char PINYIN_mp_nao[] = {""};
+static char PINYIN_mp_ne[] = {""};
+static char PINYIN_mp_nei[] = {""};
+static char PINYIN_mp_nen[] = {""};
+static char PINYIN_mp_neng[] = {""};
+static char PINYIN_mp_ng[] = {""};
+static char PINYIN_mp_ni[] = {""};
+static char PINYIN_mp_nian[] = {""};
+static char PINYIN_mp_niang[] = {""};
+static char PINYIN_mp_niao[] = {""};
+static char PINYIN_mp_nie[] = {""};
+static char PINYIN_mp_nin[] = {""};
+static char PINYIN_mp_ning[] = {""};
+static char PINYIN_mp_niu[] = {""};
+static char PINYIN_mp_nong[] = {""};
+static char PINYIN_mp_nou[] = {""};
+static char PINYIN_mp_nu[] = {""};
+static char PINYIN_mp_nv[] = {""};
+static char PINYIN_mp_nue[] = {""};
+static char PINYIN_mp_nuan[] = {""};
+static char PINYIN_mp_nuo[] = {""};
+static char PINYIN_mp_o[] = {""};
+static char PINYIN_mp_ou[] = {""};
+static char PINYIN_mp_pa[] = {""};
+static char PINYIN_mp_pai[] = {""};
+static char PINYIN_mp_pan[] = {""};
+static char PINYIN_mp_pang[] = {""};
+static char PINYIN_mp_pao[] = {""};
+static char PINYIN_mp_pei[] = {""};
+static char PINYIN_mp_pen[] = {""};
+static char PINYIN_mp_peng[] = {""};
+static char PINYIN_mp_pi[] = {""};
+static char PINYIN_mp_pian[] = {""};
+static char PINYIN_mp_piao[] = {""};
+static char PINYIN_mp_pie[] = {""};
+static char PINYIN_mp_pin[] = {""};
+static char PINYIN_mp_ping[] = {""};
+static char PINYIN_mp_po[] = {""};
+static char PINYIN_mp_pou[] = {""};
+static char PINYIN_mp_pu[] = {""};
+static char PINYIN_mp_qi[] = {""};
+static char PINYIN_mp_qia[] = {""};
+static char PINYIN_mp_qian[] = {""};
+static char PINYIN_mp_qiang[] = {""};
+static char PINYIN_mp_qiao[] = {""};
+static char PINYIN_mp_qie[] = {""};
+static char PINYIN_mp_qin[] = {""};
+static char PINYIN_mp_qing[] = {""};
+static char PINYIN_mp_qiong[] = {""};
+static char PINYIN_mp_qiu[] = {""};
+static char PINYIN_mp_qu[] = {""};
+static char PINYIN_mp_quan[] = {""};
+static char PINYIN_mp_que[] = {""};
+static char PINYIN_mp_qui[] = {""};
+static char PINYIN_mp_qun[] = {""};
+static char PINYIN_mp_ran[] = {""};
+static char PINYIN_mp_rang[] = {""};
+static char PINYIN_mp_rao[] = {""};
+static char PINYIN_mp_re[] = {""};
+static char PINYIN_mp_ren[] = {""};
+static char PINYIN_mp_reng[] = {""};
+static char PINYIN_mp_ri[] = {""};
+static char PINYIN_mp_rong[] = {""};
+static char PINYIN_mp_rou[] = {""};
+static char PINYIN_mp_ru[] = {""};
+static char PINYIN_mp_ruan[] = {""};
+static char PINYIN_mp_rui[] = {""};
+static char PINYIN_mp_run[] = {""};
+static char PINYIN_mp_ruo[] = {""};
+static char PINYIN_mp_sa[] = {""};
+static char PINYIN_mp_sai[] = {""};
+static char PINYIN_mp_san[] = {""};
+static char PINYIN_mp_sang[] = {""};
+static char PINYIN_mp_sao[] = {""};
+static char PINYIN_mp_se[] = {""};
+static char PINYIN_mp_sen[] = {""};
+static char PINYIN_mp_seng[] = {""};
+static char PINYIN_mp_sha[] = {""};
+static char PINYIN_mp_shai[] = {""};
+static char PINYIN_mp_shan[] = {""};
+static char PINYIN_mp_shang[] = {""};
+static char PINYIN_mp_shao[] = {""};
+static char PINYIN_mp_she[] = {""};
+static char PINYIN_mp_shei[] = {""};
+static char PINYIN_mp_shen[] = {""};
+static char PINYIN_mp_sheng[] = {""};
+static char PINYIN_mp_shi[] = {""};
+static char PINYIN_mp_shou[] = {""};
+static char PINYIN_mp_shu[] = {""};
+static char PINYIN_mp_shua[] = {""};
+static char PINYIN_mp_shuai[] = {""};
+static char PINYIN_mp_shuan[] = {""};
+static char PINYIN_mp_shuang[] = {""};
+static char PINYIN_mp_shui[] = {""};
+static char PINYIN_mp_shun[] = {""};
+static char PINYIN_mp_shuo[] = {""};
+static char PINYIN_mp_si[] = {""};
+static char PINYIN_mp_song[] = {""};
+static char PINYIN_mp_sou[] = {""};
+static char PINYIN_mp_su[] = {""};
+static char PINYIN_mp_suan[] = {""};
+static char PINYIN_mp_sui[] = {""};
+static char PINYIN_mp_sun[] = {""};
+static char PINYIN_mp_suo[] = {""};
+static char PINYIN_mp_ta[] = {""};
+static char PINYIN_mp_tai[] = {""};
+static char PINYIN_mp_tan[] = {""};
+static char PINYIN_mp_tang[] = {""};
+static char PINYIN_mp_tao[] = {""};
+static char PINYIN_mp_te[] = {""};
+static char PINYIN_mp_teng[] = {""};
+static char PINYIN_mp_ti[] = {""};
+static char PINYIN_mp_tian[] = {""};
+static char PINYIN_mp_tiao[] = {""};
+static char PINYIN_mp_tie[] = {""};
+static char PINYIN_mp_ting[] = {""};
+static char PINYIN_mp_tong[] = {""};
+static char PINYIN_mp_tou[] = {""};
+static char PINYIN_mp_tu[] = {""};
+static char PINYIN_mp_tuan[] = {""};
+static char PINYIN_mp_tui[] = {""};
+static char PINYIN_mp_tun[] = {""};
+static char PINYIN_mp_tuo[] = {""};
+static char PINYIN_mp_wa[] = {""};
+static char PINYIN_mp_wai[] = {""};
+static char PINYIN_mp_wan[] = {""};
+static char PINYIN_mp_wang[] = {""};
+static char PINYIN_mp_wei[] = {""};
+static char PINYIN_mp_wen[] = {""};
+static char PINYIN_mp_weng[] = {""};
+static char PINYIN_mp_wo[] = {""};
+static char PINYIN_mp_wu[] = {""};
+static char PINYIN_mp_xi[] = {""};
+static char PINYIN_mp_xia[] = {""};
+static char PINYIN_mp_xian[] = {""};
+static char PINYIN_mp_xiang[] = {""};
+static char PINYIN_mp_xiao[] = {""};
+static char PINYIN_mp_xie[] = {""};
+static char PINYIN_mp_xin[] = {""};
+static char PINYIN_mp_xing[] = {""};
+static char PINYIN_mp_xiong[] = {""};
+static char PINYIN_mp_xiu[] = {""};
+static char PINYIN_mp_xu[] = {""};
+static char PINYIN_mp_xuan[] = {""};
+static char PINYIN_mp_xue[] = {""};
+static char PINYIN_mp_xun[] = {""};
+static char PINYIN_mp_ya[] = {""};
+static char PINYIN_mp_yan[] = {""};
+static char PINYIN_mp_yang[] = {""};
+static char PINYIN_mp_yao[] = {""};
+static char PINYIN_mp_ye[] = {""};
+static char PINYIN_mp_yi[] = {""};
+static char PINYIN_mp_yin[] = {""};
+static char PINYIN_mp_ying[] = {""};
+static char PINYIN_mp_yo[] = {""};
+static char PINYIN_mp_yong[] = {""};
+static char PINYIN_mp_you[] = {""};
+static char PINYIN_mp_yu[] = {""};
+static char PINYIN_mp_yuan[] = {""};
+static char PINYIN_mp_yue[] = {""};
+static char PINYIN_mp_yun[] = {""};
+static char PINYIN_mp_za[] = {""};
+static char PINYIN_mp_zai[] = {""};
+static char PINYIN_mp_zan[] = {""};
+static char PINYIN_mp_zang[] = {""};
+static char PINYIN_mp_zao[] = {""};
+static char PINYIN_mp_ze[] = {""};
+static char PINYIN_mp_zei[] = {""};
+static char PINYIN_mp_zen[] = {""};
+static char PINYIN_mp_zeng[] = {""};
+static char PINYIN_mp_zha[] = {""};
+static char PINYIN_mp_zhai[] = {""};
+static char PINYIN_mp_zhan[] = {""};
+static char PINYIN_mp_zhang[] = {""};
+static char PINYIN_mp_zhao[] = {""};
+static char PINYIN_mp_zhe[] = {""};
+static char PINYIN_mp_zhen[] = {""};
+static char PINYIN_mp_zheng[] = {""};
+static char PINYIN_mp_zhi[] = {""};
+static char PINYIN_mp_zhong[] = {""};
+static char PINYIN_mp_zhou[] = {""};
+static char PINYIN_mp_zhu[] = {""};
+static char PINYIN_mp_zhua[] = {""};
+static char PINYIN_mp_zhuai[] = {""};
+static char PINYIN_mp_zhuan[] = {""};
+static char PINYIN_mp_zhuang[] = {""};
+static char PINYIN_mp_zhui[] = {""};
+static char PINYIN_mp_zhun[] = {""};
+static char PINYIN_mp_zhuo[] = {""};
+static char PINYIN_mp_zi[] = {""};
+static char PINYIN_mp_zong[] = {""};
+static char PINYIN_mp_zou[] = {""};
+static char PINYIN_mp_zu[] = {""};
+static char PINYIN_mp_zuan[] = {""};
+static char PINYIN_mp_zui[] = {""};
+static char PINYIN_mp_zun[] = {""};
+static char PINYIN_mp_zuo[] = {""};
+#else
+/*Chinese Characters UTF-8*/
+static char PINYIN_mp_a[] = {""};
+static char PINYIN_mp_ai[] = {""};
+static char PINYIN_mp_an[] = {""};
+static char PINYIN_mp_ang[] = {""};
+static char PINYIN_mp_ao[] = {""};
+static char PINYIN_mp_ba[] = {""};
+static char PINYIN_mp_bai[] = {""};
+static char PINYIN_mp_ban[] = {""};
+static char PINYIN_mp_bang[] = {""};
+static char PINYIN_mp_bao[] = {""};
+static char PINYIN_mp_bei[] = {""};
+static char PINYIN_mp_ben[] = {""};
+static char PINYIN_mp_beng[] = {""};
+static char PINYIN_mp_bi[] = {""};
+static char PINYIN_mp_bian[] = {""};
+static char PINYIN_mp_biao[] = {""};
+static char PINYIN_mp_bie[] = {""};
+static char PINYIN_mp_bin[] = {""};
+static char PINYIN_mp_bing[] = {""};
+static char PINYIN_mp_bo[] = {""};
+static char PINYIN_mp_bu[] = {""};
+static char PINYIN_mp_ca[] = {""};
+static char PINYIN_mp_cai[] = {""};
+static char PINYIN_mp_can[] = {""};
+static char PINYIN_mp_cang[] = {""};
+static char PINYIN_mp_cao[] = {""};
+static char PINYIN_mp_ce[] = {""};
+static char PINYIN_mp_cen[] = {""};
+static char PINYIN_mp_ceng[] = {""};
+static char PINYIN_mp_cha[] = {""};
+static char PINYIN_mp_chai[] = {""};
+static char PINYIN_mp_chan[] = {""};
+static char PINYIN_mp_chang[] = {""};
+static char PINYIN_mp_chao[] = {""};
+static char PINYIN_mp_che[] = {""};
+static char PINYIN_mp_chen[] = {""};
+static char PINYIN_mp_cheng[] = {""};
+static char PINYIN_mp_chi[] = {""};
+static char PINYIN_mp_chong[] = {""};
+static char PINYIN_mp_chou[] = {""};
+static char PINYIN_mp_chu[] = {""};
+static char PINYIN_mp_chuai[] = {""};
+static char PINYIN_mp_chuan[] = {""};
+static char PINYIN_mp_chuang[] = {""};
+static char PINYIN_mp_chui[] = {""};
+static char PINYIN_mp_chun[] = {""};
+static char PINYIN_mp_chuo[] = {""};
+static char PINYIN_mp_ci[] = {""};
+static char PINYIN_mp_cong[] = {""};
+static char PINYIN_mp_cou[] = {""};
+static char PINYIN_mp_cu[] = {""};
+static char PINYIN_mp_cuan[] = {""};
+static char PINYIN_mp_cui[] = {""};
+static char PINYIN_mp_cun[] = {""};
+static char PINYIN_mp_cuo[] = {""};
+static char PINYIN_mp_da[] = {""};
+static char PINYIN_mp_dai[] = {""};
+static char PINYIN_mp_dan[] = {""};
+static char PINYIN_mp_dang[] = {""};
+static char PINYIN_mp_dao[] = {""};
+static char PINYIN_mp_de[] = {""};
+static char PINYIN_mp_dei[] = {""};
+static char PINYIN_mp_deng[] = {""};
+static char PINYIN_mp_di[] = {""};
+static char PINYIN_mp_dia[] = {""};
+static char PINYIN_mp_dian[] = {""};
+static char PINYIN_mp_diao[] = {""};
+static char PINYIN_mp_die[] = {""};
+static char PINYIN_mp_ding[] = {""};
+static char PINYIN_mp_diu[] = {""};
+static char PINYIN_mp_dong[] = {""};
+static char PINYIN_mp_dou[] = {""};
+static char PINYIN_mp_du[] = {""};
+static char PINYIN_mp_duan[] = {""};
+static char PINYIN_mp_dui[] = {""};
+static char PINYIN_mp_dun[] = {""};
+static char PINYIN_mp_duo[] = {""};
+static char PINYIN_mp_e[] = {""};
+static char PINYIN_mp_ei[] = {""};
+static char PINYIN_mp_en[] = {""};
+static char PINYIN_mp_er[] = {""};
+static char PINYIN_mp_fa[] = {""};
+static char PINYIN_mp_fan[] = {""};
+static char PINYIN_mp_fang[] = {""};
+static char PINYIN_mp_fei[] = {""};
+static char PINYIN_mp_fen[] = {""};
+static char PINYIN_mp_feng[] = {""};
+static char PINYIN_mp_fo[] = {""};
+static char PINYIN_mp_fou[] = {""};
+static char PINYIN_mp_fu[] = {""};
+static char PINYIN_mp_ga[] = {""};
+static char PINYIN_mp_gai[] = {""};
+static char PINYIN_mp_gan[] = {""};
+static char PINYIN_mp_gang[] = {""};
+static char PINYIN_mp_gao[] = {""};
+static char PINYIN_mp_ge[] = {""};
+static char PINYIN_mp_gei[] = {""};
+static char PINYIN_mp_gen[] = {""};
+static char PINYIN_mp_geng[] = {""};
+static char PINYIN_mp_gong[] = {""};
+static char PINYIN_mp_gou[] = {""};
+static char PINYIN_mp_gu[] = {""};
+static char PINYIN_mp_gua[] = {""};
+static char PINYIN_mp_guai[] = {""};
+static char PINYIN_mp_guan[] = {""};
+static char PINYIN_mp_guang[] = {""};
+static char PINYIN_mp_gui[] = {""};
+static char PINYIN_mp_gun[] = {""};
+static char PINYIN_mp_guo[] = {""};
+static char PINYIN_mp_ha[] = {""};
+static char PINYIN_mp_hai[] = {""};
+static char PINYIN_mp_han[] = {""};
+static char PINYIN_mp_hang[] = {""};
+static char PINYIN_mp_hao[] = {""};
+static char PINYIN_mp_he[] = {""};
+static char PINYIN_mp_hei[] = {""};
+static char PINYIN_mp_hen[] = {""};
+static char PINYIN_mp_heng[] = {""};
+static char PINYIN_mp_hong[] = {""};
+static char PINYIN_mp_hou[] = {""};
+static char PINYIN_mp_hu[] = {""};
+static char PINYIN_mp_hua[] = {""};
+static char PINYIN_mp_huai[] = {""};
+static char PINYIN_mp_huan[] = {""};
+static char PINYIN_mp_huang[] = {""};
+static char PINYIN_mp_hui[] = {""};
+static char PINYIN_mp_hun[] = {""};
+static char PINYIN_mp_huo[] = {""};
+static char PINYIN_mp_ji[] = {""};
+static char PINYIN_mp_jia[] = {""};
+static char PINYIN_mp_jian[] = {""};
+static char PINYIN_mp_jiang[] = {""};
+static char PINYIN_mp_jiao[] = {""};
+static char PINYIN_mp_jie[] = {""};
+static char PINYIN_mp_jin[] = {""};
+static char PINYIN_mp_jing[] = {""};
+static char PINYIN_mp_jiong[] = {""};
+static char PINYIN_mp_jiu[] = {""};
+static char PINYIN_mp_ju[] = {""};
+static char PINYIN_mp_juan[] = {""};
+static char PINYIN_mp_jue[] = {""};
+static char PINYIN_mp_jun[] = {""};
+static char PINYIN_mp_ka[] = {""};
+static char PINYIN_mp_kai[] = {""};
+static char PINYIN_mp_kan[] = {""};
+static char PINYIN_mp_kang[] = {""};
+static char PINYIN_mp_kao[] = {""};
+static char PINYIN_mp_ke[] = {""};
+static char PINYIN_mp_ken[] = {""};
+static char PINYIN_mp_keng[] = {""};
+static char PINYIN_mp_kong[] = {""};
+static char PINYIN_mp_kou[] = {""};
+static char PINYIN_mp_ku[] = {""};
+static char PINYIN_mp_kua[] = {""};
+static char PINYIN_mp_kuai[] = {""};
+static char PINYIN_mp_kuan[] = {""};
+static char PINYIN_mp_kuang[] = {""};
+static char PINYIN_mp_kui[] = {""};
+static char PINYIN_mp_kun[] = {""};
+static char PINYIN_mp_kuo[] = {""};
+static char PINYIN_mp_la[] = {""};
+static char PINYIN_mp_lai[] = {""};
+static char PINYIN_mp_lan[] = {""};
+static char PINYIN_mp_lang[] = {""};
+static char PINYIN_mp_lao[] = {""};
+static char PINYIN_mp_le[] = {""};
+static char PINYIN_mp_lei[] = {""};
+static char PINYIN_mp_leng[] = {""};
+static char PINYIN_mp_li[] = {""};
+static char PINYIN_mp_lia[] = {""};
+static char PINYIN_mp_lian[] = {""};
+static char PINYIN_mp_liang[] = {""};
+static char PINYIN_mp_liao[] = {""};
+static char PINYIN_mp_lie[] = {""};
+static char PINYIN_mp_lin[] = {""};
+static char PINYIN_mp_ling[] = {""};
+static char PINYIN_mp_liu[] = {""};
+static char PINYIN_mp_lo[] = {""};
+static char PINYIN_mp_long[] = {""};
+static char PINYIN_mp_lou[] = {""};
+static char PINYIN_mp_lu[] = {""};
+static char PINYIN_mp_luan[] = {""};
+static char PINYIN_mp_lun[] = {""};
+static char PINYIN_mp_luo[] = {""};
+static char PINYIN_mp_lv[] = {""};
+static char PINYIN_mp_lue[] = {""};
+static char PINYIN_mp_ma[] = {""};
+static char PINYIN_mp_mai[] = {""};
+static char PINYIN_mp_man[] = {""};
+static char PINYIN_mp_mang[] = {""};
+static char PINYIN_mp_mao[] = {""};
+static char PINYIN_mp_me[] = {""};
+static char PINYIN_mp_mei[] = {""};
+static char PINYIN_mp_men[] = {""};
+static char PINYIN_mp_meng[] = {""};
+static char PINYIN_mp_mi[] = {""};
+static char PINYIN_mp_mian[] = {""};
+static char PINYIN_mp_miao[] = {""};
+static char PINYIN_mp_mie[] = {""};
+static char PINYIN_mp_min[] = {""};
+static char PINYIN_mp_ming[] = {""};
+static char PINYIN_mp_miu[] = {""};
+static char PINYIN_mp_mo[] = {""};
+static char PINYIN_mp_mou[] = {""};
+static char PINYIN_mp_mu[] = {""};
+static char PINYIN_mp_na[] = {""};
+static char PINYIN_mp_nai[] = {""};
+static char PINYIN_mp_nan[] = {""};
+static char PINYIN_mp_nang[] = {""};
+static char PINYIN_mp_nao[] = {""};
+static char PINYIN_mp_ne[] = {""};
+static char PINYIN_mp_nei[] = {""};
+static char PINYIN_mp_nen[] = {""};
+static char PINYIN_mp_neng[] = {""};
+static char PINYIN_mp_ng[] = {""};
+static char PINYIN_mp_ni[] = {""};
+static char PINYIN_mp_nian[] = {""};
+static char PINYIN_mp_niang[] = {""};
+static char PINYIN_mp_niao[] = {""};
+static char PINYIN_mp_nie[] = {""};
+static char PINYIN_mp_nin[] = {""};
+static char PINYIN_mp_ning[] = {""};
+static char PINYIN_mp_niu[] = {""};
+static char PINYIN_mp_nong[] = {""};
+static char PINYIN_mp_nou[] = {""};
+static char PINYIN_mp_nu[] = {""};
+static char PINYIN_mp_nv[] = {""};
+static char PINYIN_mp_nue[] = {""};
+static char PINYIN_mp_nuan[] = {""};
+static char PINYIN_mp_nuo[] = {""};
+static char PINYIN_mp_o[] = {""};
+static char PINYIN_mp_ou[] = {""};
+static char PINYIN_mp_pa[] = {""};
+static char PINYIN_mp_pai[] = {""};
+static char PINYIN_mp_pan[] = {""};
+static char PINYIN_mp_pang[] = {""};
+static char PINYIN_mp_pao[] = {""};
+static char PINYIN_mp_pei[] = {""};
+static char PINYIN_mp_pen[] = {""};
+static char PINYIN_mp_peng[] = {""};
+static char PINYIN_mp_pi[] = {""};
+static char PINYIN_mp_pian[] = {""};
+static char PINYIN_mp_piao[] = {""};
+static char PINYIN_mp_pie[] = {""};
+static char PINYIN_mp_pin[] = {""};
+static char PINYIN_mp_ping[] = {""};
+static char PINYIN_mp_po[] = {""};
+static char PINYIN_mp_pou[] = {""};
+static char PINYIN_mp_pu[] = {""};
+static char PINYIN_mp_qi[] = {""};
+static char PINYIN_mp_qia[] = {""};
+static char PINYIN_mp_qian[] = {""};
+static char PINYIN_mp_qiang[] = {""};
+static char PINYIN_mp_qiao[] = {""};
+static char PINYIN_mp_qie[] = {""};
+static char PINYIN_mp_qin[] = {""};
+static char PINYIN_mp_qing[] = {""};
+static char PINYIN_mp_qiong[] = {""};
+static char PINYIN_mp_qiu[] = {""};
+static char PINYIN_mp_qu[] = {""};
+static char PINYIN_mp_quan[] = {""};
+static char PINYIN_mp_que[] = {""};
+static char PINYIN_mp_qui[] = {""};
+static char PINYIN_mp_qun[] = {""};
+static char PINYIN_mp_ran[] = {""};
+static char PINYIN_mp_rang[] = {""};
+static char PINYIN_mp_rao[] = {""};
+static char PINYIN_mp_re[] = {""};
+static char PINYIN_mp_ren[] = {""};
+static char PINYIN_mp_reng[] = {""};
+static char PINYIN_mp_ri[] = {""};
+static char PINYIN_mp_rong[] = {""};
+static char PINYIN_mp_rou[] = {""};
+static char PINYIN_mp_ru[] = {""};
+static char PINYIN_mp_ruan[] = {""};
+static char PINYIN_mp_rui[] = {""};
+static char PINYIN_mp_run[] = {""};
+static char PINYIN_mp_ruo[] = {""};
+static char PINYIN_mp_sa[] = {""};
+static char PINYIN_mp_sai[] = {""};
+static char PINYIN_mp_san[] = {""};
+static char PINYIN_mp_sang[] = {""};
+static char PINYIN_mp_sao[] = {""};
+static char PINYIN_mp_se[] = {""};
+static char PINYIN_mp_sen[] = {""};
+static char PINYIN_mp_seng[] = {""};
+static char PINYIN_mp_sha[] = {""};
+static char PINYIN_mp_shai[] = {""};
+static char PINYIN_mp_shan[] = {""};
+static char PINYIN_mp_shang[] = {""};
+static char PINYIN_mp_shao[] = {""};
+static char PINYIN_mp_she[] = {""};
+static char PINYIN_mp_shei[] = {""};
+static char PINYIN_mp_shen[] = {""};
+static char PINYIN_mp_sheng[] = {""};
+static char PINYIN_mp_shi[] = {""};
+static char PINYIN_mp_shou[] = {""};
+static char PINYIN_mp_shu[] = {""};
+static char PINYIN_mp_shua[] = {""};
+static char PINYIN_mp_shuai[] = {""};
+static char PINYIN_mp_shuan[] = {""};
+static char PINYIN_mp_shuang[] = {""};
+static char PINYIN_mp_shui[] = {""};
+static char PINYIN_mp_shun[] = {""};
+static char PINYIN_mp_shuo[] = {""};
+static char PINYIN_mp_si[] = {""};
+static char PINYIN_mp_song[] = {""};
+static char PINYIN_mp_sou[] = {""};
+static char PINYIN_mp_su[] = {""};
+static char PINYIN_mp_suan[] = {""};
+static char PINYIN_mp_sui[] = {""};
+static char PINYIN_mp_sun[] = {""};
+static char PINYIN_mp_suo[] = {""};
+static char PINYIN_mp_ta[] = {""};
+static char PINYIN_mp_tai[] = {""};
+static char PINYIN_mp_tan[] = {""};
+static char PINYIN_mp_tang[] = {""};
+static char PINYIN_mp_tao[] = {""};
+static char PINYIN_mp_te[] = {""};
+static char PINYIN_mp_teng[] = {""};
+static char PINYIN_mp_ti[] = {""};
+static char PINYIN_mp_tian[] = {""};
+static char PINYIN_mp_tiao[] = {""};
+static char PINYIN_mp_tie[] = {""};
+static char PINYIN_mp_ting[] = {""};
+static char PINYIN_mp_tong[] = {""};
+static char PINYIN_mp_tou[] = {""};
+static char PINYIN_mp_tu[] = {""};
+static char PINYIN_mp_tuan[] = {""};
+static char PINYIN_mp_tui[] = {""};
+static char PINYIN_mp_tun[] = {""};
+static char PINYIN_mp_tuo[] = {""};
+static char PINYIN_mp_wa[] = {""};
+static char PINYIN_mp_wai[] = {""};
+static char PINYIN_mp_wan[] = {""};
+static char PINYIN_mp_wang[] = {""};
+static char PINYIN_mp_wei[] = {""};
+static char PINYIN_mp_wen[] = {""};
+static char PINYIN_mp_weng[] = {""};
+static char PINYIN_mp_wo[] = {""};
+static char PINYIN_mp_wu[] = {""};
+static char PINYIN_mp_xi[] = {""};
+static char PINYIN_mp_xia[] = {""};
+static char PINYIN_mp_xian[] = {""};
+static char PINYIN_mp_xiang[] = {""};
+static char PINYIN_mp_xiao[] = {""};
+static char PINYIN_mp_xie[] = {""};
+static char PINYIN_mp_xin[] = {""};
+static char PINYIN_mp_xing[] = {""};
+static char PINYIN_mp_xiong[] = {""};
+static char PINYIN_mp_xiu[] = {""};
+static char PINYIN_mp_xu[] = {""};
+static char PINYIN_mp_xuan[] = {""};
+static char PINYIN_mp_xue[] = {""};
+static char PINYIN_mp_xun[] = {""};
+static char PINYIN_mp_ya[] = {""};
+static char PINYIN_mp_yan[] = {""};
+static char PINYIN_mp_yang[] = {""};
+static char PINYIN_mp_yao[] = {""};
+static char PINYIN_mp_ye[] = {""};
+static char PINYIN_mp_yi[] = {""};
+static char PINYIN_mp_yin[] = {""};
+static char PINYIN_mp_ying[] = {""};
+static char PINYIN_mp_yo[] = {""};
+static char PINYIN_mp_yong[] = {""};
+static char PINYIN_mp_you[] = {""};
+static char PINYIN_mp_yu[] = {""};
+static char PINYIN_mp_yuan[] = {""};
+static char PINYIN_mp_yue[] = {""};
+static char PINYIN_mp_yun[] = {""};
+static char PINYIN_mp_za[] = {""};
+static char PINYIN_mp_zai[] = {""};
+static char PINYIN_mp_zan[] = {""};
+static char PINYIN_mp_zang[] = {""};
+static char PINYIN_mp_zao[] = {""};
+static char PINYIN_mp_ze[] = {""};
+static char PINYIN_mp_zei[] = {""};
+static char PINYIN_mp_zen[] = {""};
+static char PINYIN_mp_zeng[] = {""};
+static char PINYIN_mp_zha[] = {""};
+static char PINYIN_mp_zhai[] = {""};
+static char PINYIN_mp_zhan[] = {""};
+static char PINYIN_mp_zhang[] = {""};
+static char PINYIN_mp_zhao[] = {""};
+static char PINYIN_mp_zhe[] = {""};
+static char PINYIN_mp_zhen[] = {""};
+static char PINYIN_mp_zheng[] = {""};
+static char PINYIN_mp_zhi[] = {""};
+static char PINYIN_mp_zhong[] = {""};
+static char PINYIN_mp_zhou[] = {""};
+static char PINYIN_mp_zhu[] = {""};
+static char PINYIN_mp_zhua[] = {""};
+static char PINYIN_mp_zhuai[] = {""};
+static char PINYIN_mp_zhuan[] = {""};
+static char PINYIN_mp_zhuang[] = {""};
+static char PINYIN_mp_zhui[] = {""};
+static char PINYIN_mp_zhun[] = {""};
+static char PINYIN_mp_zhuo[] = {""};
+static char PINYIN_mp_zi[] = {""};
+static char PINYIN_mp_zong[] = {""};
+static char PINYIN_mp_zou[] = {""};
+static char PINYIN_mp_zu[] = {""};
+static char PINYIN_mp_zuan[] = {""};
+static char PINYIN_mp_zui[] = {""};
+static char PINYIN_mp_zun[] = {""};
+static char PINYIN_mp_zuo[] = {""};
+#endif
+
+struct PINYIN_initials PINYIN_SUMMARY[] = {{"a", PINYIN_mp_a},
+    {"ai", PINYIN_mp_ai},
+    {"an", PINYIN_mp_an},
+    {"ang", PINYIN_mp_ang},
+    {"ao", PINYIN_mp_ao},
+    {"ba", PINYIN_mp_ba},
+    {"bai", PINYIN_mp_bai},
+    {"ban", PINYIN_mp_ban},
+    {"bang", PINYIN_mp_bang},
+    {"bao", PINYIN_mp_bao},
+    {"bei", PINYIN_mp_bei},
+    {"ben", PINYIN_mp_ben},
+    {"beng", PINYIN_mp_beng},
+    {"bi", PINYIN_mp_bi},
+    {"bian", PINYIN_mp_bian},
+    {"biao", PINYIN_mp_biao},
+    {"bie", PINYIN_mp_bie},
+    {"bin", PINYIN_mp_bin},
+    {"bing", PINYIN_mp_bing},
+    {"bo", PINYIN_mp_bo},
+    {"bu", PINYIN_mp_bu},
+    {"ca", PINYIN_mp_ca},
+    {"cai", PINYIN_mp_cai},
+    {"can", PINYIN_mp_can},
+    {"cang", PINYIN_mp_cang},
+    {"cao", PINYIN_mp_cao},
+    {"ce", PINYIN_mp_ce},
+    {"cen", PINYIN_mp_cen},
+    {"ceng", PINYIN_mp_ceng},
+    {"cha", PINYIN_mp_cha},
+    {"chai", PINYIN_mp_chai},
+    {"chan", PINYIN_mp_chan},
+    {"chang", PINYIN_mp_chang},
+    {"chao", PINYIN_mp_chao},
+    {"che", PINYIN_mp_che},
+    {"chen", PINYIN_mp_chen},
+    {"cheng", PINYIN_mp_cheng},
+    {"chi", PINYIN_mp_chi},
+    {"chong", PINYIN_mp_chong},
+    {"chou", PINYIN_mp_chou},
+    {"chu", PINYIN_mp_chu},
+    {"chuai", PINYIN_mp_chuai},
+    {"chuan", PINYIN_mp_chuan},
+    {"chuang", PINYIN_mp_chuang},
+    {"chui", PINYIN_mp_chui},
+    {"chun", PINYIN_mp_chun},
+    {"chuo", PINYIN_mp_chuo},
+    {"ci", PINYIN_mp_ci},
+    {"cong", PINYIN_mp_cong},
+    {"cou", PINYIN_mp_cou},
+    {"cu", PINYIN_mp_cu},
+    {"cuan", PINYIN_mp_cuan},
+    {"cui", PINYIN_mp_cui},
+    {"cun", PINYIN_mp_cun},
+    {"cuo", PINYIN_mp_cuo},
+    {"da", PINYIN_mp_da},
+    {"dai", PINYIN_mp_dai},
+    {"dan", PINYIN_mp_dan},
+    {"dang", PINYIN_mp_dang},
+    {"dao", PINYIN_mp_dao},
+    {"de", PINYIN_mp_de},
+    {"dei", PINYIN_mp_dei},
+    {"deng", PINYIN_mp_deng},
+    {"di", PINYIN_mp_di},
+    {"dia", PINYIN_mp_dia},
+    {"dian", PINYIN_mp_dian},
+    {"diao", PINYIN_mp_diao},
+    {"die", PINYIN_mp_die},
+    {"ding", PINYIN_mp_ding},
+    {"diu", PINYIN_mp_diu},
+    {"dong", PINYIN_mp_dong},
+    {"dou", PINYIN_mp_dou},
+    {"du", PINYIN_mp_du},
+    {"duan", PINYIN_mp_duan},
+    {"dui", PINYIN_mp_dui},
+    {"dun", PINYIN_mp_dun},
+    {"duo", PINYIN_mp_duo},
+    {"e", PINYIN_mp_e},
+    {"ei", PINYIN_mp_ei},
+    {"en", PINYIN_mp_en},
+    {"er", PINYIN_mp_er},
+    {"fa", PINYIN_mp_fa},
+    {"fan", PINYIN_mp_fan},
+    {"fang", PINYIN_mp_fang},
+    {"fei", PINYIN_mp_fei},
+    {"fen", PINYIN_mp_fen},
+    {"feng", PINYIN_mp_feng},
+    {"fo", PINYIN_mp_fo},
+    {"fou", PINYIN_mp_fou},
+    {"fu", PINYIN_mp_fu},
+    {"ga", PINYIN_mp_ga},
+    {"gai", PINYIN_mp_gai},
+    {"gan", PINYIN_mp_gan},
+    {"gang", PINYIN_mp_gang},
+    {"gao", PINYIN_mp_gao},
+    {"ge", PINYIN_mp_ge},
+    {"gei", PINYIN_mp_gei},
+    {"gen", PINYIN_mp_gen},
+    {"geng", PINYIN_mp_geng},
+    {"gong", PINYIN_mp_gong},
+    {"gou", PINYIN_mp_gou},
+    {"gu", PINYIN_mp_gu},
+    {"gua", PINYIN_mp_gua},
+    {"guai", PINYIN_mp_guai},
+    {"guan", PINYIN_mp_guan},
+    {"guang", PINYIN_mp_guang},
+    {"gui", PINYIN_mp_gui},
+    {"gun", PINYIN_mp_gun},
+    {"guo", PINYIN_mp_guo},
+    {"ha", PINYIN_mp_ha},
+    {"hai", PINYIN_mp_hai},
+    {"han", PINYIN_mp_han},
+    {"hang", PINYIN_mp_hang},
+    {"hao", PINYIN_mp_hao},
+    {"he", PINYIN_mp_he},
+    {"hei", PINYIN_mp_hei},
+    {"hen", PINYIN_mp_hen},
+    {"heng", PINYIN_mp_heng},
+    {"hong", PINYIN_mp_hong},
+    {"hou", PINYIN_mp_hou},
+    {"hu", PINYIN_mp_hu},
+    {"hua", PINYIN_mp_hua},
+    {"huai", PINYIN_mp_huai},
+    {"huan", PINYIN_mp_huan},
+    {"huang", PINYIN_mp_huang},
+    {"hui", PINYIN_mp_hui},
+    {"hun", PINYIN_mp_hun},
+    {"huo", PINYIN_mp_huo},
+    {"ji", PINYIN_mp_ji},
+    {"jia", PINYIN_mp_jia},
+    {"jian", PINYIN_mp_jian},
+    {"jiang", PINYIN_mp_jiang},
+    {"jiao", PINYIN_mp_jiao},
+    {"jie", PINYIN_mp_jie},
+    {"jin", PINYIN_mp_jin},
+    {"jing", PINYIN_mp_jing},
+    {"jiong", PINYIN_mp_jiong},
+    {"jiu", PINYIN_mp_jiu},
+    {"ju", PINYIN_mp_ju},
+    {"juan", PINYIN_mp_juan},
+    {"jue", PINYIN_mp_jue},
+    {"jun", PINYIN_mp_jun},
+    {"ka", PINYIN_mp_ka},
+    {"kai", PINYIN_mp_kai},
+    {"kan", PINYIN_mp_kan},
+    {"kang", PINYIN_mp_kang},
+    {"kao", PINYIN_mp_kao},
+    {"ke", PINYIN_mp_ke},
+    {"ken", PINYIN_mp_ken},
+    {"keng", PINYIN_mp_keng},
+    {"kong", PINYIN_mp_kong},
+    {"kou", PINYIN_mp_kou},
+    {"ku", PINYIN_mp_ku},
+    {"kua", PINYIN_mp_kua},
+    {"kuai", PINYIN_mp_kuai},
+    {"kuan", PINYIN_mp_kuan},
+    {"kuang", PINYIN_mp_kuang},
+    {"kui", PINYIN_mp_kui},
+    {"kun", PINYIN_mp_kun},
+    {"kuo", PINYIN_mp_kuo},
+    {"la", PINYIN_mp_la},
+    {"lai", PINYIN_mp_lai},
+    {"lan", PINYIN_mp_lan},
+    {"lang", PINYIN_mp_lang},
+    {"lao", PINYIN_mp_lao},
+    {"le", PINYIN_mp_le},
+    {"lei", PINYIN_mp_lei},
+    {"leng", PINYIN_mp_leng},
+    {"li", PINYIN_mp_li},
+    {"lia", PINYIN_mp_lia},
+    {"lian", PINYIN_mp_lian},
+    {"liang", PINYIN_mp_liang},
+    {"liao", PINYIN_mp_liao},
+    {"lie", PINYIN_mp_lie},
+    {"lin", PINYIN_mp_lin},
+    {"ling", PINYIN_mp_ling},
+    {"liu", PINYIN_mp_liu},
+    {"lo", PINYIN_mp_lo},
+    {"long", PINYIN_mp_long},
+    {"lou", PINYIN_mp_lou},
+    {"lu", PINYIN_mp_lu},
+    {"luan", PINYIN_mp_luan},
+    {"lue", PINYIN_mp_lue},
+    {"lun", PINYIN_mp_lun},
+    {"luo", PINYIN_mp_luo},
+    {"lv", PINYIN_mp_lv},
+    {"ma", PINYIN_mp_ma},
+    {"mai", PINYIN_mp_mai},
+    {"man", PINYIN_mp_man},
+    {"mang", PINYIN_mp_mang},
+    {"mao", PINYIN_mp_mao},
+    {"me", PINYIN_mp_me},
+    {"mei", PINYIN_mp_mei},
+    {"men", PINYIN_mp_men},
+    {"meng", PINYIN_mp_meng},
+    {"mi", PINYIN_mp_mi},
+    {"mian", PINYIN_mp_mian},
+    {"miao", PINYIN_mp_miao},
+    {"mie", PINYIN_mp_mie},
+    {"min", PINYIN_mp_min},
+    {"ming", PINYIN_mp_ming},
+    {"miu", PINYIN_mp_miu},
+    {"mo", PINYIN_mp_mo},
+    {"mou", PINYIN_mp_mou},
+    {"mu", PINYIN_mp_mu},
+    {"ma", PINYIN_mp_na},
+    {"nai", PINYIN_mp_nai},
+    {"nan", PINYIN_mp_nan},
+    {"nang", PINYIN_mp_nang},
+    {"nao", PINYIN_mp_nao},
+    {"ne", PINYIN_mp_ne},
+    {"nei", PINYIN_mp_nei},
+    {"nen", PINYIN_mp_nen},
+    {"neng", PINYIN_mp_neng},
+    {"ng", PINYIN_mp_ng},
+    {"ni", PINYIN_mp_ni},
+    {"nian", PINYIN_mp_nian},
+    {"niang", PINYIN_mp_niang},
+    {"niao", PINYIN_mp_niao},
+    {"nie", PINYIN_mp_nie},
+    {"nin", PINYIN_mp_nin},
+    {"ning", PINYIN_mp_ning},
+    {"niu", PINYIN_mp_niu},
+    {"nong", PINYIN_mp_nong},
+    {"nou", PINYIN_mp_nou},
+    {"nu", PINYIN_mp_nu},
+    {"nuan", PINYIN_mp_nuan},
+    {"nue", PINYIN_mp_nue},
+    {"nuo", PINYIN_mp_nuo},
+    {"nv", PINYIN_mp_nv},
+    {"o", PINYIN_mp_o},
+    {"ou", PINYIN_mp_ou},
+    {"pa", PINYIN_mp_pa},
+    {"pai", PINYIN_mp_pai},
+    {"pan", PINYIN_mp_pan},
+    {"pang", PINYIN_mp_pang},
+    {"pao", PINYIN_mp_pao},
+    {"pei", PINYIN_mp_pei},
+    {"pen", PINYIN_mp_pen},
+    {"peng", PINYIN_mp_peng},
+    {"pi", PINYIN_mp_pi},
+    {"pian", PINYIN_mp_pian},
+    {"piao", PINYIN_mp_piao},
+    {"pie", PINYIN_mp_pie},
+    {"pin", PINYIN_mp_pin},
+    {"ping", PINYIN_mp_ping},
+    {"po", PINYIN_mp_po},
+    {"pou", PINYIN_mp_pou},
+    {"pu", PINYIN_mp_pu},
+    {"qi", PINYIN_mp_qi},
+    {"qia", PINYIN_mp_qia},
+    {"qian", PINYIN_mp_qian},
+    {"qiang", PINYIN_mp_qiang},
+    {"qiao", PINYIN_mp_qiao},
+    {"qie", PINYIN_mp_qie},
+    {"qin", PINYIN_mp_qin},
+    {"qing", PINYIN_mp_qing},
+    {"qiong", PINYIN_mp_qiong},
+    {"qiu", PINYIN_mp_qiu},
+    {"qu", PINYIN_mp_qu},
+    {"quan", PINYIN_mp_quan},
+    {"que", PINYIN_mp_que},
+    {"qui", PINYIN_mp_qui},
+    {"qun", PINYIN_mp_qun},
+    {"ran", PINYIN_mp_ran},
+    {"rang", PINYIN_mp_rang},
+    {"rao", PINYIN_mp_rao},
+    {"re", PINYIN_mp_re},
+    {"ren", PINYIN_mp_ren},
+    {"reng", PINYIN_mp_reng},
+    {"ri", PINYIN_mp_ri},
+    {"rong", PINYIN_mp_rong},
+    {"rou", PINYIN_mp_rou},
+    {"ru", PINYIN_mp_ru},
+    {"ruan", PINYIN_mp_ruan},
+    {"rui", PINYIN_mp_rui},
+    {"run", PINYIN_mp_run},
+    {"ruo", PINYIN_mp_ruo},
+    {"sa", PINYIN_mp_sa},
+    {"sai", PINYIN_mp_sai},
+    {"san", PINYIN_mp_san},
+    {"sang", PINYIN_mp_sang},
+    {"sao", PINYIN_mp_sao},
+    {"se", PINYIN_mp_se},
+    {"sen", PINYIN_mp_sen},
+    {"seng", PINYIN_mp_seng},
+    {"sha", PINYIN_mp_sha},
+    {"shai", PINYIN_mp_shai},
+    {"shan", PINYIN_mp_shan},
+    {"shang ", PINYIN_mp_shang},
+    {"shao", PINYIN_mp_shao},
+    {"she", PINYIN_mp_she},
+    {"shei", PINYIN_mp_shei},
+    {"shen", PINYIN_mp_shen},
+    {"sheng", PINYIN_mp_sheng},
+    {"shi", PINYIN_mp_shi},
+    {"shou", PINYIN_mp_shou},
+    {"shu", PINYIN_mp_shu},
+    {"shua", PINYIN_mp_shua},
+    {"shuai", PINYIN_mp_shuai},
+    {"shuan", PINYIN_mp_shuan},
+    {"shuang", PINYIN_mp_shuang},
+    {"shui", PINYIN_mp_shui},
+    {"shun", PINYIN_mp_shun},
+    {"shuo", PINYIN_mp_shuo},
+    {"si", PINYIN_mp_si},
+    {"song", PINYIN_mp_song},
+    {"sou", PINYIN_mp_sou},
+    {"su", PINYIN_mp_su},
+    {"suan", PINYIN_mp_suan},
+    {"sui", PINYIN_mp_sui},
+    {"sun", PINYIN_mp_sun},
+    {"suo", PINYIN_mp_suo},
+    {"ta", PINYIN_mp_ta},
+    {"tai", PINYIN_mp_tai},
+    {"tan", PINYIN_mp_tan},
+    {"tang", PINYIN_mp_tang},
+    {"tao", PINYIN_mp_tao},
+    {"te", PINYIN_mp_te},
+    {"teng", PINYIN_mp_teng},
+    {"ti", PINYIN_mp_ti},
+    {"tian", PINYIN_mp_tian},
+    {"tiao", PINYIN_mp_tiao},
+    {"tie", PINYIN_mp_tie},
+    {"ting", PINYIN_mp_ting},
+    {"tong", PINYIN_mp_tong},
+    {"tou", PINYIN_mp_tou},
+    {"tu", PINYIN_mp_tu},
+    {"tuan", PINYIN_mp_tuan},
+    {"tui", PINYIN_mp_tui},
+    {"tun", PINYIN_mp_tun},
+    {"tuo", PINYIN_mp_tuo},
+    {"wa", PINYIN_mp_wa},
+    {"wai", PINYIN_mp_wai},
+    {"wan", PINYIN_mp_wan},
+    {"wang", PINYIN_mp_wang},
+    {"wei", PINYIN_mp_wei},
+    {"wen", PINYIN_mp_wen},
+    {"weng", PINYIN_mp_weng},
+    {"wo", PINYIN_mp_wo},
+    {"wu", PINYIN_mp_wu},
+    {"xi", PINYIN_mp_xi},
+    {"xia", PINYIN_mp_xia},
+    {"xian", PINYIN_mp_xian},
+    {"xiang", PINYIN_mp_xiang},
+    {"xiao", PINYIN_mp_xiao},
+    {"xie", PINYIN_mp_xie},
+    {"xin", PINYIN_mp_xin},
+    {"xing", PINYIN_mp_xing},
+    {"xiong", PINYIN_mp_xiong},
+    {"xiu", PINYIN_mp_xiu},
+    {"xu", PINYIN_mp_xu},
+    {"xuan", PINYIN_mp_xuan},
+    {"xue", PINYIN_mp_xue},
+    {"xun", PINYIN_mp_xun},
+    {"ya", PINYIN_mp_ya},
+    {"yan", PINYIN_mp_yan},
+    {"yang", PINYIN_mp_yang},
+    {"yao", PINYIN_mp_yao},
+    {"ye", PINYIN_mp_ye},
+    {"yi", PINYIN_mp_yi},
+    {"yin", PINYIN_mp_yin},
+    {"ying", PINYIN_mp_ying},
+    {"yo", PINYIN_mp_yo},
+    {"yong", PINYIN_mp_yong},
+    {"you", PINYIN_mp_you},
+    {"yu", PINYIN_mp_yu},
+    {"yuan", PINYIN_mp_yuan},
+    {"yue", PINYIN_mp_yue},
+    {"yun", PINYIN_mp_yun},
+    {"za", PINYIN_mp_za},
+    {"zai", PINYIN_mp_zai},
+    {"zan", PINYIN_mp_zan},
+    {"zang", PINYIN_mp_zang},
+    {"zao", PINYIN_mp_zao},
+    {"ze", PINYIN_mp_ze},
+    {"zei", PINYIN_mp_zei},
+    {"zen", PINYIN_mp_zen},
+    {"zeng", PINYIN_mp_zeng},
+    {"zha", PINYIN_mp_zha},
+    {"zhai", PINYIN_mp_zhai},
+    {"zhan", PINYIN_mp_zhan},
+    {"zhang", PINYIN_mp_zhang},
+    {"zhao", PINYIN_mp_zhao},
+    {"zhe", PINYIN_mp_zhe},
+    {"zhen", PINYIN_mp_zhen},
+    {"zheng", PINYIN_mp_zheng},
+    {"zhi", PINYIN_mp_zhi},
+    {"zhong", PINYIN_mp_zhong},
+    {"zhou", PINYIN_mp_zhou},
+    {"zhu", PINYIN_mp_zhu},
+    {"zhua", PINYIN_mp_zhua},
+    {"zhuai", PINYIN_mp_zhuai},
+    {"zhuan", PINYIN_mp_zhuan},
+    {"zhuang", PINYIN_mp_zhuang},
+    {"zhui", PINYIN_mp_zhui},
+    {"zhun", PINYIN_mp_zhun},
+    {"zhuo", PINYIN_mp_zhuo},
+    {"zi", PINYIN_mp_zi},
+    {"zong", PINYIN_mp_zong},
+    {"zou", PINYIN_mp_zou},
+    {"zu", PINYIN_mp_zu},
+    {"zuan", PINYIN_mp_zuan},
+    {"zui", PINYIN_mp_zui},
+    {"zun", PINYIN_mp_zun},
+    {"zuo", PINYIN_mp_zuo}
+};
+#endif
diff --git a/src/extra/widgets/keyboard/lv_zh_keyboard.c b/src/extra/widgets/keyboard/lv_zh_keyboard.c
new file mode 100644
index 000000000..16becab37
--- /dev/null
+++ b/src/extra/widgets/keyboard/lv_zh_keyboard.c
@@ -0,0 +1,751 @@
+
+/**
+ * @file lv_zh_keyboard.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "lv_zh_keyboard.h"
+#if LV_USE_ZH_KEYBOARD
+
+#include "../../../lvgl.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "chinese_library.h"
+
+/*********************
+ *      DEFINES
+ *********************/
+#define MY_CLASS &lv_zh_keyboard_class
+#define LV_KB_BTN(width) LV_BTNMATRIX_CTRL_POPOVER | width
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+/**********************
+ *  STATIC PROTOTYPES
+ **********************/
+static void lv_zh_keyboard_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_zh_keyboard_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_zh_keyboard_update_map(lv_obj_t * obj, uint8_t input_type);
+static void lv_zh_keyboard_update_ctrl_map(lv_obj_t * obj, uint8_t input_type);
+static void init_selection_box(lv_obj_t * parent);
+static void switch_input_type(uint8_t inputType);
+static void set_selection_box(uint8_t cand_show);
+static void show_chinese(char * text_uft8);
+
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+
+const lv_obj_class_t lv_zh_keyboard_class = {
+    .constructor_cb = lv_zh_keyboard_constructor,
+    .destructor_cb = lv_zh_keyboard_destructor,
+    .width_def = LV_PCT(100),
+    .height_def = LV_PCT(50),
+    .instance_size = sizeof(lv_zh_keyboard_t),
+    .editable = 1,
+    .base_class = &lv_btnmatrix_class
+};
+
+static const char * const default_kb_map_lc[] = {" ", "\n", " ", "\n",
+                                                 "1#", "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", LV_SYMBOL_BACKSPACE, "\n",
+                                                 "ABC", "a", "s", "d", "f", "g", "h", "j", "k", "l", LV_SYMBOL_NEW_LINE, "\n",
+                                                 "_", "-", "z", "x", "c", "v", "b", "n", "m", ".", ",", ":", "\n",
+                                                 LV_SYMBOL_KEYBOARD, "En/Zh", LV_SYMBOL_LEFT, " ", LV_SYMBOL_RIGHT, LV_SYMBOL_OK, ""
+                                                };
+
+static const lv_btnmatrix_ctrl_t default_kb_ctrl_lc_map[] = {
+    LV_BTNMATRIX_CTRL_HIDDEN, LV_BTNMATRIX_CTRL_HIDDEN,
+    LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 5, LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_BTNMATRIX_CTRL_CHECKED | 7,
+    LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 6, LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_BTNMATRIX_CTRL_CHECKED | 7,
+    LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1),
+    LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 2, LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 3, LV_BTNMATRIX_CTRL_CHECKED | 2, 6, LV_BTNMATRIX_CTRL_CHECKED | 2, LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 2
+};
+
+static const char * const default_kb_map_uc[] = {" ", "\n",
+                                                 " ", "\n",
+                                                 "1#", "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", LV_SYMBOL_BACKSPACE, "\n",
+                                                 "abc", "A", "S", "D", "F", "G", "H", "J", "K", "L", LV_SYMBOL_NEW_LINE, "\n",
+                                                 "_", "-", "Z", "X", "C", "V", "B", "N", "M", ".", ",", ":", "\n",
+                                                 LV_SYMBOL_KEYBOARD, "En/Zh", LV_SYMBOL_LEFT, " ", LV_SYMBOL_RIGHT, LV_SYMBOL_OK, ""
+                                                };
+
+static const lv_btnmatrix_ctrl_t default_kb_ctrl_uc_map[] = {
+    LV_BTNMATRIX_CTRL_HIDDEN, LV_BTNMATRIX_CTRL_HIDDEN,
+    LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 5, LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_BTNMATRIX_CTRL_CHECKED | 7,
+    LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 6, LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_BTNMATRIX_CTRL_CHECKED | 7,
+    LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1),
+    LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 2, LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 3, LV_BTNMATRIX_CTRL_CHECKED | 2, 6, LV_BTNMATRIX_CTRL_CHECKED | 2, LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 2
+};
+
+static const char * const default_kb_map_spec[] = {" ", "\n",
+                                                   " ", "\n",
+                                                   "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", LV_SYMBOL_BACKSPACE, "\n",
+                                                   "abc", "+", "-", "/", "*", "=", "%", "!", "?", "#", "<", ">", "\n",
+                                                   "\\", "@", "$", "(", ")", "{", "}", "[", "]", ";", "\"", "'", "\n",
+                                                   LV_SYMBOL_KEYBOARD, "En/Zh", LV_SYMBOL_LEFT, " ", LV_SYMBOL_RIGHT, LV_SYMBOL_OK, ""
+                                                  };
+
+static const lv_btnmatrix_ctrl_t default_kb_ctrl_spec_map[] = {
+    LV_BTNMATRIX_CTRL_HIDDEN, LV_BTNMATRIX_CTRL_HIDDEN,
+    LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | 2,
+    LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 2, LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1),
+    LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1),
+    LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 2, LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 3, LV_BTNMATRIX_CTRL_CHECKED | 2, 6, LV_BTNMATRIX_CTRL_CHECKED | 2, LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 2
+};
+
+static const char * const default_kb_map_num[] = {"1", "2", "3", LV_SYMBOL_KEYBOARD, "\n",
+                                                  "4", "5", "6", LV_SYMBOL_OK, "\n",
+                                                  "7", "8", "9", LV_SYMBOL_BACKSPACE, "\n",
+                                                  "+/-", "0", ".", LV_SYMBOL_LEFT, LV_SYMBOL_RIGHT, ""
+                                                 };
+
+static const lv_btnmatrix_ctrl_t default_kb_ctrl_num_map[] = {
+    1, 1, 1, LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 2,
+    1, 1, 1, LV_ZH_KEYBOARD_CTRL_BTN_FLAGS | 2,
+    1, 1, 1, 2,
+    1, 1, 1, 1, 1
+};
+
+static const char ** en_kb_map[9] = {
+    (const char **) & default_kb_map_lc[4],
+    (const char **) & default_kb_map_uc[4],
+    (const char **) & default_kb_map_spec[4],
+    (const char **)default_kb_map_num,
+    (const char **)default_kb_map_lc,
+    (const char **)default_kb_map_lc,
+    (const char **)default_kb_map_lc,
+    (const char **)default_kb_map_lc,
+    (const char **)NULL,
+};
+
+static const lv_btnmatrix_ctrl_t * en_kb_ctrl[9] = {
+    &default_kb_ctrl_lc_map[2],
+    &default_kb_ctrl_uc_map[2],
+    &default_kb_ctrl_spec_map[2],
+    default_kb_ctrl_num_map,
+    default_kb_ctrl_lc_map,
+    default_kb_ctrl_lc_map,
+    default_kb_ctrl_lc_map,
+    default_kb_ctrl_lc_map,
+    NULL,
+};
+
+static const char ** zh_kb_map[9] = {
+    (const char **)default_kb_map_lc,
+    (const char **)default_kb_map_uc,
+    (const char **)default_kb_map_spec,
+    (const char **)default_kb_map_num,
+    (const char **)default_kb_map_lc,
+    (const char **)default_kb_map_lc,
+    (const char **)default_kb_map_lc,
+    (const char **)default_kb_map_lc,
+    (const char **)NULL,
+};
+
+static const lv_btnmatrix_ctrl_t * zh_kb_ctrl[9] = {
+    default_kb_ctrl_lc_map,
+    default_kb_ctrl_uc_map,
+    default_kb_ctrl_spec_map,
+    default_kb_ctrl_num_map,
+    default_kb_ctrl_lc_map,
+    default_kb_ctrl_lc_map,
+    default_kb_ctrl_lc_map,
+    default_kb_ctrl_lc_map,
+    NULL,
+};
+
+typedef struct zh_input_function {
+    uint8_t input_type;
+    lv_font_t * custom_font;
+    lv_obj_t * obj_key_board;
+    lv_obj_t * obj_selection_box;
+    lv_obj_t * pinyin_label;
+    lv_obj_t * adjustable_box;
+    lv_obj_t * drop_btn_label;
+    uint8_t extend_flag;
+    char * matched_txt;
+} zh_input_struct;
+
+static zh_input_struct * zh_input_obj = NULL;
+
+/**********************
+ *      MACROS
+ **********************/
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+/**
+ * Create a Keyboard object
+ * @param parent pointer to an object, it will be the parent of the new keyboard
+ * @param zh_font pointer to an font object.
+ * @return pointer to the created keyboard
+ */
+lv_obj_t * lv_zh_keyboard_create(lv_obj_t * parent, const lv_font_t * zh_font)
+{
+    LV_LOG_INFO("begin");
+    if(zh_input_obj) {
+        return NULL;
+    }
+
+    else {
+        zh_input_obj = lv_mem_alloc(sizeof(zh_input_struct));
+        if(zh_input_obj == NULL)
+            return NULL;
+        lv_memset(zh_input_obj, 0, sizeof(zh_input_struct));
+        zh_input_obj->custom_font = (lv_font_t *)zh_font;
+    }
+    lv_obj_t * obj = lv_obj_class_create_obj(&lv_zh_keyboard_class, parent);
+    lv_obj_class_init_obj(obj);
+    lv_group_remove_obj(obj);
+    return obj;
+}
+
+/*=====================
+ * Setter functions
+ *====================*/
+
+/**
+ * Assign a Text Area to the Keyboard. The pressed characters will be put there.
+ * @param kb pointer to a Keyboard object
+ * @param ta pointer to a Text Area object to write there
+ */
+void lv_zh_keyboard_set_textarea(lv_obj_t * obj, lv_obj_t * ta)
+{
+    if(ta) {
+        LV_ASSERT_OBJ(ta, &lv_textarea_class);
+    }
+
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+
+    /*Hide the cursor of the old Text area if cursor management is enabled*/
+    if(keyboard->ta) {
+        lv_obj_clear_state(obj, LV_STATE_FOCUSED);
+    }
+
+    keyboard->ta = ta;
+
+    /*Show the cursor of the new Text area if cursor management is enabled*/
+    if(keyboard->ta) {
+        lv_obj_add_flag(obj, LV_STATE_FOCUSED);
+    }
+
+    if(keyboard->ta) {
+        if(zh_input_obj->input_type) {
+            lv_obj_clear_flag(zh_input_obj->obj_selection_box, LV_OBJ_FLAG_HIDDEN);
+        }
+        else {
+            lv_obj_add_flag(zh_input_obj->obj_selection_box, LV_OBJ_FLAG_HIDDEN);
+        }
+    }
+}
+
+/**
+ * Set a new a mode (text or number map)
+ * @param kb pointer to a Keyboard object
+ * @param mode the mode from 'lv_keyboard_mode_t'
+ */
+void lv_zh_keyboard_set_mode(lv_obj_t * obj, lv_zh_keyboard_mode_t mode)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+    if(keyboard->mode == mode)
+        return;
+
+    keyboard->mode = mode;
+    lv_zh_keyboard_update_map(obj, zh_input_obj->input_type);
+    switch_input_type(zh_input_obj->input_type);
+}
+
+/**
+ * Show the button title in a popover when pressed.
+ * @param kb pointer to a Keyboard object
+ * @param en whether "popovers" mode is enabled
+ */
+void lv_zh_keyboard_set_popovers(lv_obj_t * obj, bool en)
+{
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+
+    if(keyboard->popovers == en) {
+        return;
+    }
+
+    keyboard->popovers = en;
+    lv_zh_keyboard_update_ctrl_map(obj, zh_input_obj->input_type);
+}
+
+/**
+ * Set a new map for the keyboard
+ * @param kb pointer to a Keyboard object
+ * @param mode keyboard map to alter 'lv_keyboard_mode_t'
+ * @param map pointer to a string array to describe the map.
+ *            See 'lv_btnmatrix_set_map()' for more info.
+ */
+void lv_zh_keyboard_set_map(lv_obj_t * obj, lv_zh_keyboard_mode_t mode, const char * map[],
+                            const lv_btnmatrix_ctrl_t ctrl_map[])
+{
+    en_kb_map[mode] = map;
+    en_kb_ctrl[mode] = ctrl_map;
+    lv_zh_keyboard_update_map(obj, zh_input_obj->input_type);
+}
+
+/*=====================
+ * Getter functions
+ *====================*/
+
+/**
+ * Assign a Text Area to the Keyboard. The pressed characters will be put there.
+ * @param kb pointer to a Keyboard object
+ * @return pointer to the assigned Text Area object
+ */
+lv_obj_t * lv_zh_keyboard_get_textarea(const lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+    return keyboard->ta;
+}
+
+/**
+ * Set a new a mode (text or number map)
+ * @param kb pointer to a Keyboard object
+ * @return the current mode from 'lv_keyboard_mode_t'
+ */
+lv_zh_keyboard_mode_t lv_zh_keyboard_get_mode(const lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+    return keyboard->mode;
+}
+
+/**
+ * Tell whether "popovers" mode is enabled or not.
+ * @param kb pointer to a Keyboard object
+ * @return true: "popovers" mode is enabled; false: disabled
+ */
+bool lv_zh_btnmatrix_get_popovers(const lv_obj_t * obj)
+{
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+    return keyboard->popovers;
+}
+
+/*=====================
+ * Other functions
+ *====================*/
+/**
+ * Default keyboard event to add characters to the Text area and change the map.
+ * If a custom `event_cb` is added to the keyboard this function can be called from it to handle the
+ * button clicks
+ * @param kb pointer to a keyboard
+ * @param event the triggering event
+ */
+void lv_zh_keyboard_def_event_cb(lv_event_t * e)
+{
+    lv_obj_t * obj = lv_event_get_target(e);
+
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+    uint16_t btn_id = lv_btnmatrix_get_selected_btn(obj);
+    if(btn_id == LV_BTNMATRIX_BTN_NONE)
+        return;
+
+    const char * txt = lv_btnmatrix_get_btn_text(obj, lv_btnmatrix_get_selected_btn(obj));
+    if(txt == NULL)
+        return;
+
+    if(strcmp(txt, "abc") == 0) {
+        keyboard->mode = LV_ZH_KEYBOARD_MODE_TEXT_LOWER;
+        lv_zh_keyboard_update_map(obj, zh_input_obj->input_type);
+        return;
+    }
+    else if(strcmp(txt, "ABC") == 0) {
+        keyboard->mode = LV_ZH_KEYBOARD_MODE_TEXT_UPPER;
+        lv_zh_keyboard_update_map(obj, zh_input_obj->input_type);
+        return;
+    }
+    else if(strcmp(txt, "1#") == 0) {
+        keyboard->mode = LV_ZH_KEYBOARD_MODE_SPECIAL;
+        lv_zh_keyboard_update_map(obj, zh_input_obj->input_type);
+        return;
+    }
+    else if(strcmp(txt, LV_SYMBOL_CLOSE) == 0 || strcmp(txt, LV_SYMBOL_KEYBOARD) == 0) {
+        lv_res_t res = lv_event_send(obj, LV_EVENT_CANCEL, NULL);
+        if(res != LV_RES_OK)
+            return;
+
+        if(keyboard->ta) {
+            res = lv_event_send(keyboard->ta, LV_EVENT_CANCEL, NULL);
+            if(res != LV_RES_OK)
+                return;
+        }
+        return;
+    }
+    else if(strcmp(txt, LV_SYMBOL_OK) == 0) {
+        lv_res_t res = lv_event_send(obj, LV_EVENT_READY, NULL);
+        if(res != LV_RES_OK)
+            return;
+
+        if(keyboard->ta) {
+            res = lv_event_send(keyboard->ta, LV_EVENT_READY, NULL);
+            if(res != LV_RES_OK)
+                return;
+        }
+        return;
+    }
+    else if(strcmp(txt, "En/Zh") == 0) {
+        if(zh_input_obj->input_type == 0) {
+            zh_input_obj->input_type = 1;
+        }
+        else {
+            zh_input_obj->input_type = 0;
+        }
+        lv_zh_keyboard_update_map(obj, zh_input_obj->input_type);
+        switch_input_type(zh_input_obj->input_type);
+        return;
+    }
+
+    /*Add the characters to the text area if set*/
+    if(keyboard->ta == NULL)
+        return;
+
+    if(strcmp(txt, "Enter") == 0 || strcmp(txt, LV_SYMBOL_NEW_LINE) == 0) {
+        lv_textarea_add_char(keyboard->ta, '\n');
+        if(lv_textarea_get_one_line(keyboard->ta)) {
+            lv_res_t res = lv_event_send(keyboard->ta, LV_EVENT_READY, NULL);
+            if(res != LV_RES_OK)
+                return;
+        }
+    }
+    else if(strcmp(txt, LV_SYMBOL_LEFT) == 0) {
+        lv_textarea_cursor_left(keyboard->ta);
+    }
+    else if(strcmp(txt, LV_SYMBOL_RIGHT) == 0) {
+        lv_textarea_cursor_right(keyboard->ta);
+    }
+    else if(strcmp(txt, LV_SYMBOL_BACKSPACE) == 0) {
+        const char * pinyin_str;
+        pinyin_str = lv_textarea_get_text(zh_input_obj->pinyin_label);
+        if(pinyin_str[0] != 0) {
+            lv_textarea_del_char(zh_input_obj->pinyin_label);
+            const char * kb_input = lv_textarea_get_text(zh_input_obj->pinyin_label);
+            if(kb_input[0] != 0) {
+                zh_input_obj->matched_txt = get_chinese((char *)kb_input);
+                show_chinese(zh_input_obj->matched_txt);
+            }
+            return;
+        }
+        else {
+            lv_textarea_set_text(zh_input_obj->adjustable_box, "");
+        }
+        lv_textarea_del_char(keyboard->ta);
+    }
+    else if(strcmp(txt, "+/-") == 0) {
+        uint16_t cur = lv_textarea_get_cursor_pos(keyboard->ta);
+        const char * ta_txt = lv_textarea_get_text(keyboard->ta);
+        if(ta_txt[0] == '-') {
+            lv_textarea_set_cursor_pos(keyboard->ta, 1);
+            lv_textarea_del_char(keyboard->ta);
+            lv_textarea_add_char(keyboard->ta, '+');
+            lv_textarea_set_cursor_pos(keyboard->ta, cur);
+        }
+        else if(ta_txt[0] == '+') {
+            lv_textarea_set_cursor_pos(keyboard->ta, 1);
+            lv_textarea_del_char(keyboard->ta);
+            lv_textarea_add_char(keyboard->ta, '-');
+            lv_textarea_set_cursor_pos(keyboard->ta, cur);
+        }
+        else {
+            lv_textarea_set_cursor_pos(keyboard->ta, 0);
+            lv_textarea_add_char(keyboard->ta, '-');
+            lv_textarea_set_cursor_pos(keyboard->ta, cur + 1);
+        }
+    }
+    else {
+        if(keyboard->ta) {
+            if((zh_input_obj->input_type == 0) || (keyboard->mode == LV_ZH_KEYBOARD_MODE_SPECIAL)) {
+                lv_textarea_add_text(keyboard->ta, txt);
+            }
+            else if(zh_input_obj->input_type == 1) {
+                lv_textarea_add_text(zh_input_obj->pinyin_label, txt);
+                const char * kb_input = lv_textarea_get_text(zh_input_obj->pinyin_label);
+                if(kb_input[0] != 0) {
+                    zh_input_obj->matched_txt = get_chinese((char *)kb_input);
+                    show_chinese(zh_input_obj->matched_txt);
+                }
+            }
+        }
+    }
+}
+
+/**
+ * Find Chinese characters based on pinyin.
+ * @param input_string pointer to input pinyin.
+ * @return pointer to chinese characters.
+ */
+
+char * get_chinese(char * input_string)
+{
+    char i, cInputStrLength;
+    int pinyinLen, j;
+
+    cInputStrLength = strlen(input_string);
+    if(*input_string == '\0' || *input_string == 'i' || *input_string == 'u' || *input_string == 'v') {
+        return NULL;
+    }
+
+    for(i = 0; i < cInputStrLength; i++) {
+        *(input_string + i) |= 0x20;
+    }
+    pinyinLen = sizeof(PINYIN_SUMMARY) / sizeof(PINYIN_SUMMARY[0]);
+
+    for(j = 0; j < pinyinLen; j++) {
+        if(strcmp(input_string, PINYIN_SUMMARY[j].PINYIN) == 0) {
+            return PINYIN_SUMMARY[j].PINYIN_mp;
+        }
+    }
+    return NULL;
+}
+
+/**
+ * Tell whether "popovers" mode is enabled or not.
+ * @param kb pointer to a Keyboard object
+ * @return true: "popovers" mode is enabled; false: disabled
+ */
+
+static void switch_input_type(uint8_t inputType)
+{
+    zh_input_obj->matched_txt = NULL;
+    if(inputType == 0) {
+        set_selection_box(0);
+    }
+    else if(inputType == 1) {
+        set_selection_box(1);
+    }
+}
+
+static void font_click_event_cb(lv_event_t * e)
+{
+    lv_event_code_t code = lv_event_get_code(e);
+    lv_obj_t * ta = lv_event_get_target(e);
+
+    static uint16_t index = 0;
+    if(code == LV_EVENT_CLICKED) {
+        index = lv_textarea_get_cursor_pos(ta);
+        if(index % 2 == 0) {
+            index = index / 2;
+            if(zh_input_obj->matched_txt != NULL && index < strlen(zh_input_obj->matched_txt) / 3) {
+                char uft8_char[3] = {0};
+                lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)zh_input_obj->obj_key_board;
+                lv_memcpy(uft8_char, &zh_input_obj->matched_txt[index * 3], 3);
+                if(keyboard->ta != NULL) {
+                    lv_textarea_add_text(keyboard->ta, uft8_char);
+                    lv_textarea_set_text(zh_input_obj->adjustable_box, "");
+                    zh_input_obj->matched_txt = NULL;
+                    lv_textarea_set_text(zh_input_obj->pinyin_label, "");
+                }
+            }
+        }
+    }
+}
+
+static void expand_retract_click_cb(lv_event_t * e)
+{
+    zh_input_obj->extend_flag = (zh_input_obj->extend_flag == 1) ? 2 : 1;
+    set_selection_box(zh_input_obj->extend_flag);
+}
+
+static void set_selection_box(uint8_t cand_show)
+{
+    if(zh_input_obj->obj_selection_box != NULL) {
+        if(cand_show == 0) {
+            lv_obj_add_flag(zh_input_obj->obj_selection_box, LV_OBJ_FLAG_HIDDEN);
+        }
+        else if(cand_show == 1) {
+            lv_textarea_set_one_line(zh_input_obj->adjustable_box, true);
+            lv_obj_set_scroll_dir(zh_input_obj->adjustable_box, LV_DIR_HOR);
+            lv_obj_set_height(zh_input_obj->adjustable_box, 38);
+            lv_obj_set_height(zh_input_obj->obj_selection_box, 38);
+            lv_label_set_text(zh_input_obj->drop_btn_label, LV_SYMBOL_DOWN);
+            lv_obj_clear_flag(zh_input_obj->obj_selection_box, LV_OBJ_FLAG_HIDDEN);
+
+        }
+        else if(cand_show == 2) {
+            lv_textarea_set_one_line(zh_input_obj->adjustable_box, false);
+            lv_obj_set_scroll_dir(zh_input_obj->adjustable_box, LV_DIR_VER);
+            lv_obj_set_height(zh_input_obj->adjustable_box, lv_obj_get_height(zh_input_obj->obj_key_board));
+            lv_obj_set_height(zh_input_obj->obj_selection_box, lv_obj_get_height(zh_input_obj->obj_key_board));
+            lv_label_set_text(zh_input_obj->drop_btn_label, LV_SYMBOL_UP);
+            lv_obj_clear_flag(zh_input_obj->obj_selection_box, LV_OBJ_FLAG_HIDDEN);
+
+        }
+    }
+}
+
+static void show_chinese(char * chineseText)
+{
+    if(chineseText != NULL) {
+        size_t i = 0, j = 0;
+        char resultText[4 * 120 + 12] = {0};
+        for(i = 0; i < strlen(chineseText); i++) {
+            if(chineseText[i] == 0) break;
+            resultText[j++] = chineseText[i];
+            if((i + 1) % 3 == 0) {
+                resultText[j++] = ' ';
+            }
+        }
+        lv_textarea_set_text(zh_input_obj->adjustable_box, resultText);
+        lv_obj_scroll_to(zh_input_obj->adjustable_box, 0, 0, LV_ANIM_OFF);
+    }
+    else {
+        lv_textarea_set_text(zh_input_obj->adjustable_box, "");
+    }
+    return;
+}
+
+static void init_selection_box(lv_obj_t * parent)
+{
+    lv_obj_update_layout(parent);
+    lv_obj_set_style_bg_opa(parent, LV_OPA_COVER, 0);
+    zh_input_obj->obj_selection_box = lv_obj_create(parent);
+    lv_obj_align(zh_input_obj->obj_selection_box, LV_ALIGN_TOP_MID, 0, 0);
+    lv_obj_set_width(zh_input_obj->obj_selection_box, lv_obj_get_width(parent));
+    lv_obj_set_style_bg_color(zh_input_obj->obj_selection_box, lv_color_hex(0xf7f7f7), 0);
+    lv_obj_set_style_pad_all(zh_input_obj->obj_selection_box, 5, 0);
+    lv_obj_set_style_pad_top(zh_input_obj->obj_selection_box, 12, 0);
+    lv_obj_clear_flag(zh_input_obj->obj_selection_box, LV_OBJ_FLAG_SCROLLABLE);
+
+    zh_input_obj->pinyin_label = lv_textarea_create(zh_input_obj->obj_selection_box);
+    lv_obj_remove_style_all(zh_input_obj->pinyin_label);
+    lv_obj_align(zh_input_obj->pinyin_label, LV_ALIGN_TOP_LEFT, 0, -12);
+    lv_obj_clear_flag(zh_input_obj->pinyin_label, LV_OBJ_FLAG_CLICKABLE);
+    lv_obj_set_size(zh_input_obj->pinyin_label, lv_obj_get_width(zh_input_obj->obj_selection_box), 20);
+    lv_obj_set_style_text_font(zh_input_obj->pinyin_label, &lv_font_montserrat_12, 0);
+    lv_obj_set_style_text_color(zh_input_obj->pinyin_label, lv_color_hex(0x262626), 0);
+
+    lv_obj_t * ext_btn = lv_btn_create(zh_input_obj->obj_selection_box);
+    lv_obj_remove_style_all(ext_btn);
+    lv_obj_align(ext_btn, LV_ALIGN_TOP_RIGHT, 0, -5);
+    lv_obj_set_size(ext_btn, 30, 30);
+    lv_obj_add_event_cb(ext_btn, expand_retract_click_cb, LV_EVENT_CLICKED, NULL);
+    lv_obj_clear_flag(ext_btn, LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_FLOATING);
+    zh_input_obj->drop_btn_label = lv_label_create(ext_btn);
+    lv_obj_set_align(zh_input_obj->drop_btn_label, LV_ALIGN_CENTER);
+    lv_obj_set_style_text_font(zh_input_obj->drop_btn_label, LV_FONT_DEFAULT, 0);
+    lv_label_set_text(zh_input_obj->drop_btn_label, LV_SYMBOL_DOWN);
+    lv_obj_set_style_text_color(zh_input_obj->drop_btn_label, lv_color_hex(0x262626), 0);
+    lv_obj_update_layout(zh_input_obj->obj_selection_box);
+
+    int16_t width;
+    zh_input_obj->adjustable_box = lv_textarea_create(zh_input_obj->obj_selection_box);
+    width = lv_obj_get_width(zh_input_obj->obj_selection_box) - lv_obj_get_width(ext_btn) - 20;
+    lv_obj_remove_style_all(zh_input_obj->adjustable_box);
+    lv_obj_set_width(zh_input_obj->adjustable_box, width);
+    lv_obj_set_style_text_font(zh_input_obj->adjustable_box, zh_input_obj->custom_font, 0);
+    lv_obj_set_style_text_color(zh_input_obj->adjustable_box, lv_color_hex(0x262626), 0);
+    lv_obj_align(zh_input_obj->adjustable_box, LV_ALIGN_TOP_LEFT, 0, 0);
+    lv_obj_clear_flag(zh_input_obj->adjustable_box, LV_OBJ_FLAG_CLICK_FOCUSABLE);
+    lv_obj_add_event_cb(zh_input_obj->adjustable_box, font_click_event_cb, LV_EVENT_CLICKED, 0);
+
+    lv_obj_update_layout(parent);
+    switch_input_type(zh_input_obj->input_type);
+}
+
+/**********************
+ *   STATIC FUNCTIONS
+ **********************/
+
+static void lv_zh_keyboard_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    lv_obj_clear_flag(obj, LV_OBJ_FLAG_CLICK_FOCUSABLE);
+
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+    keyboard->ta = NULL;
+    keyboard->mode = LV_ZH_KEYBOARD_MODE_TEXT_LOWER;
+    keyboard->popovers = 0;
+
+    lv_disp_t * disp = lv_obj_get_disp(obj);
+    obj->class_p = &lv_zh_keyboard_class;
+    disp->theme->apply_cb(NULL, obj);
+    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLLABLE);
+
+    zh_input_obj->obj_key_board = obj;
+    zh_input_obj->input_type = 1;
+    zh_input_obj->extend_flag = 1;
+    lv_obj_align(obj, LV_ALIGN_BOTTOM_MID, 0, 0);
+    lv_obj_add_event_cb(obj, lv_zh_keyboard_def_event_cb, LV_EVENT_VALUE_CHANGED, NULL);
+    lv_obj_set_style_base_dir(obj, LV_BASE_DIR_LTR, 0);
+    lv_zh_keyboard_update_map(obj, 1);
+    lv_obj_update_layout(obj);
+    init_selection_box(obj);
+}
+
+/**
+ * Update the key and control map for the current mode
+ * @param obj pointer to a keyboard object
+ */
+static void lv_zh_keyboard_update_map(lv_obj_t * obj, uint8_t input_type)
+{
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+    if(input_type == 0) {
+        lv_btnmatrix_set_map(obj, en_kb_map[keyboard->mode]);
+        lv_btnmatrix_set_ctrl_map(obj, en_kb_ctrl[keyboard->mode]);
+    }
+    else {
+        lv_btnmatrix_set_map(obj, zh_kb_map[keyboard->mode]);
+        lv_btnmatrix_set_ctrl_map(obj, zh_kb_ctrl[keyboard->mode]);
+    }
+}
+
+/**
+ * Update the control map for the current mode
+ * @param obj pointer to a keyboard object
+ */
+static void lv_zh_keyboard_update_ctrl_map(lv_obj_t * obj, uint8_t input_type)
+{
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+
+    if(keyboard->popovers) {
+        /*Apply the current control map (already includes LV_BTNMATRIX_CTRL_POPOVER flags)*/
+        if(input_type == 0) {
+            lv_btnmatrix_set_ctrl_map(obj, en_kb_ctrl[keyboard->mode]);
+        }
+        else {
+            lv_btnmatrix_set_ctrl_map(obj, zh_kb_ctrl[keyboard->mode]);
+        }
+    }
+    else {
+        /*Make a copy of the current control map*/
+        lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;
+        lv_btnmatrix_ctrl_t * ctrl_map = lv_mem_alloc(btnm->btn_cnt * sizeof(lv_btnmatrix_ctrl_t));
+        lv_memcpy(ctrl_map, en_kb_ctrl[keyboard->mode], sizeof(lv_btnmatrix_ctrl_t) * btnm->btn_cnt);
+
+        /*Remove all LV_BTNMATRIX_CTRL_POPOVER flags*/
+        for(uint16_t i = 0; i < btnm->btn_cnt; i++) {
+            ctrl_map[i] &= (~LV_BTNMATRIX_CTRL_POPOVER);
+        }
+
+        /*Apply new control map and clean up*/
+        lv_btnmatrix_set_ctrl_map(obj, ctrl_map);
+        lv_mem_free(ctrl_map);
+    }
+}
+
+static void lv_zh_keyboard_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    lv_obj_clear_flag(obj, LV_OBJ_FLAG_CLICK_FOCUSABLE);
+    lv_zh_keyboard_t * keyboard = (lv_zh_keyboard_t *)obj;
+    keyboard->ta = NULL;
+    /* when the screen deleted will set the zh_input_obj value to NULL*/
+    zh_input_obj = NULL;
+}
+
+#endif /*LV_USE_ZH_KEYBOARD*/
diff --git a/src/extra/widgets/keyboard/lv_zh_keyboard.h b/src/extra/widgets/keyboard/lv_zh_keyboard.h
new file mode 100644
index 000000000..1de0b5b82
--- /dev/null
+++ b/src/extra/widgets/keyboard/lv_zh_keyboard.h
@@ -0,0 +1,190 @@
+/**
+ * @file lv_zh_keyboard.h
+ *
+ */
+
+#ifndef LV_ZH_KEYBOARD_H
+#define LV_ZH_KEYBOARD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "../../../widgets/lv_btnmatrix.h"
+
+#if LV_USE_ZH_KEYBOARD
+/*Testing of dependencies*/
+#if LV_USE_BTNMATRIX == 0
+#error "lv_kb: lv_btnm is required. Enable it in lv_conf.h (LV_USE_BTNMATRIX  1) "
+#endif
+
+#if LV_USE_TEXTAREA == 0
+#error "lv_kb: lv_ta is required. Enable it in lv_conf.h (LV_USE_TEXTAREA  1) "
+#endif
+
+/*********************
+ *      DEFINES
+ *********************/
+#define LV_ZH_KEYBOARD_CTRL_BTN_FLAGS (LV_BTNMATRIX_CTRL_NO_REPEAT | LV_BTNMATRIX_CTRL_CLICK_TRIG | LV_BTNMATRIX_CTRL_CHECKED)
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+/** Current keyboard mode.*/
+enum {
+    LV_ZH_KEYBOARD_MODE_TEXT_LOWER,
+    LV_ZH_KEYBOARD_MODE_TEXT_UPPER,
+    LV_ZH_KEYBOARD_MODE_SPECIAL,
+    LV_ZH_KEYBOARD_MODE_NUMBER,
+    LV_ZH_KEYBOARD_MODE_USER_1,
+    LV_ZH_KEYBOARD_MODE_USER_2,
+    LV_ZH_KEYBOARD_MODE_USER_3,
+    LV_ZH_KEYBOARD_MODE_USER_4,
+};
+typedef uint8_t lv_zh_keyboard_mode_t;
+
+/*Data of keyboard*/
+typedef struct {
+    lv_btnmatrix_t btnm;
+    lv_obj_t * ta;              /*Pointer to the assigned text area*/
+    lv_zh_keyboard_mode_t mode;    /*Key map type*/
+    uint8_t popovers : 1;       /*Show button titles in popovers on press*/
+} lv_zh_keyboard_t;
+
+extern const lv_obj_class_t lv_zh_keyboard_class;
+
+/**********************
+ * GLOBAL PROTOTYPES
+ **********************/
+
+/**
+ * Create a Keyboard object
+ * @param parent pointer to an object, it will be the parent of the new keyboard
+ * @param zh_font pointer to an font object.
+ * @return pointer to the created keyboard
+ */
+lv_obj_t * lv_zh_keyboard_create(lv_obj_t * parent, const lv_font_t * zh_font);
+
+/*=====================
+ * Setter functions
+ *====================*/
+
+/**
+ * Assign a Text Area to the Keyboard. The pressed characters will be put there.
+ * @param kb pointer to a Keyboard object
+ * @param ta pointer to a Text Area object to write there
+ */
+void lv_zh_keyboard_set_textarea(lv_obj_t * kb, lv_obj_t * ta);
+
+/**
+ * Set a new a mode (text or number map)
+ * @param kb pointer to a Keyboard object
+ * @param mode the mode from 'lv_keyboard_mode_t'
+ */
+void lv_zh_keyboard_set_mode(lv_obj_t * kb, lv_zh_keyboard_mode_t mode);
+
+/**
+ * Show the button title in a popover when pressed.
+ * @param kb pointer to a Keyboard object
+ * @param en whether "popovers" mode is enabled
+ */
+void lv_zh_keyboard_set_popovers(lv_obj_t * kb, bool en);
+
+/**
+ * Set a new map for the keyboard
+ * @param kb pointer to a Keyboard object
+ * @param mode keyboard map to alter 'lv_keyboard_mode_t'
+ * @param map pointer to a string array to describe the map.
+ *            See 'lv_btnmatrix_set_map()' for more info.
+ */
+void lv_zh_keyboard_set_map(lv_obj_t * kb, lv_zh_keyboard_mode_t mode, const char * map[],
+                            const lv_btnmatrix_ctrl_t ctrl_map[]);
+
+/*=====================
+ * Getter functions
+ *====================*/
+
+/**
+ * Assign a Text Area to the Keyboard. The pressed characters will be put there.
+ * @param kb pointer to a Keyboard object
+ * @return pointer to the assigned Text Area object
+ */
+lv_obj_t * lv_zh_keyboard_get_textarea(const lv_obj_t * kb);
+
+/**
+ * Set a new a mode (text or number map)
+ * @param kb pointer to a Keyboard object
+ * @return the current mode from 'lv_keyboard_mode_t'
+ */
+lv_zh_keyboard_mode_t lv_zh_keyboard_get_mode(const lv_obj_t * kb);
+
+/**
+ * Tell whether "popovers" mode is enabled or not.
+ * @param kb pointer to a Keyboard object
+ * @return true: "popovers" mode is enabled; false: disabled
+ */
+bool lv_zh_btnmatrix_get_popovers(const lv_obj_t * obj);
+
+/**
+ * Get the current map of a keyboard
+ * @param kb pointer to a keyboard object
+ * @return the current map
+ */
+static inline const char ** lv_zh_keyboard_get_map_array(const lv_obj_t * kb)
+{
+    return lv_btnmatrix_get_map(kb);
+}
+
+/**
+ * Get the index of the lastly "activated" button by the user (pressed, released, focused etc)
+ * Useful in the `event_cb` to get the text of the button, check if hidden etc.
+ * @param obj       pointer to button matrix object
+ * @return          index of the last released button (LV_BTNMATRIX_BTN_NONE: if unset)
+ */
+static inline uint16_t lv_zh_keyboard_get_selected_btn(const lv_obj_t * obj)
+{
+    return lv_btnmatrix_get_selected_btn(obj);
+}
+
+/**
+ * Get the button's text
+ * @param obj       pointer to button matrix object
+ * @param btn_id    the index a button not counting new line characters.
+ * @return          text of btn_index` button
+ */
+static inline const char * lv_zh_keyboard_get_btn_text(const lv_obj_t * obj, uint16_t btn_id)
+{
+    return lv_btnmatrix_get_btn_text(obj, btn_id);
+}
+
+
+/*=====================
+ * Other functions
+ *====================*/
+
+/**
+ * Default keyboard event to add characters to the Text area and change the map.
+ * If a custom `event_cb` is added to the keyboard this function can be called from it to handle the
+ * button clicks
+ * @param kb pointer to a keyboard
+ * @param event the triggering event
+ */
+void lv_zh_keyboard_def_event_cb(lv_event_t * e);
+
+char * get_chinese(char * input_string);
+
+/**********************
+ *      MACROS
+ **********************/
+
+#endif  /*LV_USE_KEYBOARD*/
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*LV_KEYBOARD_H*/
diff --git a/src/extra/widgets/lv_widgets.h b/src/extra/widgets/lv_widgets.h
index 114181022..f2ee4d8ee 100644
--- a/src/extra/widgets/lv_widgets.h
+++ b/src/extra/widgets/lv_widgets.h
@@ -17,21 +17,28 @@ extern "C" {
 #include "calendar/lv_calendar.h"
 #include "calendar/lv_calendar_header_arrow.h"
 #include "calendar/lv_calendar_header_dropdown.h"
+#include "carousel/lv_carousel.h"
 #include "chart/lv_chart.h"
 #include "keyboard/lv_keyboard.h"
+#include "keyboard/lv_zh_keyboard.h"
 #include "list/lv_list.h"
 #include "menu/lv_menu.h"
 #include "msgbox/lv_msgbox.h"
 #include "meter/lv_meter.h"
+#include "analogclock/lv_analogclock.h"
+#include "radiobtn/lv_radiobtn.h"
 #include "spinbox/lv_spinbox.h"
 #include "spinner/lv_spinner.h"
 #include "tabview/lv_tabview.h"
+#include "textprogress/lv_textprogress.h"
 #include "tileview/lv_tileview.h"
 #include "win/lv_win.h"
 #include "colorwheel/lv_colorwheel.h"
 #include "led/lv_led.h"
 #include "imgbtn/lv_imgbtn.h"
 #include "span/lv_span.h"
+#include "dclock/lv_dclock.h"
+#include "video/lv_video.h"
 
 /*********************
  *      DEFINES
diff --git a/src/extra/widgets/radiobtn/lv_radiobtn.c b/src/extra/widgets/radiobtn/lv_radiobtn.c
new file mode 100644
index 000000000..0ade7d967
--- /dev/null
+++ b/src/extra/widgets/radiobtn/lv_radiobtn.c
@@ -0,0 +1,385 @@
+/**
+ * @file lv_radiobtn.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "lv_radiobtn.h"
+
+#if LV_USE_RADIOBTN != 0
+
+#include "../../../misc/lv_assert.h"
+#include "../../../core/lv_group.h"
+#include "../../../draw/lv_draw.h"
+#include "../../../misc/lv_txt_ap.h"
+
+/*********************
+ *      DEFINES
+ *********************/
+#define MY_CLASS &lv_radiobtn_class
+#define ITEM_CLASS &lv_radiobtn_item_class
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+/**********************
+ *  STATIC PROTOTYPES
+ **********************/
+static void lv_radiobtn_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_radiobtn_event(const lv_obj_class_t * class_p, lv_event_t * e);
+static void lv_radiobtn_item_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_radiobtn_item_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_radiobtn_item_event(const lv_obj_class_t * class_p, lv_event_t * e);
+static void lv_radiobtn_item_draw(lv_event_t * e);
+
+
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+const lv_obj_class_t lv_radiobtn_class = {
+    .constructor_cb = lv_radiobtn_constructor,
+    .event_cb = lv_radiobtn_event,
+    .instance_size = sizeof(lv_radiobtn_t),
+    .width_def = (LV_DPI_DEF * 3) / 4,
+    .height_def = (LV_DPI_DEF * 3) / 4,
+    .base_class = &lv_obj_class
+};
+
+const lv_obj_class_t lv_radiobtn_item_class = {
+    .constructor_cb = lv_radiobtn_item_constructor,
+    .destructor_cb = lv_radiobtn_item_destructor,
+    .event_cb = lv_radiobtn_item_event,
+    .width_def = LV_SIZE_CONTENT,
+    .height_def = LV_SIZE_CONTENT,
+    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,
+    .instance_size = sizeof(lv_radiobtn_item_t),
+    .base_class = &lv_obj_class
+};
+
+
+
+/**********************
+ *      MACROS
+ **********************/
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+lv_obj_t * lv_radiobtn_create(lv_obj_t * parent)
+{
+    LV_LOG_INFO("begin");
+    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);
+    lv_obj_class_init_obj(obj);
+
+    return obj;
+}
+
+lv_obj_t * lv_radiobtn_create_item(lv_obj_t * parent)
+{
+    LV_LOG_INFO("begin");
+    lv_obj_t * obj = lv_obj_class_create_obj(ITEM_CLASS, parent);
+    lv_obj_class_init_obj(obj);
+
+    return obj;
+}
+
+lv_obj_t * lv_radiobtn_add_item(lv_obj_t * parent, const char * txt)
+{
+    LV_LOG_INFO("begin");
+    lv_obj_t * obj = lv_radiobtn_create_item(parent);
+    lv_obj_class_init_obj(obj);
+    lv_obj_add_flag(obj, LV_OBJ_FLAG_EVENT_BUBBLE);
+    lv_obj_set_size(obj, LV_PCT(100), LV_SIZE_CONTENT);
+    if(txt) {
+        lv_radiobtn_set_item_text(obj, txt);
+    }
+
+    return obj;
+}
+
+/*=====================
+ * Setter functions
+ *====================*/
+
+void lv_radiobtn_set_item_text(lv_obj_t * obj, const char * txt)
+{
+    LV_LOG_INFO("begin");
+    lv_radiobtn_item_t * rb = (lv_radiobtn_item_t *)obj;
+#if LV_USE_ARABIC_PERSIAN_CHARS
+    size_t len = _lv_txt_ap_calc_bytes_cnt(txt);
+#else
+    size_t len = strlen(txt);
+#endif
+
+    if(!rb->static_txt) rb->txt = lv_mem_realloc(rb->txt, len + 1);
+    else  rb->txt = lv_mem_alloc(len + 1);
+#if LV_USE_ARABIC_PERSIAN_CHARS
+    _lv_txt_ap_proc(txt, rb->txt);
+#else
+    if(rb->txt != NULL) strncpy(rb->txt, txt, len + 1);
+#endif
+
+    rb->static_txt = 0;
+
+    lv_obj_refresh_self_size(obj);
+    lv_obj_invalidate(obj);
+}
+
+void lv_radiobtn_set_item_text_static(lv_obj_t * obj, const char * txt)
+{
+    lv_radiobtn_item_t * rb = (lv_radiobtn_item_t *)obj;
+
+    if(!rb->static_txt) lv_mem_free(rb->txt);
+
+    rb->txt = (char *)txt;
+    rb->static_txt = 1;
+
+    lv_obj_refresh_self_size(obj);
+    lv_obj_invalidate(obj);
+}
+
+/*=====================
+ * Getter functions
+ *====================*/
+
+lv_obj_t * lv_radiobtn_get_item(lv_obj_t * radiobtn, uint32_t index)
+{
+    LV_LOG_INFO("begin");
+    lv_obj_t * item = lv_obj_get_child(radiobtn, index);
+    return item;
+}
+
+const char * lv_radiobtn_get_item_text(lv_obj_t * radiobtn, lv_obj_t * obj)
+{
+    LV_UNUSED(radiobtn);
+
+    lv_radiobtn_item_t * rb = (lv_radiobtn_item_t *)obj;
+    return rb->txt;
+}
+
+uint32_t lv_radiobtn_get_item_num(lv_obj_t * radiobtn)
+{
+    uint32_t num = lv_obj_get_child_cnt(radiobtn);
+    return num;
+}
+
+/**********************
+ *   STATIC FUNCTIONS
+ **********************/
+static void lv_radiobtn_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    LV_TRACE_OBJ_CREATE("begin");
+
+    lv_radiobtn_t * rb = (lv_radiobtn_t *)obj;
+    rb->active_index = 0;
+    rb->checked_txt = "";
+    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN);
+
+    LV_TRACE_OBJ_CREATE("finished");
+}
+
+static void lv_radiobtn_item_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    LV_TRACE_OBJ_CREATE("begin");
+
+    lv_radiobtn_item_t * btn = (lv_radiobtn_item_t *)obj;
+
+    btn->txt = "radio";
+    btn->static_txt = 1;
+    lv_obj_add_flag(obj, LV_OBJ_FLAG_CLICKABLE);
+    lv_obj_add_flag(obj, LV_OBJ_FLAG_CHECKABLE);
+    lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
+
+    LV_TRACE_OBJ_CREATE("finished");
+}
+
+static void lv_radiobtn_item_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    LV_TRACE_OBJ_CREATE("begin");
+
+    lv_radiobtn_item_t * btn = (lv_radiobtn_item_t *)obj;
+    if(!btn->static_txt) {
+        lv_mem_free(btn->txt);
+        btn->txt = NULL;
+    }
+    LV_TRACE_OBJ_CREATE("finished");
+}
+
+static void lv_radiobtn_item_event(const lv_obj_class_t * class_p, lv_event_t * e)
+{
+    LV_UNUSED(class_p);
+
+    lv_res_t res;
+    /*Call the ancestor's event handler*/
+    res = lv_obj_event_base(ITEM_CLASS, e);
+    if(res != LV_RES_OK) return;
+
+    lv_event_code_t code = lv_event_get_code(e);
+    lv_obj_t * obj = lv_event_get_target(e);
+
+    if(code == LV_EVENT_GET_SELF_SIZE) {
+        lv_point_t * p = lv_event_get_param(e);
+        lv_radiobtn_item_t * btn = (lv_radiobtn_item_t *)obj;
+
+        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);
+        lv_coord_t font_h = lv_font_get_line_height(font);
+        lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);
+        lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);
+
+        lv_point_t txt_size;
+        lv_txt_get_size(&txt_size, btn->txt, font, letter_space, line_space, LV_COORD_MAX, LV_TEXT_FLAG_NONE);
+
+        lv_coord_t bg_colp = lv_obj_get_style_pad_column(obj, LV_PART_MAIN);
+        lv_coord_t marker_leftp = lv_obj_get_style_pad_left(obj, LV_PART_INDICATOR);
+        lv_coord_t marker_rightp = lv_obj_get_style_pad_right(obj, LV_PART_INDICATOR);
+        lv_coord_t marker_topp = lv_obj_get_style_pad_top(obj, LV_PART_INDICATOR);
+        lv_coord_t marker_bottomp = lv_obj_get_style_pad_bottom(obj, LV_PART_INDICATOR);
+        lv_point_t marker_size;
+        marker_size.x = font_h + marker_leftp + marker_rightp;
+        marker_size.y = font_h + marker_topp + marker_bottomp;
+
+        p->x = marker_size.x + txt_size.x + bg_colp;
+        p->y = LV_MAX(marker_size.y, txt_size.y);
+    }
+    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {
+        lv_coord_t * s = lv_event_get_param(e);
+        lv_coord_t m = lv_obj_calculate_ext_draw_size(obj, LV_PART_INDICATOR);
+        *s = LV_MAX(*s, m);
+    }
+    else if(code == LV_EVENT_DRAW_MAIN) {
+        lv_radiobtn_item_draw(e);
+    }
+}
+
+static void lv_radiobtn_item_draw(lv_event_t * e)
+{
+    lv_obj_t * obj = lv_event_get_target(e);
+    lv_radiobtn_item_t * btn = (lv_radiobtn_item_t *)obj;
+
+    lv_draw_ctx_t * draw_ctx = lv_event_get_draw_ctx(e);
+    if(draw_ctx == NULL) return;
+    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);
+    lv_coord_t font_h = lv_font_get_line_height(font);
+
+    lv_coord_t bg_border = lv_obj_get_style_border_width(obj, LV_PART_MAIN);
+    lv_coord_t bg_topp = lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + bg_border;
+    lv_coord_t bg_leftp = lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + bg_border;
+    lv_coord_t bg_colp = lv_obj_get_style_pad_column(obj, LV_PART_MAIN);
+
+    lv_coord_t marker_leftp = lv_obj_get_style_pad_left(obj, LV_PART_INDICATOR);
+    lv_coord_t marker_rightp = lv_obj_get_style_pad_right(obj, LV_PART_INDICATOR);
+    lv_coord_t marker_topp = lv_obj_get_style_pad_top(obj, LV_PART_INDICATOR);
+    lv_coord_t marker_bottomp = lv_obj_get_style_pad_bottom(obj, LV_PART_INDICATOR);
+
+    lv_coord_t transf_w = lv_obj_get_style_transform_width(obj, LV_PART_INDICATOR);
+    lv_coord_t transf_h = lv_obj_get_style_transform_height(obj, LV_PART_INDICATOR);
+
+    lv_draw_rect_dsc_t indic_dsc;
+    lv_draw_rect_dsc_init(&indic_dsc);
+    lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &indic_dsc);
+    lv_area_t marker_area;
+    marker_area.x1 = obj->coords.x1 + bg_leftp;
+    marker_area.x2 = marker_area.x1 + font_h + marker_leftp + marker_rightp - 1;
+    marker_area.y1 = obj->coords.y1 + bg_topp;
+    marker_area.y2 = marker_area.y1 + font_h + marker_topp + marker_bottomp - 1;
+
+    lv_area_t marker_area_transf;
+    lv_area_copy(&marker_area_transf, &marker_area);
+    marker_area_transf.x1 -= transf_w;
+    marker_area_transf.x2 += transf_w;
+    marker_area_transf.y1 -= transf_h;
+    marker_area_transf.y2 += transf_h;
+
+    lv_obj_draw_part_dsc_t part_draw_dsc;
+    lv_obj_draw_dsc_init(&part_draw_dsc, draw_ctx);
+    part_draw_dsc.rect_dsc = &indic_dsc;
+    part_draw_dsc.class_p = ITEM_CLASS;
+    part_draw_dsc.type = LV_RADIOBTN_DRAW_PART_BOX;
+    part_draw_dsc.draw_area = &marker_area_transf;
+    part_draw_dsc.part = LV_PART_INDICATOR;
+
+    lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);
+    lv_draw_rect(draw_ctx, &indic_dsc, &marker_area_transf);
+    lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);
+
+    /**draw inner box*/
+    lv_draw_rect_dsc_t indic_inner_dsc;
+    lv_draw_rect_dsc_init(&indic_inner_dsc);
+    lv_obj_init_draw_rect_dsc(obj, LV_PART_CUSTOM_FIRST, &indic_inner_dsc);
+
+    lv_area_t marker_inner_area_transf;
+    lv_area_copy(&marker_inner_area_transf, &marker_area_transf);
+    int16_t dist = ((int16_t)(marker_inner_area_transf.x2 - marker_inner_area_transf.x1) / 4);
+    marker_inner_area_transf.x1 += dist;
+    marker_inner_area_transf.x2 -= dist;
+    marker_inner_area_transf.y1 += dist;
+    marker_inner_area_transf.y2 -= dist;
+
+    part_draw_dsc.rect_dsc = &indic_inner_dsc;
+    part_draw_dsc.class_p = ITEM_CLASS;
+    part_draw_dsc.type = LV_RADIOBTN_DRAW_PART_BOX_INNER;
+    part_draw_dsc.draw_area = &marker_inner_area_transf;
+    part_draw_dsc.part = LV_PART_CUSTOM_FIRST;
+
+    lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);
+    lv_draw_rect(draw_ctx, &indic_inner_dsc, &marker_inner_area_transf);
+    lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);
+
+    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);
+    lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);
+
+    lv_point_t txt_size;
+    lv_txt_get_size(&txt_size, btn->txt, font, letter_space, line_space, LV_COORD_MAX, LV_TEXT_FLAG_NONE);
+
+    lv_draw_label_dsc_t txt_dsc;
+    lv_draw_label_dsc_init(&txt_dsc);
+    lv_obj_init_draw_label_dsc(obj, LV_PART_MAIN, &txt_dsc);
+
+    lv_coord_t y_ofs = (lv_area_get_height(&marker_area) - font_h) / 2;
+    lv_area_t txt_area;
+    txt_area.x1 = marker_area.x2 + bg_colp;
+    txt_area.x2 = txt_area.x1 + txt_size.x;
+    txt_area.y1 = obj->coords.y1 + bg_topp + y_ofs;
+    txt_area.y2 = txt_area.y1 + txt_size.y;
+
+    lv_draw_label(draw_ctx, &txt_dsc, &txt_area, btn->txt, NULL);
+}
+
+static void lv_radiobtn_event(const lv_obj_class_t * class_p, lv_event_t * e)
+{
+    LV_UNUSED(class_p);
+
+    lv_res_t res;
+    /*Call the ancestor's event handler*/
+    res = lv_obj_event_base(MY_CLASS, e);
+    if(res != LV_RES_OK) return;
+
+    lv_event_code_t code = lv_event_get_code(e);
+    lv_obj_t * obj = lv_event_get_current_target(e);
+    lv_obj_t * act_btn = lv_event_get_target(e);
+    if(code == LV_EVENT_CLICKED) {
+        lv_radiobtn_t * rb = (lv_radiobtn_t *)obj;
+        uint16_t active_id = rb->active_index;
+        lv_obj_t * old_btn = lv_radiobtn_get_item(obj, active_id);
+
+        if(act_btn == obj || old_btn == NULL) return;
+
+        lv_obj_clear_state(old_btn, LV_STATE_CHECKED);
+        lv_obj_add_state(act_btn, LV_STATE_CHECKED);
+
+        rb->active_index = lv_obj_get_index(act_btn);
+        rb->checked_txt = (char *)lv_radiobtn_get_item_text(obj, act_btn);
+
+        LV_LOG_USER("Selected radio buttons: %d ", (int)rb->active_index);
+    }
+
+}
+
+#endif /*LV_USE_RADIOBTN*/
diff --git a/src/extra/widgets/radiobtn/lv_radiobtn.h b/src/extra/widgets/radiobtn/lv_radiobtn.h
new file mode 100644
index 000000000..791612c04
--- /dev/null
+++ b/src/extra/widgets/radiobtn/lv_radiobtn.h
@@ -0,0 +1,137 @@
+/**
+ * @file lv_radiobtn.h
+ *
+ */
+
+#ifndef LV_RADIOBTN_H
+#define LV_RADIOBTN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "../../../core/lv_obj.h"
+#include "../../layouts/flex/lv_flex.h"
+#include "../../../lv_conf_internal.h"
+
+#if LV_USE_RADIOBTN
+
+/*********************
+ *      DEFINES
+ *********************/
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+typedef struct {
+    lv_obj_t obj;
+    char * checked_txt;
+    uint32_t active_index;
+} lv_radiobtn_t;
+
+typedef struct {
+    lv_obj_t obj;
+    char * txt;
+    uint32_t static_txt : 1;
+} lv_radiobtn_item_t;
+
+extern const lv_obj_class_t lv_radiobtn_class;
+extern const lv_obj_class_t lv_radiobtn_item_class;
+
+/**
+ * `type` field in `lv_obj_draw_part_dsc_t` if `class_p = lv_radiobtn_item_class`
+ * Used in `LV_EVENT_DRAW_PART_BEGIN` and `LV_EVENT_DRAW_PART_END`
+ */
+typedef enum {
+    LV_RADIOBTN_DRAW_PART_BOX,    /**< The tick box*/
+    LV_RADIOBTN_DRAW_PART_BOX_INNER, /**< The inner box of tich box*/
+} lv_radiobtn_draw_part_type_t;
+
+
+/**********************
+ * GLOBAL PROTOTYPES
+ **********************/
+
+/**
+ * Create a radio button object
+ * @param parent    pointer to an object, it will be the parent of radio button
+ * @return          pointer to the created radio button object
+ */
+lv_obj_t * lv_radiobtn_create(lv_obj_t * parent);
+
+/**
+ * Create a radiobtn item object like check box
+ * @param parent    pointer to an object, it will be the parent of the new button
+ * @return          pointer to the created radiobtn item
+ */
+lv_obj_t * lv_radiobtn_create_item(lv_obj_t * parent);
+
+/**
+ * Add new radiobtn item into radio button with text
+ * @param radiobtn  pointer to an object, it will be the parent of new radiobtn item
+ * @param txt       the text of new radiobtn item
+ * @return          pointer to created new radiobtn item
+ */
+lv_obj_t * lv_radiobtn_add_item(lv_obj_t * radiobtn, const char * txt);
+
+/*=====================
+ * Setter functions
+ *====================*/
+
+/**
+ * Set new text of a radiobtn item
+ * @param obj       pointer to an object, it is a radiobtn item to set text
+ * @param txt       the new text that you want to set for radiobtn item
+ * @return          pointer to chenged radiobtn item
+ */
+void lv_radiobtn_set_item_text(lv_obj_t * obj, const char * txt);
+
+/**
+ * Set the text of a radiobtn item. `txt` must not be deallocated during the life
+ * of this radiobtn.
+ * @param obj       pointer to an object, it is a radiobtn item to set static text
+ * @param txt       the static text of the radiobtn item.
+ */
+void lv_radiobtn_set_item_text_static(lv_obj_t * obj, const char * txt);
+
+/*=====================
+ * Getter functions
+ *====================*/
+
+/**
+ * Get radiobtn item from radio bytton by index
+ * @param radiobtn  pointer to an object, it's parent of the wanted radiobtn item
+ * @param index     the index of radiobtn item in radio button
+ * @return          pointer to the wanted radiobtn item
+ */
+lv_obj_t * lv_radiobtn_get_item(lv_obj_t * radiobtn, uint32_t index);
+
+/**
+ * Get the text of a radiobtn item
+ * @param radiobtn  pointer to an object, it is the parent of radiobtn item
+ * @param obj      pointer to an object, it is a radiobtn item to get text
+ * @return          the text of specified radiobtn item
+ */
+const char * lv_radiobtn_get_item_text(lv_obj_t * radiobtn, lv_obj_t * obj);
+
+/**
+ * Get the item number of a radio button
+ * @param radiobtn  pointer to an object, it is a radio button to get item number
+ * @return          the item number of radio button
+ */
+uint32_t lv_radiobtn_get_item_num(lv_obj_t * radiobtn);
+
+/**********************
+ *      MACROS
+ **********************/
+
+#endif /*LV_USE_RADIOBTN*/
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*LV_RADIOBTN_H*/
diff --git a/src/extra/widgets/textprogress/lv_textprogress.c b/src/extra/widgets/textprogress/lv_textprogress.c
new file mode 100644
index 000000000..c117ee7e6
--- /dev/null
+++ b/src/extra/widgets/textprogress/lv_textprogress.c
@@ -0,0 +1,140 @@
+/**
+ * @file lv_textprogress.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "lv_textprogress.h"
+
+#if LV_USE_TEXTPROGRESS != 0
+
+/*********************
+ *      DEFINES
+ *********************/
+#define MY_CLASS &lv_textprogress_class
+
+#define MULDIV(a,b,c) (a*b)/c
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+/**********************
+ *  STATIC PROTOTYPES
+ **********************/
+static void lv_textprogress_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+
+const lv_obj_class_t lv_textprogress_class = {
+    .constructor_cb = lv_textprogress_constructor,
+    .instance_size = sizeof(lv_textprogress_t),
+    .base_class = &lv_label_class
+};
+
+/**********************
+ *      MACROS
+ **********************/
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+lv_obj_t * lv_textprogress_create(lv_obj_t * parent)
+{
+    LV_LOG_INFO("begin");
+    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);
+    lv_obj_class_init_obj(obj);
+
+    return obj;
+}
+
+/*=====================
+ * Setter functions
+ *====================*/
+
+void lv_textprogress_set_range_value(lv_obj_t * obj, uint32_t min, uint32_t max, uint32_t steps, uint32_t steps_min)
+{
+    lv_textprogress_t * tp = (lv_textprogress_t *)obj;
+
+    tp->range_min = min;
+    tp->range_max = max;
+    tp->range_steps_min = steps_min;
+    if(steps == 0) {
+        tp->range_steps = max - min;
+    }
+    else {
+        tp->range_steps = steps;
+    }
+}
+
+void lv_textprogress_set_decimal(lv_obj_t * obj, uint32_t decimal)
+{
+    lv_textprogress_t * tp = (lv_textprogress_t *)obj;
+
+    tp->decimals = (((2) < (decimal)) ? (2) : (decimal));
+}
+
+void lv_textprogress_set_value(lv_obj_t * obj, uint32_t value)
+{
+    lv_textprogress_t * tp = (lv_textprogress_t *)obj;
+
+    value = (((value) > (tp->range_min)) ? (value) : (tp->range_min));
+    value = (((value) < (tp->range_max)) ? (value) : (tp->range_max));
+    tp->value = value;
+    int range[3] = {1, 10, 100};
+    uint32_t progress;
+    char textbuffer[8];
+    progress = lv_textprogress_get_progress(obj, 100 * range[tp->decimals]);
+    if(tp->decimals > 0) {
+        lv_snprintf(textbuffer, sizeof(textbuffer), "%d.%0*d%%", (progress / range[tp->decimals]), tp->decimals,
+                    (progress % range[tp->decimals]));
+    }
+    else {
+        lv_snprintf(textbuffer, sizeof(textbuffer), "%d%%", progress);
+    }
+    lv_label_set_text(obj, textbuffer);
+}
+/*=====================
+ * Getter functions
+ *====================*/
+
+uint32_t lv_textprogress_get_progress(lv_obj_t * obj, uint32_t range)
+{
+    lv_textprogress_t * tp = (lv_textprogress_t *)obj;
+
+    int32_t step, prog;
+    step = tp->range_steps_min + MULDIV(((tp->value) - (tp->range_min)), ((tp->range_steps) - (tp->range_steps_min)),
+                                        ((tp->range_max) - (tp->range_min)));
+    prog = MULDIV(step, range, tp->range_steps);
+    return prog;
+}
+
+/**********************
+ *   STATIC FUNCTIONS
+ **********************/
+
+static void lv_textprogress_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    LV_TRACE_OBJ_CREATE("begin");
+
+    lv_textprogress_t * tp = (lv_textprogress_t *)obj;
+    tp->range_min = 0;
+    tp->range_max = 100;
+    tp->range_steps = 80;
+    tp->range_steps_min = 0;
+    tp->value = 0;
+    tp->decimals = 2;
+
+    lv_label_set_text(obj, "0.00%");
+
+    LV_TRACE_OBJ_CREATE("finished");
+}
+
+
+#endif /*LV_USE_TEXTPROGRESS*/
\ No newline at end of file
diff --git a/src/extra/widgets/textprogress/lv_textprogress.h b/src/extra/widgets/textprogress/lv_textprogress.h
new file mode 100644
index 000000000..9251620b0
--- /dev/null
+++ b/src/extra/widgets/textprogress/lv_textprogress.h
@@ -0,0 +1,100 @@
+/**
+ * @file lv_textprogress.h
+ *
+ */
+
+#ifndef LV_TEXTPROGRESS_H
+#define LV_TEXTPROGRESS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "../../../lvgl.h"
+
+#if LV_USE_TEXTPROGRESS
+/*********************
+ *      DEFINES
+ *********************/
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+typedef struct {
+    lv_label_t text;
+    uint32_t range_max;
+    uint32_t range_min;
+    uint32_t value;
+    uint32_t range_steps;
+    uint32_t range_steps_min;
+    uint16_t decimals;
+} lv_textprogress_t;
+
+extern const lv_obj_class_t lv_textprogress_class;
+
+/**********************
+ * GLOBAL PROTOTYPES
+ **********************/
+
+/**
+ * Create a textprogress object
+ * @param parent    pointer to an object, it will be the parent of textprogress
+ * @return          pointer to the created textprogress object
+ */
+lv_obj_t * lv_textprogress_create(lv_obj_t * parent);
+
+/*=====================
+ * Setter functions
+ *====================*/
+
+/**
+ * Set range value of a textprogress object
+ * @param obj       pointer to an object, it is a textprogress to set range value
+ * @param min       the minimum value of range
+ * @param max       the maximum value of range
+ * @param steps     the number of steps from min to max range
+ * @param steps_min the minimum steps of textprogress
+ * @return          pointer to chenged textprogress
+ */
+void lv_textprogress_set_range_value(lv_obj_t * obj, uint32_t min, uint32_t max, uint32_t steps, uint32_t steps_min);
+
+/**
+ * Set decimal place of a textprogress object
+ * @param obj       pointer to an object, it is a textprogress to set decimal place
+ * @param decimal   the decimal place of the textprogress
+ * @return          pointer to chenged textprogress
+ */
+void lv_textprogress_set_decimal(lv_obj_t * obj, uint32_t decimal);
+
+/**
+ * Set current value of a textprogress object
+ * @param obj       pointer to an object, it is a textprogress to set current value
+ * @param value     the value want to set for the textprogress
+ * @return          pointer to chenged textprogress
+ */
+void lv_textprogress_set_value(lv_obj_t * obj, uint32_t value);
+
+
+/*=====================
+ * Getter functions
+ *====================*/
+
+/**
+ * Get each step's progress of a textprogress object
+ * @param radiobtn  pointer to a textprogress object
+ * @param range     the range of textprogress object
+ * @return          the progresss number of textprogress
+ */
+uint32_t lv_textprogress_get_progress(lv_obj_t * obj, uint32_t range);
+
+
+#endif /*LV_USE_TEXTPROGRESS*/
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*LV_TEXTPROGRESS_H*/
\ No newline at end of file
diff --git a/src/extra/widgets/video/lv_video.c b/src/extra/widgets/video/lv_video.c
new file mode 100644
index 000000000..5288d5429
--- /dev/null
+++ b/src/extra/widgets/video/lv_video.c
@@ -0,0 +1,602 @@
+/**
+ * @file lv_video.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+
+#include "lv_video.h"
+
+#if LV_USE_VIDEO != 0
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+// for run on target function.
+#if !LV_USE_GUIDER_SIMULATOR
+    #include "FreeRTOS.h"
+    #include "task.h"
+    #include "sdcard.h"
+    #include "h264_dec.h"
+    #include "fsl_common.h"
+    #include "fsl_debug_console.h"
+    #include "fsl_pxp.h"
+    #include "fsl_cache.h"
+#else
+    #include "decoder.h"
+    #include <unistd.h>
+#endif
+
+/*********************
+ *      DEFINES
+ *********************/
+#define MY_CLASS &lv_video_class
+#define LV_COLOR_SIZE 16
+#ifndef DEMO_FILE_BUF_SIZE
+    #define DEMO_FILE_BUF_SIZE (16 * 1024)
+#endif
+#ifndef DEMO_DECODE_BUF_SIZE
+    #define DEMO_DECODE_BUF_SIZE (64 * 1024)
+#endif
+
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+/**********************
+ *  STATIC PROTOTYPES
+ **********************/
+
+static int16_t video_width = 0;
+static int16_t video_height = 0;
+static void lv_video_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+static void lv_video_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);
+
+#if !LV_USE_GUIDER_SIMULATOR
+/* PXP Usage */
+
+static void PXP_DisplayFrame(uint16_t width,
+                             uint16_t height,
+                             const uint8_t * Y,
+                             const uint8_t * U,
+                             const uint8_t * V,
+                             uint32_t Y_Stride,
+                             uint32_t UV_Stride,
+                             lv_obj_t * obj);
+#else
+static void yuv420pToRgb565(int oriWidth,
+                            int oriHeight,
+                            int width, int height,
+                            uint8_t * py, uint8_t * pu, uint8_t * pv,
+                            unsigned short * dst);
+static void CPU_DisplayFrame(SBufferInfo sDstBufInfo, unsigned char ** dst, lv_obj_t * obj);
+#endif
+/**********************
+ *  STATIC VARIABLES
+ **********************/
+const lv_obj_class_t lv_video_class = {
+    .base_class = &lv_img_class,
+    .instance_size = sizeof(lv_video_t),
+    .width_def = LV_SIZE_CONTENT,
+    .height_def = LV_SIZE_CONTENT,
+    .constructor_cb = lv_video_constructor,
+    .destructor_cb = lv_video_destructor,
+};
+
+#if !LV_USE_GUIDER_SIMULATOR
+    /* PXP Usage */
+    static pxp_output_buffer_config_t s_pxpOutputBufferConfig;
+    static pxp_ps_buffer_config_t s_pxpPsBufferConfig;
+    static volatile uint8_t s_lcdActiveFbIdx = 0;
+    static int buffer_byte_per_pixel = 2;
+    static uint8_t * s_lcdBuffer[2];
+#else
+    static int mallocInit = 0;
+    static uint8_t * rgb, *py, *pu, *pv;
+#endif
+
+static uint8_t s_decodeBuf[DEMO_DECODE_BUF_SIZE];
+
+/**********************
+ *      MACROS
+ **********************/
+
+/**********************
+ *   GLOBAL FUNCTIONS
+ **********************/
+
+/**
+ * Create an image button object
+ * @param parent pointer to an object, it will be the parent of the new image button
+ * @return pointer to the created image button
+ */
+lv_obj_t * lv_video_create(lv_obj_t * parent, int widgetWidth, int widgetHeight)
+{
+    LV_LOG_INFO("begin");
+
+    video_width = widgetWidth;
+    video_height = widgetHeight;
+
+#if !LV_USE_GUIDER_SIMULATOR
+    s_lcdBuffer[0] = malloc(widgetWidth * widgetHeight * buffer_byte_per_pixel);
+    s_lcdBuffer[1] = malloc(widgetWidth * widgetHeight * buffer_byte_per_pixel);
+#endif
+
+    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);
+    lv_obj_class_init_obj(obj);
+    return obj;
+}
+
+void lv_video_play(lv_obj_t * obj)
+{
+    lv_video_t * video = (lv_video_t *)obj;
+    Read_HFile(video->file_name, obj);
+}
+
+static int search_nalu(const uint8_t * data, int32_t len)
+{
+    int i;
+    /* parse NALU 00 00 00 01 or 00 00 01 */
+    for(i = 1; i < len - 4; i++) {
+        if((data[i] == 0 && data[i + 1] == 0 && data[i + 2] == 0 && data[i + 3] == 1) ||
+           (data[i] == 0 && data[i + 1] == 0 && data[i + 2] == 1)) {
+            return i;
+        }
+    }
+
+    if(data[i] == 0 && data[i + 1] == 0 && data[i + 2] == 1) {
+        return i;
+    }
+
+    return -1;
+}
+
+int Decoder_Data(const uint8_t * data, int len, bool isStartOfFile, bool isEndOfFile, lv_obj_t * obj)
+{
+    lv_video_t * video = (lv_video_t *)obj;
+    SBufferInfo sDstBufInfo = {0};
+    int32_t copiedLen = 0;
+    int32_t sliceSize = 0;
+    uint8_t * dst[3];
+    int32_t num_of_frames_in_buffer = 0;
+    int32_t leftDataLen;
+
+    static int32_t decodeBufStart = 0;
+    static int32_t decodeBufEnd   = 0;
+
+    if(isStartOfFile) {
+        decodeBufStart         = 0;
+        decodeBufEnd           = 0;
+    }
+    leftDataLen = len;
+
+    while(leftDataLen > 0) {
+        copiedLen = MIN(leftDataLen, ((int32_t)sizeof(s_decodeBuf) - decodeBufEnd));
+
+        /* Copy the input data to the end of decode buffer. */
+        memcpy(&s_decodeBuf[decodeBufEnd], data, copiedLen);
+        decodeBufEnd += copiedLen;
+        data += copiedLen;
+        leftDataLen -= copiedLen;
+
+        while(decodeBufStart < decodeBufEnd) {
+            sliceSize = search_nalu(&s_decodeBuf[decodeBufStart], decodeBufEnd - decodeBufStart);
+            if(video->exist) {
+                return 0;
+            }
+            /* Could not find NALU. */
+            if(sliceSize < 0) {
+                /* This is the file end part, pass them all to H264 decoder. */
+                if(isEndOfFile && (0 == leftDataLen)) {
+                    sliceSize = decodeBufEnd - decodeBufStart;
+                }
+                else {
+                    /* After searching the full buffer, no slice found, then drop the data in buffer. */
+                    if((decodeBufStart == 0) && (decodeBufEnd == sizeof(s_decodeBuf))) {
+                        /* Drop the decode buffer, fill using left input data. */
+                        decodeBufEnd   = 0;
+                        decodeBufStart = 0;
+                    }
+
+                    /* Have processed all slice in the buffer. */
+                    break;
+                }
+            }
+            /* Slice size too small, skip it. */
+            else if(sliceSize < 4) {
+                decodeBufStart += sliceSize;
+                continue;
+            }
+            /* Found NALU, decode. */
+            if(OpenH264_Decode(&s_decodeBuf[decodeBufStart], sliceSize, dst, &sDstBufInfo) == 0) {
+                if(sDstBufInfo.iBufferStatus == 1) {
+#if LV_USE_GUIDER_SIMULATOR
+                    CPU_DisplayFrame(sDstBufInfo, dst, obj);
+#else
+                    PXP_DisplayFrame(
+                        sDstBufInfo.UsrData.sSystemBuffer.iWidth, sDstBufInfo.UsrData.sSystemBuffer.iHeight,
+                        sDstBufInfo.pDst[0], sDstBufInfo.pDst[1], sDstBufInfo.pDst[2],
+                        sDstBufInfo.UsrData.sSystemBuffer.iStride[0], sDstBufInfo.UsrData.sSystemBuffer.iStride[1], obj);
+#endif
+                }
+
+            }
+            else {
+                LV_LOG_ERROR("decode error\r\n");
+            }
+
+            decodeBufStart += sliceSize;
+        }
+
+        /* Move the left data in decode buffer to the start of decode buffer,
+         * left input data will be appended to the end.
+         */
+        memcpy(s_decodeBuf, &s_decodeBuf[decodeBufStart], decodeBufEnd - decodeBufStart);
+        decodeBufEnd -= decodeBufStart;
+        decodeBufStart = 0;
+    }
+
+    if(isEndOfFile) {
+        OpenH264_GetOption(&num_of_frames_in_buffer);
+        for(int32_t i = 0; i < num_of_frames_in_buffer; i++) {
+            dst[0] = NULL;
+            dst[1] = NULL;
+            dst[2] = NULL;
+
+            OpenH264_FlashFrame(dst, &sDstBufInfo);
+            if(sDstBufInfo.iBufferStatus == 1) {
+#if LV_USE_GUIDER_SIMULATOR
+                CPU_DisplayFrame(sDstBufInfo, dst, obj);
+#else
+                PXP_DisplayFrame(
+                    sDstBufInfo.UsrData.sSystemBuffer.iWidth, sDstBufInfo.UsrData.sSystemBuffer.iHeight,
+                    sDstBufInfo.pDst[0], sDstBufInfo.pDst[1], sDstBufInfo.pDst[2],
+                    sDstBufInfo.UsrData.sSystemBuffer.iStride[0], sDstBufInfo.UsrData.sSystemBuffer.iStride[1], obj);
+#endif
+            }
+        }
+    }
+
+    return 0;
+}
+
+void Read_HFile(const char * fileName, lv_obj_t * obj)
+{
+    lv_video_t * video = (lv_video_t *)obj;
+    uint32_t bytesRead;
+    while(1) {
+        int error = lv_fs_open(&video->h264File, video->file_name, LV_FS_MODE_RD);
+        if(error != LV_FS_RES_OK) {
+            break;
+        }
+        video->fileStart = true;
+        while(1) {
+            if(video->play_status == 1) {
+                error = lv_fs_read(&video->h264File, video->blk.data, DEMO_FILE_BUF_SIZE, &bytesRead);
+                if(error != LV_FS_RES_OK) {
+                    break;
+                }
+                video->blk.len           = bytesRead;
+                video->blk.isEndOfFile   = (DEMO_FILE_BUF_SIZE > bytesRead);
+                video->blk.isStartOfFile = video->fileStart;
+                video->fileStart         = false;
+                Decoder_Data(video->blk.data, video->blk.len, video->blk.isStartOfFile, video->blk.isEndOfFile, obj);
+                if(video->blk.isEndOfFile) {
+                    break;
+                }
+                if(video->exist) {
+                    video->blk.data = NULL;
+                    lv_fs_close(&video->h264File);
+                    return;
+                }
+            }
+            else {
+
+#if LV_USE_GUIDER_SIMULATOR
+                lv_task_handler();
+                usleep(5 * 1000);
+#else
+                vTaskDelay(5);
+#endif
+                continue;
+            }
+        }
+        lv_fs_close(&video->h264File);
+    }
+}
+
+#if !LV_USE_GUIDER_SIMULATOR
+int Video_InitPXP()
+{
+    /* Initialize variables. */
+
+
+    memset(&s_pxpPsBufferConfig, 0, sizeof(s_pxpPsBufferConfig));
+    memset(&s_pxpOutputBufferConfig, 0, sizeof(s_pxpOutputBufferConfig));
+    memset(s_lcdBuffer[0], 0, video_width * video_height * buffer_byte_per_pixel);
+    memset(s_lcdBuffer[1], 0, video_width * video_height * buffer_byte_per_pixel);
+    s_pxpPsBufferConfig.pixelFormat = kPXP_PsPixelFormatYVU420;
+    s_pxpPsBufferConfig.swapByte    = false,
+
+    s_pxpOutputBufferConfig.pixelFormat    = kPXP_OutputPixelFormatRGB565;
+    s_pxpOutputBufferConfig.interlacedMode = kPXP_OutputProgressive;
+    s_pxpOutputBufferConfig.buffer1Addr    = 0U,
+    s_pxpOutputBufferConfig.pitchBytes     = (video_width * buffer_byte_per_pixel);
+
+    /* Initialize hardware. */
+    PXP_Init(PXP);
+
+    PXP_SetProcessSurfaceBackGroundColor(PXP, 0U);
+
+    /* Disable AS. */
+    PXP_SetAlphaSurfacePosition(PXP, 0xFFFFU, 0xFFFFU, 0U, 0U);
+
+    PXP_SetCsc1Mode(PXP, kPXP_Csc1YCbCr2RGB);
+    PXP_EnableCsc1(PXP, true);
+
+    return 0;
+}
+
+static void PXP_DisplayFrame(uint16_t width,
+                             uint16_t height,
+                             const uint8_t * Y,
+                             const uint8_t * U,
+                             const uint8_t * V,
+                             uint32_t Y_Stride,
+                             uint32_t UV_Stride,
+                             lv_obj_t * obj)
+{
+    lv_video_t * video = (lv_video_t *)obj;
+    void * lcdFrameAddr;
+    bool rotate                    = false;
+    static uint16_t oldInputWidth  = 0U;
+    static uint16_t oldInputHeight = 0U;
+
+    uint16_t lcdWidth  = video_width;
+    uint16_t lcdHeight = video_height;
+
+    DCACHE_CleanInvalidateByRange((uint32_t)Y, height * Y_Stride);
+    DCACHE_CleanInvalidateByRange((uint32_t)U, height * UV_Stride / 2);
+    DCACHE_CleanInvalidateByRange((uint32_t)V, height * UV_Stride / 2);
+
+    /* PS configure. */
+    s_pxpPsBufferConfig.bufferAddr  = (uint32_t)Y;
+    s_pxpPsBufferConfig.bufferAddrU = (uint32_t)U;
+    s_pxpPsBufferConfig.bufferAddrV = (uint32_t)V;
+    s_pxpPsBufferConfig.pitchBytes  = Y_Stride;
+
+    PXP_SetProcessSurfaceBufferConfig(PXP, &s_pxpPsBufferConfig);
+
+    /* Input frame size changed. */
+    if((oldInputHeight != height) || (oldInputWidth != width)) {
+
+        rotate = (height > width);
+
+        if(rotate) {
+            s_pxpOutputBufferConfig.width  = lcdHeight;
+            s_pxpOutputBufferConfig.height = lcdWidth;
+
+            PXP_SetRotateConfig(PXP, kPXP_RotateOutputBuffer, kPXP_Rotate90, kPXP_FlipDisable);
+            PXP_SetProcessSurfaceScaler(PXP, width, height, lcdHeight, lcdWidth);
+            PXP_SetProcessSurfacePosition(PXP, 0, 0, lcdHeight - 1, lcdWidth - 1);
+        }
+        else {
+            s_pxpOutputBufferConfig.width  = lcdWidth;
+            s_pxpOutputBufferConfig.height = lcdHeight;
+
+            PXP_SetProcessSurfaceScaler(PXP, width, height, lcdWidth, lcdHeight);
+            PXP_SetProcessSurfacePosition(PXP, 0, 0, lcdWidth - 1, lcdHeight - 1);
+        }
+
+        oldInputHeight = height;
+        oldInputWidth  = width;
+    }
+
+    lcdFrameAddr                              = s_lcdBuffer[s_lcdActiveFbIdx ^ 1];
+    s_pxpOutputBufferConfig.buffer0Addr = (uint32_t)lcdFrameAddr;
+
+    PXP_SetOutputBufferConfig(PXP, &s_pxpOutputBufferConfig);
+    PXP_Start(PXP);
+
+    while(0U == (kPXP_CompleteFlag & PXP_GetStatusFlags(PXP))) {
+    }
+    PXP_ClearStatusFlags(PXP, kPXP_CompleteFlag);
+
+    video->frameImage.data = lcdFrameAddr;
+    s_lcdActiveFbIdx ^= 1;
+    lv_img_set_src(obj, &video->frameImage);
+}
+#else
+static void CPU_DisplayFrame(SBufferInfo sDstBufInfo, unsigned char ** dst, lv_obj_t * obj)
+{
+    lv_video_t * video = (lv_video_t *)obj;
+    int width = 0;
+    int height = 0;
+    if(sDstBufInfo.iBufferStatus == 1) {
+        width = sDstBufInfo.UsrData.sSystemBuffer.iWidth;
+        height = sDstBufInfo.UsrData.sSystemBuffer.iHeight;
+        int YStride = sDstBufInfo.UsrData.sSystemBuffer.iStride[0];
+        int UVStride = sDstBufInfo.UsrData.sSystemBuffer.iStride[1];
+        unsigned char * pPtr = NULL;
+        if(mallocInit == 0) {
+            rgb = malloc(2 * width * height);
+            py = malloc(width * height);
+            pu = malloc(width * height / 4);
+            pv = malloc(width * height / 4);
+            mallocInit = 1;
+        }
+        pPtr = dst[0];
+        for(int i = 0; i < height; i++) {
+            memcpy(py + i * width, pPtr, width);
+            pPtr += YStride;
+        }
+
+        height = height / 2;
+        width = width / 2;
+        pPtr = dst[1];
+        for(int i = 0; i < height; i++) {
+            memcpy(pu + i * width, pPtr, width);
+            pPtr += UVStride;
+        }
+        pPtr = dst[2];
+        for(int i = 0; i < height; i++) {
+            memcpy(pv + i * width, pPtr, width);
+            pPtr += UVStride;
+        }
+        yuv420pToRgb565(width * 2, height * 2, video_width, video_height, py, pu, pv, (uint16_t *)rgb);
+        // update the image data.
+        video->frameImage.data = rgb;
+        lv_img_set_src(obj, &video->frameImage);
+        lv_img_cache_invalidate_src(lv_img_get_src(obj));
+        lv_obj_invalidate(obj);
+        lv_task_handler();
+        usleep(30 * 1000);
+    }
+}
+
+static void yuv420pToRgb565(int oriWidth, int oriHeight, int width, int height, uint8_t * py, uint8_t * pu,
+                            uint8_t * pv, unsigned short * dst)
+{
+    int y, u, v, yy, vr, ug, vg, ub;
+    int r, g, b;
+    int oriLine, oriCol;
+
+    for(int i = 0; i < height; i++) {
+        oriLine = i * oriHeight / height;
+        for(int j = 0; j < width; j++) {
+            oriCol = j * oriWidth / width;
+            y = py[oriLine * oriWidth + oriCol];
+            yy = y << 8;
+            u = pu[(oriLine / 2) * (oriWidth / 2) + (oriCol / 2)] - 128;
+            ug = 88 * u;
+            ub = 454 * u;
+            v = pv[(oriLine / 2) * (oriWidth / 2) + (oriCol / 2)] - 128;
+            vg = 183 * v;
+            vr = 359 * v;
+
+            r = (yy + vr) >> 8;
+            g = (yy - ug - vg) >> 8;
+            b = (yy + ub) >> 8;
+            if(r < 0)
+                r = 0;
+            if(r > 255)
+                r = 255;
+            if(g < 0)
+                g = 0;
+            if(g > 255)
+                g = 255;
+            if(b < 0)
+                b = 0;
+            if(b > 255)
+                b = 255;
+            dst[i * width + j] = (((unsigned short)r >> 3) << 11) | (((unsigned short)g >> 2) << 5) | (((
+                                                                                                            unsigned short)b >> 3) << 0);
+        }
+    }
+}
+#endif
+
+/*=====================
+ * Setter functions
+ *====================*/
+
+void lv_video_set_src(lv_obj_t * obj, const char * src)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+    lv_video_t * video = (lv_video_t *)obj;
+
+    video->file_name = src;
+}
+
+void lv_video_set_status(lv_obj_t * obj, int status)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+    lv_video_t * video = (lv_video_t *)obj;
+
+    video->play_status = status;
+}
+
+/*=====================
+ * Getter functions
+ *====================*/
+int lv_video_get_status(lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+    lv_video_t * video = (lv_video_t *)obj;
+
+    return video->play_status;
+}
+
+
+const char * lv_video_get_src(lv_obj_t * obj)
+{
+    LV_ASSERT_OBJ(obj, MY_CLASS);
+
+    lv_video_t * video = (lv_video_t *)obj;
+
+    return video->file_name;
+}
+
+
+/**********************
+ *   STATIC FUNCTIONS
+ **********************/
+
+static void lv_video_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    lv_video_t * video = (lv_video_t *)obj;
+
+    video->play_status = 1;
+    video->exist = false;
+    OpenH264_Init();
+    video->frameImage.header.always_zero = 0;
+    video->frameImage.header.cf = LV_IMG_CF_TRUE_COLOR;
+    video->frameImage.header.w = video_width;
+    video->frameImage.header.h = video_height;
+    video->frameImage.data_size = video_width * video_height * LV_COLOR_SIZE / 8;
+    video->blk.data = (uint8_t *)malloc(DEMO_FILE_BUF_SIZE + 4);
+    video->frameImage.data = NULL;
+    video->fileStart = true;
+    LV_TRACE_OBJ_CREATE("finished");
+    lv_obj_update_layout(obj);
+}
+
+static void lv_video_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
+{
+    LV_UNUSED(class_p);
+    lv_video_t * video = (lv_video_t *)obj;
+    video->exist = true;
+    if(video->blk.data) {
+        free(video->blk.data);
+        video->blk.data = NULL;
+    }
+
+#if LV_USE_GUIDER_SIMULATOR
+    mallocInit = 0;
+    if(rgb) {
+        free(py);
+        free(pu);
+        free(pv);
+        free(rgb);
+    }
+#else
+    if(s_lcdBuffer[0] != NULL && s_lcdBuffer[1] != NULL) {
+        free(s_lcdBuffer[0]);
+        free(s_lcdBuffer[1]);
+        s_lcdBuffer[0] = NULL;
+        s_lcdBuffer[1] = NULL;
+    }
+#endif
+    lv_img_cache_invalidate_src(lv_img_get_src(obj));
+}
+#endif
diff --git a/src/extra/widgets/video/lv_video.h b/src/extra/widgets/video/lv_video.h
new file mode 100644
index 000000000..b13af20d7
--- /dev/null
+++ b/src/extra/widgets/video/lv_video.h
@@ -0,0 +1,114 @@
+/**
+ * @file lv_video.h
+ *
+ */
+
+#ifndef LV_VIDEO_H
+#define LV_VIDEO_H
+#if !defined(MIN)
+    #define MIN(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "../../../lvgl.h"
+
+#if LV_USE_VIDEO != 0
+
+/*********************
+ *      DEFINES
+ *********************/
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+
+typedef struct {
+    uint8_t * data;     /* Pointer to data. */
+    uint32_t len;        /* Length of the data. */
+    bool isEndOfFile;   /* Has reached file end. */
+    bool isStartOfFile; /* Is start of file. */
+} file_data_block_t;
+
+typedef struct {
+    lv_obj_t obj;
+    const void * src; /*Image source: Pointer to an array or a file or a symbol*/
+    lv_point_t offset;
+    lv_coord_t w;          /*Width of the image (Handled by the library)*/
+    lv_coord_t h;          /*Height of the image (Handled by the library)*/
+    uint16_t angle;    /*rotation angle of the image*/
+    lv_point_t pivot;     /*rotation center of the image*/
+    uint16_t zoom;         /*256 means no zoom, 512 double size, 128 half size*/
+    uint8_t src_type : 2;  /*See: lv_img_src_t*/
+    uint8_t cf : 5;        /*Color format from `lv_img_color_format_t`*/
+    uint8_t antialias : 1; /*Apply anti-aliasing in transformations (rotate, zoom)*/
+    uint8_t obj_size_mode: 2; /*Image size mode when image size and object size is different.*/
+    int play_status;
+    const char * file_name;
+    lv_img_dsc_t frameImage;
+    lv_fs_file_t h264File;
+    file_data_block_t blk;
+    bool  fileStart;
+    bool exist;
+} lv_video_t;
+
+extern const lv_obj_class_t lv_video_class;
+
+/**********************
+ * GLOBAL PROTOTYPES
+ **********************/
+void lv_video_play(lv_obj_t * obj);
+
+void Read_HFile(const char * fileName, lv_obj_t * obj);
+int Video_InitPXP();
+/**
+ * Create an image button object
+ * @param parent pointer to an object, it will be the parent of the new image button
+ * @return pointer to the created image button
+ */
+lv_obj_t * lv_video_create(lv_obj_t * parent, int widgetWidth, int widgetHeight);
+
+
+/*======================
+ * Add/remove functions
+ *=====================*/
+
+/*=====================
+ * Setter functions
+ *====================*/
+
+/**
+ * Set images for a state of the image button
+ * @param obj pointer to an image button object
+ * @param state for which state set the new image
+ */
+void lv_video_set_src(lv_obj_t * obj, const char * src);
+
+void lv_video_set_status(lv_obj_t * obj, int status);
+/*=====================
+ * Getter functions
+ *====================*/
+
+int lv_video_get_status(lv_obj_t * obj);
+const char * lv_video_get_src(lv_obj_t * obj);
+
+/*=====================
+ * Other functions
+ *====================*/
+
+/**********************
+ *      MACROS
+ **********************/
+
+#endif /*LV_USE_VIDEO*/
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*LV_VIDEO_H*/
diff --git a/src/lv_conf_internal.h b/src/lv_conf_internal.h
index 0c297081c..e349fdf8c 100644
--- a/src/lv_conf_internal.h
+++ b/src/lv_conf_internal.h
@@ -1499,6 +1499,39 @@
     #endif
 #endif
 
+#ifndef LV_USE_DCLOCK
+    #ifdef _LV_KCONFIG_PRESENT
+        #ifdef CONFIG_LV_USE_DCLOCK
+            #define LV_USE_DCLOCK CONFIG_LV_USE_DCLOCK
+        #else
+            #define LV_USE_DCLOCK 0
+        #endif
+    #else
+        #define LV_USE_DCLOCK      1
+    #endif
+#endif
+#if LV_USE_DCLOCK
+    #ifndef LV_DCLOCK_TEXT_SELECTION
+        #ifdef CONFIG_LV_DCLOCK_TEXT_SELECTION
+            #define LV_DCLOCK_TEXT_SELECTION CONFIG_LV_DCLOCK_TEXT_SELECTION
+        #else
+            #define LV_DCLOCK_TEXT_SELECTION 1 /*Enable selecting text of the dclock*/
+        #endif
+    #endif
+#endif
+
+#ifndef LV_USE_VIDEO
+    #ifdef _LV_KCONFIG_PRESENT
+        #ifdef CONFIG_LV_USE_VIDEO
+            #define LV_USE_VIDEO CONFIG_LV_USE_VIDEO
+        #else
+            #define LV_USE_VIDEO 0
+        #endif
+    #else
+        #define LV_USE_VIDEO      1
+    #endif
+#endif
+
 #ifndef LV_USE_LINE
     #ifdef _LV_KCONFIG_PRESENT
         #ifdef CONFIG_LV_USE_LINE
@@ -1676,6 +1709,18 @@
     #endif
 #endif  /*LV_USE_CALENDAR*/
 
+#ifndef LV_USE_CAROUSEL
+    #ifdef _LV_KCONFIG_PRESENT
+        #ifdef CONFIG_LV_USE_CAROUSEL
+            #define LV_USE_CAROUSEL CONFIG_LV_USE_CAROUSEL
+        #else
+            #define LV_USE_CAROUSEL 0
+        #endif
+    #else
+        #define LV_USE_CAROUSEL  1
+    #endif
+#endif
+
 #ifndef LV_USE_CHART
     #ifdef _LV_KCONFIG_PRESENT
         #ifdef CONFIG_LV_USE_CHART
@@ -1724,6 +1769,27 @@
     #endif
 #endif
 
+#ifndef LV_USE_ZH_KEYBOARD
+    #ifdef _LV_KCONFIG_PRESENT
+        #ifdef CONFIG_LV_USE_ZH_KEYBOARD
+            #define LV_USE_ZH_KEYBOARD CONFIG_LV_USE_ZH_KEYBOARD
+        #else
+            #define LV_USE_ZH_KEYBOARD 0
+        #endif
+    #else
+        #define LV_USE_ZH_KEYBOARD   1
+    #endif
+#endif
+#if LV_USE_ZH_KEYBOARD
+    #ifndef LV_ZH_KEYBOARD_MINI
+        #ifdef CONFIG_LV_ZH_KEYBOARD_MINI
+            #define LV_ZH_KEYBOARD_MINI CONFIG_LV_ZH_KEYBOARD_MINI
+        #else
+            #define LV_ZH_KEYBOARD_MINI   1
+        #endif
+    #endif
+#endif
+
 #ifndef LV_USE_LED
     #ifdef _LV_KCONFIG_PRESENT
         #ifdef CONFIG_LV_USE_LED
@@ -1772,6 +1838,14 @@
     #endif
 #endif
 
+#ifndef LV_USE_ANALOGCLOCK
+#  ifdef CONFIG_LV_USE_ANALOGCLOCK
+#    define LV_USE_ANALOGCLOCK CONFIG_LV_USE_ANALOGCLOCK
+#  else
+#    define  LV_USE_ANALOGCLOCK        1
+#  endif
+#endif
+
 #ifndef LV_USE_MSGBOX
     #ifdef _LV_KCONFIG_PRESENT
         #ifdef CONFIG_LV_USE_MSGBOX
@@ -1784,6 +1858,18 @@
     #endif
 #endif
 
+#ifndef LV_USE_RADIOBTN
+    #ifdef _LV_KCONFIG_PRESENT
+        #ifdef CONFIG_LV_USE_RADIOBTN
+            #define LV_USE_RADIOBTN CONFIG_LV_USE_RADIOBTN
+        #else
+            #define LV_USE_RADIOBTN 0
+        #endif
+    #else
+        #define LV_USE_RADIOBTN   1
+    #endif
+#endif
+
 #ifndef LV_USE_SPAN
     #ifdef _LV_KCONFIG_PRESENT
         #ifdef CONFIG_LV_USE_SPAN
@@ -1842,6 +1928,18 @@
     #endif
 #endif
 
+#ifndef LV_USE_TEXTPROGRESS
+    #ifdef _LV_KCONFIG_PRESENT
+        #ifdef CONFIG_LV_USE_TEXTPROGRESS
+            #define LV_USE_TEXTPROGRESS CONFIG_LV_USE_TEXTPROGRESS
+        #else
+            #define LV_USE_TEXTPROGRESS 0
+        #endif
+    #else
+        #define LV_USE_TEXTPROGRESS 1
+    #endif
+#endif
+
 #ifndef LV_USE_TILEVIEW
     #ifdef _LV_KCONFIG_PRESENT
         #ifdef CONFIG_LV_USE_TILEVIEW
@@ -2124,6 +2222,33 @@
     #endif
 #endif
 
+/*API for RAWFS (needs to be added separately).*/
+#ifndef LV_USE_FS_RAWFS
+    #ifdef CONFIG_LV_USE_FS_RAWFS
+        #define LV_USE_FS_RAWFS CONFIG_LV_USE_FS_RAWFS
+    #else
+        #define LV_USE_FS_RAWFS 0
+    #endif
+#endif
+#if LV_USE_FS_RAWFS
+    #ifndef LV_FS_RAWFS_LETTER
+        #ifdef CONFIG_LV_FS_RAWFS_LETTER
+            #define LV_FS_RAWFS_LETTER CONFIG_LV_FS_RAWFS_LETTER
+        #else
+            #define LV_FS_RAWFS_LETTER 'F'
+        #endif
+    #endif
+    #if LV_FS_RAWFS_XIP
+        #ifndef LV_FS_RAWFS_XIP_BASE_ADDR
+            #ifdef CONFIG_LV_FS_RAWFS_XIP_BASE_ADDR
+                #define LV_FS_RAWFS_XIP_BASE_ADDR CONFIG_LV_FS_RAWFS_XIP_BASE_ADDR
+            #else
+                #define LV_FS_RAWFS_XIP_BASE_ADDR 0xFFFFFFFF
+            #endif
+        #endif
+    #endif
+#endif
+
 /*PNG decoder library*/
 #ifndef LV_USE_PNG
     #ifdef CONFIG_LV_USE_PNG
@@ -2170,6 +2295,15 @@
     #endif
 #endif
 
+/*Barcode library*/
+#ifndef LV_USE_BARCODE
+    #ifdef CONFIG_LV_USE_BARCODE
+        #define LV_USE_BARCODE CONFIG_LV_USE_BARCODE
+    #else
+        #define LV_USE_BARCODE 0
+    #endif
+#endif
+
 /*FreeType library*/
 #ifndef LV_USE_FREETYPE
     #ifdef CONFIG_LV_USE_FREETYPE
diff --git a/src/misc/lv_anim.c b/src/misc/lv_anim.c
index 4e4253a6e..4caa70566 100644
--- a/src/misc/lv_anim.c
+++ b/src/misc/lv_anim.c
@@ -71,6 +71,7 @@ void lv_anim_init(lv_anim_t * a)
     a->repeat_cnt = 1;
     a->path_cb = lv_anim_path_linear;
     a->early_apply = 1;
+    a->anim_pause = false;
 }
 
 lv_anim_t * lv_anim_start(const lv_anim_t * a)
@@ -135,6 +136,45 @@ uint32_t lv_anim_get_playtime(lv_anim_t * a)
     return playtime;
 }
 
+bool lv_anim_pause(void * var, lv_anim_exec_xcb_t exec_cb)
+{
+    lv_anim_t * a;
+    lv_anim_t * a_next;
+    bool pause = false;
+    a        = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
+    while(a != NULL) {
+        a_next = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
+
+        if((a->var == var || var == NULL) && (a->exec_cb == exec_cb || exec_cb == NULL)) {
+            a->anim_pause = true;
+            anim_mark_list_change();
+            pause = true;
+        }
+
+        a = a_next;
+    }
+    return pause;
+}
+
+bool lv_anim_resume(void * var, lv_anim_exec_xcb_t exec_cb)
+{
+    lv_anim_t * a;
+    lv_anim_t * a_next;
+    bool resume = false;
+    a        = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
+    while(a != NULL) {
+        a_next = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
+
+        if((a->var == var || var == NULL) && (a->exec_cb == exec_cb || exec_cb == NULL)) {
+            a->anim_pause = false;
+            anim_mark_list_change();
+            resume = true;
+        }
+        a = a_next;
+    }
+    return resume;
+}
+
 bool lv_anim_del(void * var, lv_anim_exec_xcb_t exec_cb)
 {
     lv_anim_t * a;
@@ -365,7 +405,8 @@ static void anim_timer(lv_timer_t * param)
          */
         anim_list_changed = false;
 
-        if(a->run_round != anim_run_round) {
+        /*Add the animation pause flag check*/
+        if(a->run_round != anim_run_round && !a->anim_pause) {
             a->run_round = anim_run_round; /*The list readying might be reset so need to know which anim has run already*/
 
             /*The animation will run now for the first time. Call `start_cb`*/
diff --git a/src/misc/lv_anim.h b/src/misc/lv_anim.h
index faef72787..dcd8378cd 100644
--- a/src/misc/lv_anim.h
+++ b/src/misc/lv_anim.h
@@ -96,6 +96,7 @@ typedef struct _lv_anim_t {
     uint8_t playback_now : 1; /**< Play back is in progress*/
     uint8_t run_round : 1;    /**< Indicates the animation has run in this round*/
     uint8_t start_cb_called : 1;    /**< Indicates that the `start_cb` was already called*/
+    bool anim_pause;
 } lv_anim_t;
 
 /**********************
@@ -347,6 +348,24 @@ static inline void * lv_anim_get_user_data(lv_anim_t * a)
  */
 bool lv_anim_del(void * var, lv_anim_exec_xcb_t exec_cb);
 
+/**
+ * Pause an animation of a variable with a given animator function
+ * @param var       pointer to variable
+ * @param exec_cb   a function pointer which is animating 'var',
+ *                  or NULL to ignore it and delete all the animations of 'var
+ * @return          true: at least 1 animation is stoped, false: no animation is stoped
+ */
+bool lv_anim_pause(void * var, lv_anim_exec_xcb_t exec_cb);
+
+/**
+ * Resume an animation of a variable with a given animator function
+ * @param var       pointer to variable
+ * @param exec_cb   a function pointer which is animating 'var',
+ *                  or NULL to ignore it and delete all the animations of 'var
+ * @return          true: at least 1 animation is resumed, false: no animation is resumed
+ */
+bool lv_anim_resume(void * var, lv_anim_exec_xcb_t exec_cb);
+
 /**
  * Delete all the animations
  */
diff --git a/src/widgets/lv_arc.c b/src/widgets/lv_arc.c
index 63cf57740..3bb6e3514 100644
--- a/src/widgets/lv_arc.c
+++ b/src/widgets/lv_arc.c
@@ -553,6 +553,11 @@ static void lv_arc_event(const lv_obj_class_t * class_p, lv_event_t * e)
         /*Set the new value*/
         int16_t old_value = arc->value;
         int16_t new_value = lv_map(angle, arc->bg_angle_start, bg_end, arc->min_value, arc->max_value);
+        if(arc->type == LV_ARC_MODE_REVERSE) {
+            new_value = arc->max_value - new_value + arc->min_value;
+        }
+
+
         if(new_value != lv_arc_get_value(obj)) {
             arc->last_tick = lv_tick_get(); /*Cache timestamp for the next iteration*/
             lv_arc_set_value(obj, new_value); /*set_value caches the last_angle for the next iteration*/
diff --git a/src/widgets/lv_btnmatrix.c b/src/widgets/lv_btnmatrix.c
index fd14e56e9..1b0cdc398 100644
--- a/src/widgets/lv_btnmatrix.c
+++ b/src/widgets/lv_btnmatrix.c
@@ -104,13 +104,22 @@ void lv_btnmatrix_set_map(lv_obj_t * obj, const char * map[])
     lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);
 
     /*Set size and positions of the buttons*/
+    lv_coord_t bwidth = lv_obj_get_style_border_width(obj, LV_PART_MAIN);
+    lv_coord_t bside = lv_obj_get_style_border_side(obj, LV_PART_MAIN);
     lv_coord_t pleft = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);
+    lv_coord_t sleft = (bside & LV_BORDER_SIDE_LEFT) ? pleft + bwidth : pleft;
     lv_coord_t ptop = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);
+    lv_coord_t stop = (bside & LV_BORDER_SIDE_TOP) ? ptop + bwidth : ptop;
+    lv_coord_t pright = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);
+    lv_coord_t sright = (bside & LV_BORDER_SIDE_RIGHT) ? pright + bwidth : pright;
+    lv_coord_t pbottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);
+    lv_coord_t sbottom = (bside & LV_BORDER_SIDE_BOTTOM) ? pbottom + bwidth : pbottom;
+
     lv_coord_t prow = lv_obj_get_style_pad_row(obj, LV_PART_MAIN);
     lv_coord_t pcol = lv_obj_get_style_pad_column(obj, LV_PART_MAIN);
 
-    lv_coord_t max_w            = lv_obj_get_content_width(obj);
-    lv_coord_t max_h            = lv_obj_get_content_height(obj);
+    lv_coord_t max_w            = lv_obj_get_width(obj) - sleft - sright;
+    lv_coord_t max_h            = lv_obj_get_height(obj) - stop - sbottom;
 
     /*Calculate the position of each row*/
     lv_coord_t max_h_no_gap = max_h - (prow * (btnm->row_cnt - 1));
@@ -138,8 +147,8 @@ void lv_btnmatrix_set_map(lv_obj_t * obj, const char * map[])
             continue;
         }
 
-        lv_coord_t row_y1 = ptop + (max_h_no_gap * row) / btnm->row_cnt + row * prow;
-        lv_coord_t row_y2 = ptop + (max_h_no_gap * (row + 1)) / btnm->row_cnt + row * prow - 1;
+        lv_coord_t row_y1 = stop + (max_h_no_gap * row) / btnm->row_cnt + row * prow;
+        lv_coord_t row_y2 = stop + (max_h_no_gap * (row + 1)) / btnm->row_cnt + row * prow - 1;
 
         /*Set the button size and positions*/
         lv_coord_t max_w_no_gap = max_w - (pcol * (btn_cnt - 1));
@@ -163,8 +172,8 @@ void lv_btnmatrix_set_map(lv_obj_t * obj, const char * map[])
                 btn_x2 = max_w - btn_x2;
             }
 
-            btn_x1 += pleft;
-            btn_x2 += pleft;
+            btn_x1 += sleft;
+            btn_x2 += sleft;
 
             lv_area_set(&btnm->button_areas[btn_tot_i], btn_x1, row_y1, btn_x2, row_y2);
 
-- 
2.34.1

